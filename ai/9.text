----------------------------------------------------------------------
9. 인공지능을 움직이는 힘, 알고리즘
----------------------------------------------------------------------

[1 페이지]
지난 차시 때 제시한 하노이의 탑 알고리즘입니다.
규칙은 A 기둥에 쌓인 선반을 모두 C 기둥으로 옮기되 작은 원반 위에 큰 원반이 올라가서는 안 되며 한 번에 한 개씩만 이동해야 합니다.
여러분은 어떻게 C 기둥으로 모든 선반을 옮기시겠습니까?

정답은 다음과 같습니다.
1단계입니다. A 기둥에 있는 가장 위의 3번 원판을 오른쪽 C 기둥으로 옮깁니다.
2단계, A 기둥 위에 있는 2번 원판을 가운데 B 기둥으로 옮깁니다.
3단계입니다. 오른쪽 C 기둥의 3번 원판을 가운데 B 기둥으로 옮깁니다.
4단계, 왼쪽 A 기둥의 1번 원판을 오른쪽 C 기둥으로 옮깁니다.
5단계, 가운데 B 기둥 위에 있는 3번 원판을 왼쪽 A 기둥으로 옮깁니다.
6단계입니다. 가운데 B 기둥의 원판을 오른쪽 C 기둥으로 옮깁니다.
7단계, 왼쪽 A 기둥의 3번 원판을 오른쪽 C 기둥으로 옮기면 모든 동작이 종료됩니다.

하노이의 탑 규칙에 따라 일반적으로 원판이 n개일 때 2ⁿ-1번의 이동으로 원판을 모두 옮길 수 있는데요.
원판이 3개이므로 총 7번을 이동하면 원판을 다 옮길 수 있습니다.
만약 이것을 Python이라는 언어로 구현한다면 다음과 같은 프로그램을 실행하여 값을 얻을 수 있습니다.
하노이의 탑은 프로그래밍 수업에서 알고리즘 예제로 많이 사용됩니다.
오늘은 알고리즘에 대해 학습하도록 하겠습니다.





----------------------------------------------------------------------
09_02 알고리즘의 이해
----------------------------------------------------------------------

[2 페이지]
여러분께서 인공지능과 관련된 글, 서적을 읽다 보면 알고리즘이란 용어가 자주 나올 겁니다.
알고리즘이란 문제 해결을 위한 단계들을 체계적으로 명시한 것으로써 문제를 해결하는 방법의 상세한 특징을 기술한 것입니다.

알고리즘이라는 용어는 9세기경 페르시아의 수학자인 al-Khwarizmi의 이름으로부터 유래되었으며 최초의 알고리즘은 BC300년경에 개발된 유클리드의 최대공약수 알고리즘입니다.

유클리드의 최대공약수 알고리즘은 다음과 같습니다.
여러분, 앞에 두 개의 자연수가 있어요.
우리는 그것을 a, b라고 칭하겠습니다.
여기서 a가 b보다 클 때 a를 b로 나눈 나머지를 r이라고 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 같다는 원리입니다.
이 원리에 따라서 a를 b로 나누고 b를 r로 나눈 나머지 r'를 구하고 다시 r을 r'로 나눈 나머지를 구하는 과정을 계속 반복해서 결국에는 나머지가 0이 되었을 때 그 나눈 수가 바로 a와 b의 최대공약수가 된다는 말입니다.

문장으로 설명 드리니까 상당히 복잡하지요.
절차를 정리하면 다음과 같습니다.
a를 b로 나눈다. b를 r로 나눈다. r을 r'로 나눈다. …해서 더 이상 나눠지지 않는 0 단계까지 갈 때 그 나누는 수를 바로 최대공약수로 도출하는 겁니다.

그러면 이러한 방법론에 따라서 저와 함께 몇 개의 문제를 한번 같이 풀어보시도록 하겠습니다.
첫 번째 문제는 12와 18의 최대공약수를 구하시오, 입니다.
여러분도 다 아시지요?
12와 18의 최대공약수, 복잡하게 계산하지 않아도 6이라는 거 쉽게 알 수 있는데 앞서 설명 드린 절차에 따라서 한번 저와 함께 구해 보도록 하겠습니다.

12와 18중 숫자가 큰 것은 18이지요? 그래서 a는 18이 되고 b는 12가 됩니다.
최대공약수를 구하기 위해서 큰 수를 작은 수로 나눕니다.
18을 12로 나누면 몫은 1이 되고 나머지는 6이 되지요.
즉, 여기에서 r 값은 6이 됩니다.
b를 r로 나눕니다.
12를 6으로 나눴더니 몫은 2가 되고 나머지는 0이 됐어요.
더 이상 나뉘지 않는 숫자까지 왔습니다.
이 경우에 이 두 수, 즉 12와 18의 최대공약수는 6이 되는 원리입니다.
문제가 암산으로 풀 수 있을 만큼 쉬웠기 때문에 쉽게 접근했는데 숫자를 조금 키워서 문제를 다시 한번 풀어보도록 하겠습니다.

두 번째 문제는 950과 703의 최대공약수를 구하시오, 입니다.
암산으로 풀이 가능하십니까?
절차에 따라서 문제 한번 풀어보겠습니다.
950과 703중 큰 숫자는 950이니까 a에는 950, b에는 703 숫자를 대입합니다.
a를 b로 나눠야 되겠지요.
950/703 하면 몫은 1이 되고 나머지는 247이 됩니다.
즉, 여기의 r 값이 247이라는 거지요? b를 r로 나누겠습니다.
b값은 703, r 값은 247. 703을 247로 나누면 몫은 몇이 되고? 그렇지요.
몫은 2가 되고 나머지는 209가 됩니다.
r'가 나왔네요.
다시 이런 방식으로 풀겠습니다.
247을 209로 나누면 몫은 1이 되고 r'', 즉 나머지는 38이 되며 다시 209를 38로 나누면 몫은 5가 되고 나머지는 19가 됩니다.
38을 19로 나누면 몫은 몇이 되고? 2가 되고 나머지는 제로, 0이 됩니다. 더 이상 나눌 수 없지요?
그랬을 때 38을 뭐로 나눴더니 2가 됐다? 19로 나눴더니 2로 딱 떨어졌다.
이 경우에 정답은 19가 됩니다.
즉, 950과 703의 최대공약수는 19가 되는 겁니다.

지금 제가 두 개의 문제를 같이 풀어보면서 최대공약수를 한번 구해 봤는데 어렵지 않지요?
이번에는 여러분이 스스로 직접 문제를 풀어보시기 바랍니다.
주어진 문제는 91과 273의 최대공약수를 구하는 문제인데요.
화면 하단의 정지 버튼 잠깐 누른 상태에서 여러분이 주어진 절차에 따라서 한번 직접 구해 보시기 바랍니다.
정답 몇으로 나왔습니까?
정답은 바로 13입니다.
사실 이 절차에 대입해서 문제를 푸는 게 그렇게 어렵지는 않으셨을 것 같아요.

이게 바로 유클리드의 최대공약수 알고리즘입니다.
이처럼 유클리드의 최대공약수 알고리즘을 경험하면서 우리는 두 가지의 메시지를 얻을 수 있을 것으로 생각하는데요.

첫 번째 포인트는 알고리즘은 문제를 해결하기 위한 절차나 방법을 순서대로 나열해서 기록한 것으로 문제를 해결하기 위한 가장 효율적인 절차에 해당한다는 것을 알 수 있어야 되겠고요.

두 번째 포인트로는 사람이 직접 손으로 푸는 것보다 컴퓨터가 알고리즘에 의해서 계산하는 것이 더 빠르다는 것은 누구도 부정할 수 없는 사실입니다.
가령 5,945와 4,551의 최대공약수를 구하라고 했을 때 여러분은 이 절차에 따라서 문제를 푼다고 하면 적어도 10초는 걸릴 것 같아요.
그런데 컴퓨터는 어떠합니까?
미리 만들어진 알고리즘에 두 개의 숫자만 대입하면 되기 때문에 엔터를 치고 0.1초가 되지 않아서 바로 이 두 개 숫자의 최대공약수를 제시할 것입니다.

따라서 복잡한 논리적인 연산을 할 수 있도록, 컴퓨터가 쉽게 계산할 수 있도록 알고리즘을 만들어주는 것이 우리 인간의 역할이 되겠습니다.
이런 알고리즘은 여러 곳에서 사용됩니다.
덧셈과 곱셈, 최대공약수를 구하는 방법 등 기초적인 수학 연산에서도 적용되지만 타이머를 개발하거나 엘리베이터를 설계하거나 지하철 환승 방법을 알려주는 앱 개발 등에도 이러한 알고리즘이 적용됩니다.

앞서 Today’s topic에서 우리가 함께 확인했던 하노이의 탑, 이 문제를 푸는 과정에도 알고리즘이 적용됩니다.
이처럼 알고리즘은 문제를 해결하기 위한 절차나 방법을 의미하는 단어로 매우 넓은 범위에서 사용되고 있습니다.

알고리즘을 표현하는 방법에는 순서도, 유사 코드, 언어적 표현 등등이 있으며 문제를 해결하는 알고리즘은 여러 가지가 존재할 수 있습니다.
우리가 가게에서 거스름돈을 내어주는 것에도 알고리즘이 존재합니다.
물건을 사고 거스름돈을 동전으로 받을 경우 손님들은 적은 수의 동전을 받기를 원하겠지요.
주머니에 넣으면 짤랑짤랑 소리가 나고 또 지갑에 넣으면 불필요하게 부피를 키우기 때문에 최소한의 개수로 동전을 받기를 원할 겁니다.
만약 거스름돈이 870원이라면 어떻게 거스름돈을 주어야 손님들이 가장 적은 동전을 받게 될까요?

교수님, 제가 풀어볼게요. 500원짜리 동전 한 개, 100원짜리 동전 세 개, 50원짜리 동전 한 개, 10원짜리 동전 두 개. 이 경우 내어주는 동전의 수는 7개가 됩니다. 그래서 최소 동전 수가 되겠지요. 

네. 잘했어요.
그럼 만약에 고객에게 100원짜리 8개, 10원짜리 7개를 준다면 이 경우에 내어 주는 동전의 수는 15개가 되겠지요.
7개의 동전과 15개의 동전, 어떤 것을 고객이 더 선호할까요?
이것이 바로 알고리즘의 효율성이 되겠습니다.

컴퓨터 프로그램은 정교한 알고리즘의 집합으로 잘 알려져 있습니다.
많은 사람들은 알고리즘 하면 컴퓨터를 통해 실행되는 것이라 여겨지는 경향이 있지만 사실 알고리즘 자체는 컴퓨터가 등장하기 이전부터 존재해 왔고요.
컴퓨터의 등장과 함께 알고리즘 역시 급속도로 발전하게 된 것입니다.
우리가 인공지능을 구현하는 데 있어서도 기술적으로 가장 중요한 것이 바로 효율적인 알고리즘을 개발하는 것입니다.
주어진 문제에 대해서 여러 종류의 알고리즘이 있을 수 있겠지요.
그런데 적게 노력해서 신속, 정확하게 결과물을 얻는 효율적인 알고리즘을 구현하는 것이 매우 중요합니다.

그렇다면 알고리즘 개발의 핵심 포인트는 뭘까요?
알고리즘 개발의 핵심은 앞서 말씀드린 효율성 외에도 문제와 해결책 규명 그리고 순차성이 있습니다.

먼저 문제는 알고리즘이 해결해야 될 목적이 됩니다.
만약 공항을 통해서 다른 나라로 도망치는 범죄자가 점점 늘고 있다고 할 때 문제는 공항을 통한 범죄자의 도피 증가가 되겠지요.
이 경우 해당 문제를 해결하기 위한 방안을 알고리즘으로 구현하는 것이 인공지능 개발자의 목표가 되겠습니다.
이 경우에 공항을 통해서 해외로 출국하는 사람의 안면을 카메라로 인식해서 범죄자 여부를 판단하는 안면인식 알고리즘을 개발한다고 하면 그게 이 문제를 해결하기 위한 하나의 솔루션이 될 겁니다.

다음으로 효율성입니다.
앞서 효율성에 대해서 말씀드렸지요.
최소한의 노력을 들여서 최대 성과를 내는 것이 바로 효율성인데 안면인식 방법이 범죄자를 판단하는 가장 효과적인 방법이냐, 이게 바로 효율성의 이슈입니다.
공항 검색대에서는 안경이나 모자로 얼굴을 가릴 수 없고 또 중간에 도망갈 수 없기 때문에 범죄자의 얼굴을 인식하는 방법은 가장 효율적인 방법이 될 겁니다.

다음으로 순차성은 컴퓨터는 처리 내용과 처리 순서를 하나하나 알려주어야만 명령을 수행할 수 있기 때문에 컴퓨터가 이해하도록 순차적으로 명령을 해야 한다는 의미를 담고 있습니다.
그러면 다음 사례를 통해서 순차성의 개념을 함께 살펴보실까요?

음료 자판기에서 현금으로 음료를 구매하는 경우의 알고리즘을 사용자와 자판기로 나누어 기술해 주세요~

주어진 문제를 저와 함께 풀어보도록 하겠습니다.
사용자는 자판기에서 음료를 구매하기 위해서 다음과 같은 기본적인 단계를 거쳐야 합니다.
먼저 자판기에 돈을 넣고 음료수를 선택하면, 즉 버튼을 누르면 밑으로 떨어진 음료수를 받아야 되겠지요.
잔돈이 있다면 그 잔돈을 받으면 됩니다.
반대로 자판기는 투입된 금액을 확인하고 선택 가능한 음료수에 불을 켜준 후 사용자의 선택에 따라서 음료수를 떨어뜨려 주고 필요한 경우에 잔돈을 내어주면 되겠지요.
이러한 두 가지 개체의 프로세스는 다음과 같이 분리가 되며 이런 두 가지의 프로세스를 합했을 때 비로소 완성된 프로세스가 되는 겁니다.

다음으로 여러분이 드립 커피를 타는 알고리즘을 한번 직접 개발해 보셨으면 좋겠는데요.
잠깐 역시 화면 정지 버튼 눌러놓고 여러분이 네 개 정도의 프로세스로 그 단계 프로세스를 만들어보시기 바랍니다.

제가 대충 도식화하거나 프로세스로 나타내면 다음과 같이 표현할 수 있을 것 같습니다.
첫 번째, 원두를 준비한다.
두 번째, 원두를 분쇄한다.
세 번째, 드리퍼에 원두를 넣는다.
네 번째, 바깥쪽으로 원을 그리며 물을 붓는다.

디테일하게 설명할까요?
첫 번째 단계는 원두를 준비하는 겁니다.
그런 다음에 원두를 그라인더로 곱게 간 다음에 필터를 끼운 드리퍼에 분쇄형 원두를 넣고 바깥쪽으로 원을 그리면서 물을 부어주면 원하는 커피가 완성되겠지요.

그런데 여기서 궁금한 점이 생겼어요.
사실 이 궁금증은 저라기보다는 원두를 가지고 커피를 제조해야 되는 로봇이 가질만한 궁금증일 텐데요.
과연 얼마나 원두를 넣어야 될까, 몇 분 동안 이 작업을 해야 될까, 바깥쪽으로 원을 그리며 물을 부을 때 내가 몇 번을 그려야 될까, 1인용과 3인용의 경우에 이러한 조건이 어떻게 달라져야 될까.
바리스타라면 본인의 경험과 감각으로 이런 것들을 알아서 판단하겠지만 기계는 사실 쉽지 않습니다.

이처럼 처리 내용과 처리 순서를 구체적으로 알려주어야만 컴퓨터가 정확하게 명령을 수행할 수 있기 때문에 알고리즘을 정확하게 설계해야 하는 것이 매우 중요하지요.
이처럼 알고리즘은 문제를 해결하기 위한 손쉬운 방법을 컴퓨터가 능동적으로 처리할 수 있도록 제시하는 겁니다.

즉, 프로그램을 실행하면 컴퓨터가 자동으로 문제를 해결해줄 수 있도록 구체적인 처리 절차를 명확하게 제시하는 것이 매우 중요합니다.
우리가 일상적으로 사용하는 표현들을 사용해서 한번 문제를 해결하는 절차를 표현해 보겠습니다.

50과 60을 더해서 평균을 구하는 미션이 떨어졌다고 할 때, 이 문제를 해결하기 위한 알고리즘을 그냥 우리가 사용하는 말로 표현해 볼까요?

첫 번째 단계는 일단 50과 60을 더해야 되겠지요.
두 번째 단계는 더한 값을 2로 나누어야 됩니다.
세 번째 단계는 나온 값을 답으로 제시하면 되겠지요.
참 쉽습니다.

그런데 문제는 컴퓨터는 이 과정을 이해하지 못한다는 겁니다.
이를 엑셀과 같은 컴퓨터 소프트웨어가 처리할 수 있도록 한번 step을 바꿔 보겠습니다.
보시는 것처럼 우리가 말로 설명할 때는 세 단계였는데 이것을 엑셀이 처리할 수 있도록 바꾸는 과정에서 두 단계가 더 추가되었습니다.
step 1은 50을 a에 대입한다.
step 2는 60을 b에 대입한다.
step 3은 a와 b의 합을 sum에 대입한다.
step 4는 sum에 2를 나누어 average, 즉 avg에 대입한다.
step 5는 avg 값을 화면에 출력한다, 입니다.

그런데 이러한 프로세스도 컴퓨터가 이해하고 바로 작동할 수 없습니다.
따라서 이를 컴퓨터 명령어의 일부를 차용해서 알고리즘으로 표현해야 되는데 이것을 알고리즘으로 표현하면 다음과 같습니다.
또 이런 프로세스를 시작과 끝, 선택을 도식화한 다음에 그림, 즉 순서도로 표현하면 다음과 같이 표시될 수 있겠는데요.
이처럼 문제를 해결하려는 방법 및 절차인 알고리즘을 정확하게 구현하는 것이 인공지능의 첫걸음이 되겠습니다.
