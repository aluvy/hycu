----------------------------------------------------------------------
9. 인공지능을 움직이는 힘, 알고리즘
----------------------------------------------------------------------

[1 페이지]
지난 차시 때 제시한 하노이의 탑 알고리즘입니다.
규칙은 A 기둥에 쌓인 선반을 모두 C 기둥으로 옮기되 작은 원반 위에 큰 원반이 올라가서는 안 되며 한 번에 한 개씩만 이동해야 합니다.
여러분은 어떻게 C 기둥으로 모든 선반을 옮기시겠습니까?

정답은 다음과 같습니다.
1단계입니다. A 기둥에 있는 가장 위의 3번 원판을 오른쪽 C 기둥으로 옮깁니다.
2단계, A 기둥 위에 있는 2번 원판을 가운데 B 기둥으로 옮깁니다.
3단계입니다. 오른쪽 C 기둥의 3번 원판을 가운데 B 기둥으로 옮깁니다.
4단계, 왼쪽 A 기둥의 1번 원판을 오른쪽 C 기둥으로 옮깁니다.
5단계, 가운데 B 기둥 위에 있는 3번 원판을 왼쪽 A 기둥으로 옮깁니다.
6단계입니다. 가운데 B 기둥의 원판을 오른쪽 C 기둥으로 옮깁니다.
7단계, 왼쪽 A 기둥의 3번 원판을 오른쪽 C 기둥으로 옮기면 모든 동작이 종료됩니다.

하노이의 탑 규칙에 따라 일반적으로 원판이 n개일 때 2ⁿ-1번의 이동으로 원판을 모두 옮길 수 있는데요.
원판이 3개이므로 총 7번을 이동하면 원판을 다 옮길 수 있습니다.
만약 이것을 Python이라는 언어로 구현한다면 다음과 같은 프로그램을 실행하여 값을 얻을 수 있습니다.
하노이의 탑은 프로그래밍 수업에서 알고리즘 예제로 많이 사용됩니다.
오늘은 알고리즘에 대해 학습하도록 하겠습니다.





----------------------------------------------------------------------
09_02 알고리즘의 이해
----------------------------------------------------------------------

[2 페이지]
여러분께서 인공지능과 관련된 글, 서적을 읽다 보면 알고리즘이란 용어가 자주 나올 겁니다.
알고리즘이란 문제 해결을 위한 단계들을 체계적으로 명시한 것으로써 문제를 해결하는 방법의 상세한 특징을 기술한 것입니다.

알고리즘이라는 용어는 9세기경 페르시아의 수학자인 al-Khwarizmi의 이름으로부터 유래되었으며 최초의 알고리즘은 BC300년경에 개발된 유클리드의 최대공약수 알고리즘입니다.

유클리드의 최대공약수 알고리즘은 다음과 같습니다.
여러분, 앞에 두 개의 자연수가 있어요.
우리는 그것을 a, b라고 칭하겠습니다.
여기서 a가 b보다 클 때 a를 b로 나눈 나머지를 r이라고 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 같다는 원리입니다.
이 원리에 따라서 a를 b로 나누고 b를 r로 나눈 나머지 r'를 구하고 다시 r을 r'로 나눈 나머지를 구하는 과정을 계속 반복해서 결국에는 나머지가 0이 되었을 때 그 나눈 수가 바로 a와 b의 최대공약수가 된다는 말입니다.

문장으로 설명 드리니까 상당히 복잡하지요.
절차를 정리하면 다음과 같습니다.
a를 b로 나눈다. b를 r로 나눈다. r을 r'로 나눈다. …해서 더 이상 나눠지지 않는 0 단계까지 갈 때 그 나누는 수를 바로 최대공약수로 도출하는 겁니다.

그러면 이러한 방법론에 따라서 저와 함께 몇 개의 문제를 한번 같이 풀어보시도록 하겠습니다.
첫 번째 문제는 12와 18의 최대공약수를 구하시오, 입니다.
여러분도 다 아시지요?
12와 18의 최대공약수, 복잡하게 계산하지 않아도 6이라는 거 쉽게 알 수 있는데 앞서 설명 드린 절차에 따라서 한번 저와 함께 구해 보도록 하겠습니다.

12와 18중 숫자가 큰 것은 18이지요? 그래서 a는 18이 되고 b는 12가 됩니다.
최대공약수를 구하기 위해서 큰 수를 작은 수로 나눕니다.
18을 12로 나누면 몫은 1이 되고 나머지는 6이 되지요.
즉, 여기에서 r 값은 6이 됩니다.
b를 r로 나눕니다.
12를 6으로 나눴더니 몫은 2가 되고 나머지는 0이 됐어요.
더 이상 나뉘지 않는 숫자까지 왔습니다.
이 경우에 이 두 수, 즉 12와 18의 최대공약수는 6이 되는 원리입니다.
문제가 암산으로 풀 수 있을 만큼 쉬웠기 때문에 쉽게 접근했는데 숫자를 조금 키워서 문제를 다시 한번 풀어보도록 하겠습니다.

두 번째 문제는 950과 703의 최대공약수를 구하시오, 입니다.
암산으로 풀이 가능하십니까?
절차에 따라서 문제 한번 풀어보겠습니다.
950과 703중 큰 숫자는 950이니까 a에는 950, b에는 703 숫자를 대입합니다.
a를 b로 나눠야 되겠지요.
950/703 하면 몫은 1이 되고 나머지는 247이 됩니다.
즉, 여기의 r 값이 247이라는 거지요? b를 r로 나누겠습니다.
b값은 703, r 값은 247. 703을 247로 나누면 몫은 몇이 되고? 그렇지요.
몫은 2가 되고 나머지는 209가 됩니다.
r'가 나왔네요.
다시 이런 방식으로 풀겠습니다.
247을 209로 나누면 몫은 1이 되고 r'', 즉 나머지는 38이 되며 다시 209를 38로 나누면 몫은 5가 되고 나머지는 19가 됩니다.
38을 19로 나누면 몫은 몇이 되고? 2가 되고 나머지는 제로, 0이 됩니다. 더 이상 나눌 수 없지요?
그랬을 때 38을 뭐로 나눴더니 2가 됐다? 19로 나눴더니 2로 딱 떨어졌다.
이 경우에 정답은 19가 됩니다.
즉, 950과 703의 최대공약수는 19가 되는 겁니다.

지금 제가 두 개의 문제를 같이 풀어보면서 최대공약수를 한번 구해 봤는데 어렵지 않지요?
이번에는 여러분이 스스로 직접 문제를 풀어보시기 바랍니다.
주어진 문제는 91과 273의 최대공약수를 구하는 문제인데요.
화면 하단의 정지 버튼 잠깐 누른 상태에서 여러분이 주어진 절차에 따라서 한번 직접 구해 보시기 바랍니다.
정답 몇으로 나왔습니까?
정답은 바로 13입니다.
사실 이 절차에 대입해서 문제를 푸는 게 그렇게 어렵지는 않으셨을 것 같아요.

이게 바로 유클리드의 최대공약수 알고리즘입니다.
이처럼 유클리드의 최대공약수 알고리즘을 경험하면서 우리는 두 가지의 메시지를 얻을 수 있을 것으로 생각하는데요.

첫 번째 포인트는 알고리즘은 문제를 해결하기 위한 절차나 방법을 순서대로 나열해서 기록한 것으로 문제를 해결하기 위한 가장 효율적인 절차에 해당한다는 것을 알 수 있어야 되겠고요.

두 번째 포인트로는 사람이 직접 손으로 푸는 것보다 컴퓨터가 알고리즘에 의해서 계산하는 것이 더 빠르다는 것은 누구도 부정할 수 없는 사실입니다.
가령 5,945와 4,551의 최대공약수를 구하라고 했을 때 여러분은 이 절차에 따라서 문제를 푼다고 하면 적어도 10초는 걸릴 것 같아요.
그런데 컴퓨터는 어떠합니까?
미리 만들어진 알고리즘에 두 개의 숫자만 대입하면 되기 때문에 엔터를 치고 0.1초가 되지 않아서 바로 이 두 개 숫자의 최대공약수를 제시할 것입니다.

따라서 복잡한 논리적인 연산을 할 수 있도록, 컴퓨터가 쉽게 계산할 수 있도록 알고리즘을 만들어주는 것이 우리 인간의 역할이 되겠습니다.
이런 알고리즘은 여러 곳에서 사용됩니다.
덧셈과 곱셈, 최대공약수를 구하는 방법 등 기초적인 수학 연산에서도 적용되지만 타이머를 개발하거나 엘리베이터를 설계하거나 지하철 환승 방법을 알려주는 앱 개발 등에도 이러한 알고리즘이 적용됩니다.

앞서 Today’s topic에서 우리가 함께 확인했던 하노이의 탑, 이 문제를 푸는 과정에도 알고리즘이 적용됩니다.
이처럼 알고리즘은 문제를 해결하기 위한 절차나 방법을 의미하는 단어로 매우 넓은 범위에서 사용되고 있습니다.

알고리즘을 표현하는 방법에는 순서도, 유사 코드, 언어적 표현 등등이 있으며 문제를 해결하는 알고리즘은 여러 가지가 존재할 수 있습니다.
우리가 가게에서 거스름돈을 내어주는 것에도 알고리즘이 존재합니다.
물건을 사고 거스름돈을 동전으로 받을 경우 손님들은 적은 수의 동전을 받기를 원하겠지요.
주머니에 넣으면 짤랑짤랑 소리가 나고 또 지갑에 넣으면 불필요하게 부피를 키우기 때문에 최소한의 개수로 동전을 받기를 원할 겁니다.
만약 거스름돈이 870원이라면 어떻게 거스름돈을 주어야 손님들이 가장 적은 동전을 받게 될까요?

교수님, 제가 풀어볼게요. 500원짜리 동전 한 개, 100원짜리 동전 세 개, 50원짜리 동전 한 개, 10원짜리 동전 두 개. 이 경우 내어주는 동전의 수는 7개가 됩니다. 그래서 최소 동전 수가 되겠지요. 

네. 잘했어요.
그럼 만약에 고객에게 100원짜리 8개, 10원짜리 7개를 준다면 이 경우에 내어 주는 동전의 수는 15개가 되겠지요.
7개의 동전과 15개의 동전, 어떤 것을 고객이 더 선호할까요?
이것이 바로 알고리즘의 효율성이 되겠습니다.

컴퓨터 프로그램은 정교한 알고리즘의 집합으로 잘 알려져 있습니다.
많은 사람들은 알고리즘 하면 컴퓨터를 통해 실행되는 것이라 여겨지는 경향이 있지만 사실 알고리즘 자체는 컴퓨터가 등장하기 이전부터 존재해 왔고요.
컴퓨터의 등장과 함께 알고리즘 역시 급속도로 발전하게 된 것입니다.
우리가 인공지능을 구현하는 데 있어서도 기술적으로 가장 중요한 것이 바로 효율적인 알고리즘을 개발하는 것입니다.
주어진 문제에 대해서 여러 종류의 알고리즘이 있을 수 있겠지요.
그런데 적게 노력해서 신속, 정확하게 결과물을 얻는 효율적인 알고리즘을 구현하는 것이 매우 중요합니다.

그렇다면 알고리즘 개발의 핵심 포인트는 뭘까요?
알고리즘 개발의 핵심은 앞서 말씀드린 효율성 외에도 문제와 해결책 규명 그리고 순차성이 있습니다.

먼저 문제는 알고리즘이 해결해야 될 목적이 됩니다.
만약 공항을 통해서 다른 나라로 도망치는 범죄자가 점점 늘고 있다고 할 때 문제는 공항을 통한 범죄자의 도피 증가가 되겠지요.
이 경우 해당 문제를 해결하기 위한 방안을 알고리즘으로 구현하는 것이 인공지능 개발자의 목표가 되겠습니다.
이 경우에 공항을 통해서 해외로 출국하는 사람의 안면을 카메라로 인식해서 범죄자 여부를 판단하는 안면인식 알고리즘을 개발한다고 하면 그게 이 문제를 해결하기 위한 하나의 솔루션이 될 겁니다.

다음으로 효율성입니다.
앞서 효율성에 대해서 말씀드렸지요.
최소한의 노력을 들여서 최대 성과를 내는 것이 바로 효율성인데 안면인식 방법이 범죄자를 판단하는 가장 효과적인 방법이냐, 이게 바로 효율성의 이슈입니다.
공항 검색대에서는 안경이나 모자로 얼굴을 가릴 수 없고 또 중간에 도망갈 수 없기 때문에 범죄자의 얼굴을 인식하는 방법은 가장 효율적인 방법이 될 겁니다.

다음으로 순차성은 컴퓨터는 처리 내용과 처리 순서를 하나하나 알려주어야만 명령을 수행할 수 있기 때문에 컴퓨터가 이해하도록 순차적으로 명령을 해야 한다는 의미를 담고 있습니다.
그러면 다음 사례를 통해서 순차성의 개념을 함께 살펴보실까요?

음료 자판기에서 현금으로 음료를 구매하는 경우의 알고리즘을 사용자와 자판기로 나누어 기술해 주세요~

주어진 문제를 저와 함께 풀어보도록 하겠습니다.
사용자는 자판기에서 음료를 구매하기 위해서 다음과 같은 기본적인 단계를 거쳐야 합니다.
먼저 자판기에 돈을 넣고 음료수를 선택하면, 즉 버튼을 누르면 밑으로 떨어진 음료수를 받아야 되겠지요.
잔돈이 있다면 그 잔돈을 받으면 됩니다.
반대로 자판기는 투입된 금액을 확인하고 선택 가능한 음료수에 불을 켜준 후 사용자의 선택에 따라서 음료수를 떨어뜨려 주고 필요한 경우에 잔돈을 내어주면 되겠지요.
이러한 두 가지 개체의 프로세스는 다음과 같이 분리가 되며 이런 두 가지의 프로세스를 합했을 때 비로소 완성된 프로세스가 되는 겁니다.

다음으로 여러분이 드립 커피를 타는 알고리즘을 한번 직접 개발해 보셨으면 좋겠는데요.
잠깐 역시 화면 정지 버튼 눌러놓고 여러분이 네 개 정도의 프로세스로 그 단계 프로세스를 만들어보시기 바랍니다.

제가 대충 도식화하거나 프로세스로 나타내면 다음과 같이 표현할 수 있을 것 같습니다.
첫 번째, 원두를 준비한다.
두 번째, 원두를 분쇄한다.
세 번째, 드리퍼에 원두를 넣는다.
네 번째, 바깥쪽으로 원을 그리며 물을 붓는다.

디테일하게 설명할까요?
첫 번째 단계는 원두를 준비하는 겁니다.
그런 다음에 원두를 그라인더로 곱게 간 다음에 필터를 끼운 드리퍼에 분쇄형 원두를 넣고 바깥쪽으로 원을 그리면서 물을 부어주면 원하는 커피가 완성되겠지요.

그런데 여기서 궁금한 점이 생겼어요.
사실 이 궁금증은 저라기보다는 원두를 가지고 커피를 제조해야 되는 로봇이 가질만한 궁금증일 텐데요.
과연 얼마나 원두를 넣어야 될까, 몇 분 동안 이 작업을 해야 될까, 바깥쪽으로 원을 그리며 물을 부을 때 내가 몇 번을 그려야 될까, 1인용과 3인용의 경우에 이러한 조건이 어떻게 달라져야 될까.
바리스타라면 본인의 경험과 감각으로 이런 것들을 알아서 판단하겠지만 기계는 사실 쉽지 않습니다.

이처럼 처리 내용과 처리 순서를 구체적으로 알려주어야만 컴퓨터가 정확하게 명령을 수행할 수 있기 때문에 알고리즘을 정확하게 설계해야 하는 것이 매우 중요하지요.
이처럼 알고리즘은 문제를 해결하기 위한 손쉬운 방법을 컴퓨터가 능동적으로 처리할 수 있도록 제시하는 겁니다.

즉, 프로그램을 실행하면 컴퓨터가 자동으로 문제를 해결해줄 수 있도록 구체적인 처리 절차를 명확하게 제시하는 것이 매우 중요합니다.
우리가 일상적으로 사용하는 표현들을 사용해서 한번 문제를 해결하는 절차를 표현해 보겠습니다.

50과 60을 더해서 평균을 구하는 미션이 떨어졌다고 할 때, 이 문제를 해결하기 위한 알고리즘을 그냥 우리가 사용하는 말로 표현해 볼까요?

첫 번째 단계는 일단 50과 60을 더해야 되겠지요.
두 번째 단계는 더한 값을 2로 나누어야 됩니다.
세 번째 단계는 나온 값을 답으로 제시하면 되겠지요.
참 쉽습니다.

그런데 문제는 컴퓨터는 이 과정을 이해하지 못한다는 겁니다.
이를 엑셀과 같은 컴퓨터 소프트웨어가 처리할 수 있도록 한번 step을 바꿔 보겠습니다.
보시는 것처럼 우리가 말로 설명할 때는 세 단계였는데 이것을 엑셀이 처리할 수 있도록 바꾸는 과정에서 두 단계가 더 추가되었습니다.
step 1은 50을 a에 대입한다.
step 2는 60을 b에 대입한다.
step 3은 a와 b의 합을 sum에 대입한다.
step 4는 sum에 2를 나누어 average, 즉 avg에 대입한다.
step 5는 avg 값을 화면에 출력한다, 입니다.

그런데 이러한 프로세스도 컴퓨터가 이해하고 바로 작동할 수 없습니다.
따라서 이를 컴퓨터 명령어의 일부를 차용해서 알고리즘으로 표현해야 되는데 이것을 알고리즘으로 표현하면 다음과 같습니다.
또 이런 프로세스를 시작과 끝, 선택을 도식화한 다음에 그림, 즉 순서도로 표현하면 다음과 같이 표시될 수 있겠는데요.
이처럼 문제를 해결하려는 방법 및 절차인 알고리즘을 정확하게 구현하는 것이 인공지능의 첫걸음이 되겠습니다.





----------------------------------------------------------------------
09_03 알고리즘 작동방식
----------------------------------------------------------------------

[3 페이지]
다음에서는 우리가 쉽게 이해할 수 있는 몇 가지 알고리즘에 대해서 함께 살펴보도록 하겠습니다.

첫 번째로 소개할 알고리즘은 바로 그리디 알고리즘입니다.
그리디 알고리즘은 우리말로 탐욕적 알고리즘이라고 말하는데요.
문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행을 함으로써 최종 해답에 도달하는 문제해결 방식입니다.
즉, 전체를 보지 않고 결정하는 그 순간만 딱 고려한다고 해서 탐욕적인 선택, 근시안적인 선택이라고 부릅니다.

예를 한번 들어 설명해 보도록 하겠습니다.
여러분 앞에는 배낭 가방 하나가 놓여있고요.
그 안에 담을 수 있는 다섯 개의 유용한 물품들이 주어졌습니다.
아이템 1은 25kg짜리고요.
이것을 돈으로 바꿨을 때 15만 원 정도에 해당하는 가치를 갖고 있어요.
아이템 2는 11kg짜리 물건으로 이걸 당장 내다 팔면 9만 원으로 바꿀 수 있습니다.
아이템 3은 중량이 9kg 정도 되고요.
역시 이것을 갖다 팔면 8만 원을 얻을 수 있고 아이템 4는 7kg짜리고 이건 3만 원에 해당하는 물품입니다.
마지막으로 아이템 5는 5kg에 해당하는 건데요.
이건 내다 팔면 2만 원밖에 못 받아요.

여기서 미션입니다.
미션은 하나의 배당에 더 많은 가치를 담으면서 가볍게 만들어야 되는 건데요.
이 경우에 조건은 가방에 넣을 수 있는 최대 무게는 25kg라는 겁니다.
즉, 가방에 최대 무게 25kg를 꽉꽉 채워 넣어서 더 많은 가치를 담으면서 반대로 가볍게 만드는 것이 우리가 해결해야 될 문제가 될 텐데요.
탐욕적인 알고리즘, 그리디 알고리즘을 이용하면 가장 가치가 높은 아이템을 선택해야 되기 때문에 우리는 주저 없이 아이템 1을 선택할 수 있습니다.
반면 가장 가벼운 아이템을 담으려면 가벼운 순서대로 담아야 되겠지요.
즉, 아이템 5, 4, 3 순서대로 담아야만 할 겁니다. 이러한 경우에 선택한 결정의 총 가치와 무게는 각각 다음과 같습니다.

첫 번째, 가장 가치가 높은 아이템 먼저 집어넣었을 때 우리가 선택할 수 있는 아이템은 아이템 1번 밖에 없어요.
이 경우에 가치는 15만 원, 무게는 25kg가 됩니다.
두 번째로 가장 가벼운 아이템 순서대로 넣다 보니까 아이템 5, 4, 3을 넣게 되는데 이 경우의 무게는 21kg로 상당히 가벼워졌지만 이 안에 들어간 제품의 모든 가치는 13만 원밖에 안 됩니다.
즉, 이 두 가지의 결정 모두 우리가 반드시 고려해야 될 가치와 무게를 완벽하게 충족하지 못하고 있어요.
어떤가요?
여러분이 보시기에도 최적이라고 보기 어렵겠지요.
이 경우에 우리가 더 많은 가치를 담으면서 가벼운 배낭을 만들기 위해서는 아이템 2와 3을 조합하는 겁니다.
이 경우의 가치는 17만 원이 되면서 무게는 20kg에 불과해요.
앞서 그리디 알고리즘에 의한 의사결정보다 훨씬 효율적이고 이익이 많이 나지요.
이처럼 그리디 알고리즘은 알고리즘의 기본에 해당하는 아주 쉬우면서도 중요한 알고리즘입니다.

하지만 완벽한 솔루션을 제공하기 어렵다는 단점 때문에 알고리즘을 배울 때 우리가 많이 이용하지만 실제로 인공지능을 개발할 때는 그리디 알고리즘을 사용하지는 않습니다.

다음은 이진수를 이용해서 문제를 풀어보는 사례, 같이 경험해 보도록 하겠습니다.
제목은 독이 든 술 단지, 읽어보겠습니다.
옛날 어떤 나라에 술을 즐겨 마시는 왕이 살고 있었다.
어느 날 이웃 나라 암살자가 창고에 몰래 들어와 술 단지 4개 중 하나에 독을 넣고 나오다가 붙잡혔다.
암살자는 단지 하나에 독을 넣었다고 실토하고는 숨을 거두었다.
독의 독성이 너무나 강해서 아주 조금만 맛보아도 다음날 바로 죽는다.
왕은 독이 든 술 단지를 내일까지 찾아내라고 지시했고 실패할 경우 술 단지를 하나하나 직접 마시도록 하겠다고 하였다.
당신은 투옥된 죄수들을 살아남으면 석방시켜주겠다는 조건으로 이들을 실험에 동원했는데 최소한의 죄수들을 동원한다고 할 때 최소 몇 명의 죄수를 동원해야 하겠는가?
라는 문제입니다.
여기서 핵심 포인트는 뭐지요?
우리가 반드시 알아야 될 문제 상황 두 가지입니다.
첫 번째는 독이 든 술 단지를 찾아내는 것이며 두 번째는 투입되는 죄수를 최소화해야 한다는 것입니다.
이것을 그리디 알고리즘으로 접근하면 일단 인력투입을 최소화하는 방법으로 문제를 해결해야 될 테니, 일단 먼저 1명을 투입해야 될 텐데 이 경우에 문제를 절대 풀리지 않습니다.
만약 첫 번째 술독에 든 술을 마시게 했는데 독이 네 번째 술독에 들었다면 죄수는 살아나지만 나는 죽게 되지요.
왜냐하면 술독 어디에 독이 들어있는지 모르니까 내가 죽습니다.
두 번째, 세 번째도 다 마찬가지지요.
죄수가 첫 번째를 마시든 두 번째를 마시든 세 번째를 마시든 다 살아남을 것이기 때문에 독이 어디 들어있는지 모르는 상태에서 내가 죽임을 당하게 됩니다.
딱 한 명을 투입해서 알아내려면 죄수한테 4번만 먹이든지 아니면 1, 2, 3번을 한꺼번에 먹이든지 둘 중의 하나를 선택해야 될 텐데 이러한 방법으로 독이 든 술 단지를 찾아낼 확률은 극히 드물다는 게 문제지요.

이번에는 죄수를 한 명 더 투입해서 두 명으로 문제를 해결하는 방법을 찾아보도록 하겠습니다.
첫 번째 방법은 첫 번째 술독은 죄수 1에게 주고 두 번째 술독은 죄수 2한테 주는 방법입니다.
두 사람이 맛보지 않은 나머지 두 개의 단지 중 독이 들어있기 때문에 다음 날 두 사람은 살아남겠지요.
대신 누가 죽는다?
내가 죽기 때문에 이것은 솔루션이 될 수 없습니다.
두 번째 경우는 두 번째 술 단지를 죄수 1에게 주고 세 번째 술 단지를 죄수 2에게 주는 경우입니다.
이 경우도 죄수 1, 2번은 다음날 살아날 것이기 때문에 내가 죽는 경우로, 이것도 완벽한 솔루션이라고 볼 수 없지요.
세 번째 단계는 세 번째 술독을 죄수 1에게 주고 네 번째 술독을 죄수 2에게 주는 방법입니다.
이 경우에 다음날 죄수 1은 살겠지만 죄수 2는 죽는 겁니다.
네 번째 술독에 독이 있다는 것을 알 수 있기 때문에 나는 살아남을 수 있어요.
네 번째 방법, 첫 번째 술독을 죄수 1에게 네 번째 술독을 죄수 2에게 주는 방법입니다.
역시 다음날이 됐을 때 죄수 1번은 살아남겠지만 죄수 2번은 죽음으로써 ‘아, 네 번째 술독에 독이 들어 있구나.’라는 것을 알게 됩니다.
그런데 문제는 확률이 1이 되어야만 내가 산다는 거예요.
첫 번째, 두 번째 케이스는 내가 죽는 케이스가 되는 거고 세 번째, 네 번째 내가 사는 케이스가 되기 때문에 확률이 1이 되지 못합니다.
재수 없으면 내가 죽을 수 있어요.
그래서 이런 방법도 완벽한 해답이 될 수 없다.
그래서 이것도 패스입니다.
이번에는 두 사람한테 각각 두 개의 술 단지의 술을 마시도록 한번 해 보겠습니다.
이 경우에 둘 중 하나는 반드시 죽겠지요.
그래서 죄수 1번에게는 첫 번째와 두 번째 술독의 술을 마시게 하고 죄수 2번에게는 세 번째, 네 번째 술독의 술을 마시게 했습니다.
이 경우에 다음날 사는 사람은 누가 되고?
죄수 1이 되고 누가 죽는다?
죄수 2가 죽습니다.
그런데 문제가 생겨요.
어떤 문제가 생길까요?
죄수 2번이 마신 세 번째, 네 번째 술독 중 어디에 독이 들어 있는지 알 수 없다는 겁니다.
결국에 여기에서 죽는 사람은 누가 되냐면 죄수 2번과 내가 되는 겁니다.
따라서 이 방법도 패스해야 되겠지요.

이제 더 이상 운에 맡기지 말고 과학적으로 풀어보겠습니다.
이진수를 이용해서 문제를 풀어보시기 바랍니다.
이렇게 문제를 풀기 위해서 각 단지에 이진수를 부여해야 됩니다.
각 단지에 0, 1 이걸 조합해서 00, 01, 10, 11, 이 네 가지의 숫자를 부여해 보겠습니다.
만약 죄인이 술맛을 보면 1로 표기하고 안 보면 0으로 표기하고 다음과 같이 단지와 죄수를 짝지어 보겠습니다.
만약 둘 다 살았다면 첫 번째 술독에 독이 있다는 것을 알 수 있겠지요.
만약 여기서 죄수 1번만 죽었다면 두 번째 술독에 독이 들었다는 것을 알 수 있습니다.
반대로 죄수 2번만 죽었다면 세 번째 술독에 독이 있다는 것을 알 수 있고요.
죄수 1, 2번이 모두 죽었다면 네 번째 술독에 독이 들었다는 것을 알 수 있습니다.
즉, 우리는 두 명이라는 최소 인원으로 독이 든 술독을 맞혔고요.
우리는 효율적인 알고리즘으로 이 문제를 해결할 수 있었습니다.

이번에는 조금 어려운 문제로 가보겠습니다.
문제 상황은 똑같은데요.
여기서는 술 단지가 네 개에서 여덟 개로 증가합니다.
역시 실패할 경우에는 내가 술 단지를 하나하나 직접 마셔야 되고 결국 내가 죽게 되는데 여기서 최소한으로 죄수를 몇 명 동원했을 때 우리는 독이 든 술 단지를 알 수 있을까요?
이건 저희가 이진수를 통해서 문제를 풀어보겠습니다.
앞선 방법과 마찬가지로 각 단지에 이진수를 0부터 부여합니다.
000, 001, 010, 011, 100, 101, 110, 111, 이렇게 여덟 개 술 단지에 세 개의 자리로 된 이진수를 각각 넘버링 했습니다.
여기서 각 죄수가 술맛을 보면 1, 안 보면 0으로 표기했습니다.
그렇게 해서 화면에서 보시는 이미지처럼 단지와 죄수를 하나하나 짝지어 보겠습니다.
만약 셋 다 살았다면 어디에 독이 있는 걸까요? 셋 다 살았다면 당연히 첫 번째 술독에 독이 있다는 겁니다.
이 경우에 세 명이라는 최소 인원으로 독이 든 술독을 맞힐 수 있겠지요.
두 번째, 죄수 3만 죽었다.
그럴 경우에는 두 번째 술독에 독이 있는 것이고 다음으로 죄수 2번만 죽었다고 하면 세 번째 술독에, 죄수 2번과 3번이 함께 죽었다.
그러면 네 번째 술독에 독이 있다는 걸 알 수 있습니다.
죄수 2, 3번은 다 살았는데 죄수 1번만 죽었다.
이럴 경우에는 다섯 번째 술독에, 죄수 1번과 3번이 같이 죽었다.
그러면 여섯 번째 술독에, 죄수 1번과 2번이 같이 죽었다고 하면 일곱 번째 술독에, 이 술을 마신 죄수 1번, 2번, 3번이 다 죽었다.
그러면 여덟 번째 술독에 독이 들어 있다는 것을 알 수 있겠지요.

이를 공식화하면 다음과 같습니다.
이진수의 2 그리고 자릿수의 3. 즉, 2의 3승은 8이라는 결과가 나옵니다.
만약 128개의 술 단지가 있었다면 몇 명의 죄수가 필요할까요? 이걸 하나하나 계산하려면 시간이 되게 오래 걸릴 거예요.
그런데 이진수를 가지고 문제를 쉽게 풀어보겠습니다.
2의 X승은 128이 되어야 되는데 이 경우에 X는 7이 됩니다.
2x2x2x2x2x2x2를 하면 128이 되고 이건 2의 7승이지요.
따라서 이 문제를 해결하기 위해서는 죄수가 몇 명이 필요하다? 그렇지요.
죄수가 7명이 필요합니다.

지금까지 간단한 사례를 통해서 알고리즘이 어떻게 작동하는지 알고리즘을 알고 있으면 어떤 점에서 편익이 있는지 이런 것들을 경험해 보셨는데요.

알고리즘이 제대로 작동하려면 다음과 같은 몇 가지 요건을 만족해야 합니다.
첫 번째, 입력과 관련해서는 입력 데이터가 반드시 존재해야 된다는 거고요.
두 번째, 출력과 관련해서는 최소 한 개 이상의 결괏값을 반드시 도출해야 한다는 겁니다.
세 번째, 명확성은 알고리즘의 각 단계는 애매함이 없도록 명확해야 된다는 거고요.
네 번째, 유한성은 각 단계를 유한한 횟수로 거친 후에 문제를 해결하고 반드시 종료 단계가 있어야 된다는 겁니다.
끝이 없이 계속 도는 것을 우리가 negative loop라고 하는데요.
그것은 잘못된 알고리즘이라는 것을 보여주는 하나의 증표가 되겠습니다.
마지막으로 효과성은 알고리즘의 연산은 유한한 시간 내에 정확하게 수행할 수 있을 정도로 충분히 단순해야 된다는 거예요.
예를 들어서 앞서 이진수를 가지고 죄수, 투입되는 최소의 죄수 수를 도출하는 게임을 해 본다고 할 때 사람이 연필과 공책을 가지고 하루를 열심히 돌려봤는데 답을 못 찾는다.
그러면 그건 제대로 된 알고리즘이라고 볼 수 없겠지요.
기계가 인지할 수 있도록 알고리즘을 짜서 컴퓨터에 input 시켰는데 이러한 알고리즘을 통해서 컴퓨터가 1초 내에 정확한 값을 내놓지 못한다?
그러면 그것은 효과성이 떨어지는 또는 잘못된 알고리즘이라고 말할 수 있을 것입니다.

이러한 다섯 가지 요건 중에 저는 유한성과 명확성을 강조하고 싶어요.

첫 번째 유한성입니다.
유한성은 반드시 정해진 시간 내에 처리를 완료해야 된다는 건데요.
이것을 구분해서 말하면 반드시 처리를 완료할 것. 즉, 시작이 있으면 끝이 있어야 된다는 의미이며 유한한 시간 내에 끝내야 된다는 겁니다.
우리가 좋은 알고리즘의 요건 중 하나에 효율성이라는 것이 있었지요.
input을 적게 해서 최대한의 output을 낸다는 측면에서 유한성은 이러한 효율성을 충족하는 매우 중요한 요건이 되겠습니다.

두 번째는 명확성입니다.
이것은 반드시 올바르게 작동해야 한다는 의미인데 이를 위해서는 우리가 작동 과정을 명확하게 나타내야 되겠지요.
즉, 반드시 올바르게 작동하고 작동 과정을 모호하지 않게 나타내는 것을 우리는 명확성이라고 이야기합니다.
가령 1+2+3이라는 입력을 줬을 때 이것에 대한 결괏값으로 6을 명확하게 줄 수 있는 것, 이게 바로 명확성이 되겠습니다.
알고리즘은 문제를 해결하기 쉬운 방법을 컴퓨터가 능동적으로 처리할 수 있도록 합니다.
즉, 프로그램을 실행하면 컴퓨터가 자동으로 문제를 해결할 수 있도록 구체적인 처리 절차를 명확하게 제시하고 있는데요.
따라서 우리가 알고리즘을 만들기 위해서는 문제의 핵심 요소를 뽑아서 자동화의 오류가 없도록 섬세하게 만들어야 됩니다.

그러기 위해서는 알고리즘 개발 과정에서 다음과 같은 질문을 하고 수정하는 시뮬레이션을 반드시 거쳐야 될 텐데요.

첫 번째는 주어진 문제를 정확하게 해결했는가? 라는 부분입니다.
앞서 술독 문제에서도 경험했지만 네 개의 술독에 독이 들어 있어요.
어떠한 방법으로든 몇 번째 술독에 독이 들어있는지를 찾아내야 될 텐데 우리가 개발한 알고리즘으로 어느 독에 독이 들어 있는지를 명확하게 찾아내야만 그것이 알고리즘으로 인정받는 겁니다.
만약 잘못된 술독을 지정했다고 하면 그것은 알고리즘으로써의 기본을 충족하지 못한다고 보는 거지요.

두 번째는 주어진 모든 조건을 만족시키고 있는가? 라는 부분입니다.
앞서 우리는 그리디 알고리즘을 통해서 25kg라는 배낭 내에 가장 가벼우면서도 가장 많은 가치를 담는 그런 activity를 해봤는데 우리가 가장 완벽한 솔루션을 도출하기 위해서는 두 개의 조건을 모두 만족시켜야 했어요.
가치는 높이고 그램 수는 낮추고.
이 두 가지의 요건을 충족하는 솔루션을 제시했을 때 우리는 그것을 완벽한 알고리즘이라고 말할 수 있을 것입니다. 세 번째는 입력에 대해서 예상되는 결과가 명확해야 된다는 거고요.
그리고 빠른 처리가 가능해야 된다는 점입니다.
특히 우리가 컴퓨터를 통해서 알고리즘을 작동해서 뭔가 output을 낼 때는 메모리와 같은 자원들이 투입되는데 이러한 자원이 최소화돼서 사용된다고 하면 그것은 좋은 알고리즘이라고 볼 수 있겠습니다.
특히 우리가 주의해야 될 게 있어요.
10번, 100번, 1,000번, 10,000번, 몇 번을 돌리더라도 한 번이라도 오류가 검출된다고 하면 이것은 완벽한 알고리즘이라고 볼 수 없습니다.
만약 9,999번을 다 잘했는데 단 한 번의 실수로 인해서 사람이 죽거나 기업이 파산되거나 정상적으로 작동하는 기계들이 멈췄을 경우에 우리가 입게 되는 피해는 어마어마하게 커질 수 있기 때문에 완벽한 알고리즘은 오류를 범할 가능성이 제로에 가까울 경우, 즉 제로인 경우에 우리는 그것을 완벽한 알고리즘이다.
이렇게 이야기합니다.

지금까지 제시한 여섯 가지의 질문에 대한 대답이 다 ‘예’라고 하면 완벽하겠지만 혹시 하나라도 ‘아니오’라고 답이 나온다고 하면 입력과 출력 또는 처리의 일부 또는 전체를 수정하는 작업을 반드시 해야만 합니다.





----------------------------------------------------------------------
09_04 인공지능을 위한 알고리즘
----------------------------------------------------------------------

[4 페이지]
우리가 인공지능을 개발하는 데 있어서 알고리즘을 이해하고 이것을 구현하는 스킬은 매우 중요합니다.

특히 딥러닝이라는 기계학습 알고리즘을 개발할 때 우리가 인간을 뛰어넘는 기계 지능이 가능해진 것은 이런 알고리즘이 조금 더 고도화되었기 때문인데요.

인공지능 알고리즘의 선조 격에 해당하는 퍼셉트론 다들 기억하십니까?
제가 중간고사 전에 이 부분에 대해서 아주 간단하게 설명 드렸는데 인공지능을 이해하는 데 있어서 매우 중요한 개념인 만큼 다시 한번 복습해 보도록 하겠습니다.
1950년대부터 인공지능에 대한 개념은 구체화되었으며 퍼셉트론의 등장으로 인공지능은 더 이상 꿈의 이야기가 아니라는 믿음을 많은 사람들이 가지게 되었습니다.
퍼셉트론은 인공신경망의 한 종류로 1957년에 코넬 항공 연구소의 Frank Rosenblatt에 의해서 처음 고안된 알고리즘인데요.
앞서 설명 드린 인간의 뉴런을 본 따 만들었기 때문에 개념적으로는 비슷한 점이 아주 많습니다.

퍼셉트론은 다수의 신호, 즉 input을 입력받아서 하나의 신호 output을 출력합니다.
뉴런이 전기신호를 내보내서 정보를 전달하는 것과 상당히 비슷한 프로세스지요. 뉴런의 수상 돌기나 축삭 돌기처럼 신호를 전달하는 역할을 퍼셉트론에서는 가중치, 즉 weight로 처리하는데 각각의 입력 신호에 부여되어서 입력 신호와의 계산을 하고 또 신호의 총합이 정해진 임계 값을 넘었을 때 1을 출력하는 방식으로 작동합니다.
각 입력 신호에는 고유한 가중치가 부여되고 가중치가 크면 클수록 해당 신호가 중요하다고 볼 수 있겠지요.
따라서 인공지능 분야에서는 가중치를 정확하게 정해서 알고리즘 또는 모델을 정교화하는 것이 매우 중요합니다.

이러한 퍼셉트론은 선형 분류 모형을 기반으로 합니다.
선형 분류라는 것은 평면에서는 딱 긋고 이 경계를 넘느냐 마느냐에 따라서 상대방을 구분하는 방식입니다.
모든 학습 데이터를 정확히 분류시킬 때까지 학습을 진행하면 학습데이터가 선형적으로 완벽하게 분리할 수 있는 수준까지 가는데요.
기계학습이 반복될수록 선의 기울기가 달라지는데 이는 학습을 하면서 가중치가 계속 조정되기 때문입니다.

화면에서 제시되는 이 그림 네 개를 보도록 하겠습니다.
왼쪽 상단부터 1번, 2번, 3번, 4번.
네 개의 그림이 그려지지요.
이 화면에 강아지와 고양이를 투입합니다.
누가 보더라도 구분이 되기 때문에 고양이와 강아지를 가로지르는 선을 하나 만들었어요.
여기에 강아지와 닮은 사물, 객체가 하나 더 들어옵니다.
그랬을 때 두 마리의 강아지와 한 마리의 고양이를 나누기 위한 선이 다시 조정이 되겠지요.

세 번째 단계에서는 여기에 강아지가 한 마리 더, 고양이가 한 마리 더 들어옵니다.
총 다섯 마리의 동물을 나눠야 되는데 강아지와 고양이를 완벽하게 구분하기 위해서 다시 기울기가 조금 더 완만해지는 선으로 구분되고 마지막으로 여기 하나가 더 투입되지요.
강아지가 한 마리 더 투입됩니다.
네 마리의 강아지와 두 마리의 고양이를 구분하기 위해서 다시 기울기가 완만하게 조정됩니다.
이런 방식으로 해서 여기에 투입되는 다양한 동물들을 완벽하게 구분할 수 있게 되는데 이렇게 해서 모델을 정교화하는 활동이 바로 가중치에 대한 조정이 되겠습니다.

하지만 환상적인 퍼셉트론의 알고리즘에 심각한 에러가 발생합니다.
바로 XOR, exclusive OR의 문제가 발견되었는데요. 우리가 네 개의 연산을 가지고 한번 표현해 보면 AND, NAND, OR, XOR은 다음과 같이 숫자들이 배치가 되며 이런 것들을 x축과 y축으로 그림을 그려보면 다음과 같이 제시됩니다.
그런데 AND, NAND, OR, 이 세 가지는 모두 직선을 이용해서 경계가 구분되지만 exclusive OR, 즉 XOR의 경우에는 직선으로 경계를 구분하지 못한다는 문제가 발견된 거지요.
즉, 이러한 방식으로는 개와 고양이를 구분하는 것이 불가능해진다는 점이 밝혀지게 된 겁니다.
사실 퍼셉트론이 인공지능 분야에서 처음 발견되었을 때 이것은 엄청난 센세이션을 불러일으켰습니다.
그리고 연구 과제도 이쪽으로 다 몰렸는데요.
exclusive OR의 사례처럼 이것이 가지는 한계점이 밝혀지면서 1차 인공지능의 붐이 끝나는 그러한 결과를 초래하게 됩니다.
이런 충격 때문이었을까요?
Rosenblatt은 1971년 7월 그의 43번째 생일에 혼자 보트를 타다가 사고로 익사했습니다.
많은 사람들은 퍼셉트론에 대한 비판으로 괴로워하던 Rosenblatt이 자살한 것이라고 말했지만 사실 이것은 누구도 모를 일이지요.

다만 분명한 건 시간이 흐른 후 그의 업적이 재조명받기 시작했고 이런 문제를 해결할 수 있는 방법이 나오는 데 그가 크게 기여했다는 것입니다.
이것이 바로 다층 퍼셉트론이 되겠습니다.
다층 퍼셉트론은 단층 퍼셉트론을 2개 이상의 층으로 쌓아서 만든 겁니다.
이를 통해서 복잡한 형태의 방정식을 표현할 수 있는 길이 열렸는데요.
즉, 인간의 뉴런과 유사한 알고리즘을 통해서 단일 퍼셉트론의 한계를 극복하는 데 다층 퍼셉트론이 혁혁한 공을 세우게 되었습니다.

화면에서 보시는 바와 같이 단일 퍼셉트론은 입력층과 출력층으로만 구성되는데요.
여기 중간에 한 층이 더 들어옵니다.
바로 이것이 Hidden Layer, 즉 히든 층이지요.
이처럼 히든 층을 하나 더 투입함으로써 컴퓨터도 인간처럼 복잡한 처리도 수행할 수 있게 된 것입니다.

지금까지 복잡한 말씀들을 드렸는데 간단하게 정리하고 넘어가도록 하겠습니다.

첫 번째, 퍼셉트론은 입력층과 출력층으로 만들어진 네트워크로 우리말로는 단층 신경망이라고 부른다. 여기에서 포인트는 뭐다? 입력층과 출력층만 있고 히든 층은 없어요.
다음으로 다층 퍼셉트론은 입력층과 출력층 사이의 히든 층이 한 개가 있다. 이것을 우리말로는 다층 신경망이라고 부릅니다.

그런데 여기서 질문, 입력층과 출력층 사이에 히든 층이 꼭 하나만 있어야 될까요? 두 개가 들어가면 안 될까요?
물론 가능합니다.
입력층과 출력층 사이에 히든 층이 두 개 이상 있는 경우가 있는데요.
우리는 그것을 일컬어 심층신경망, DNN이라고 합니다.

심층신경망이 영어로 DNN이에요.
D는 뭘까요? 심층이니까 deep일 거고 NN, 뒤에 붙은 것은 Neural Network.
그래서 심층신경망은 Deep Neural Network, 그래서 DNN이라고 부릅니다.

이처럼 퍼셉트론은 다층 퍼셉트론으로 발전했고 지금의 딥러닝 기술로 진화해 나가고 있습니다.
다음에서는 인공지능 분야에서 사용되는 대표적인 알고리즘에 대해서 아주 간단하게 설명할 텐데요.
여기에는 규칙기반 모델, SVM, k-means clustering과 같은 고전적인 알고리즘이 있고요.
또 딥러닝 관련해서는 앞서 언급한 DNN 외에도 CNN, RNN, GAN 이런 다양한 알고리즘이 있습니다.

다음에서는 각각의 개념에 대해서 제가 아주 심플하게, 최대한 쉽게 설명해 드리겠습니다.

첫 번째 규칙기반 모델입니다.
이것은 영어로 Rule-based Model이라고 하는데요.
규칙기반 모델은 사람이 하는 판단을 기계가 대신하도록 하는 알고리즘으로 If ~ then이라는 조건에 따라 대상을 분류하는 방식으로 작동합니다.
기억나시지요?
우리가 지난 7차시에 배웠던 이진 탐색 트리, 즉 Binary Search Tree는 이 규칙기반 모델에 해당하는 방법이라고 볼 수 있겠습니다.

두 번째는 SVM이에요.
이건 full로 풀어보자면 Support Vector Machine, 앞글자를 따서 SVM이라고 하는데요.
SVM은 머신러닝 기법의 하나로 서로 다른 두 그룹을 분류하기 위해서 제안된 방법입니다.
패턴을 인식하거나 자료를 분석하기 위한 지도학습 모델의 일종인 SVM은 두 카테고리 중 어느 하나에 속한 데이터의 집합이 주어졌을 때 이 알고리즘을 이용해서 주어진 데이터의 집합을 바탕으로 해서 새로운 데이터가 어느 카테고리에 속할지 미리 판단해주는 그런 역할을 합니다.
즉, 서로 다른 특징의 데이터들을 한 공간에 두면 이들 데이터를 분류하기 위해서 SVM 알고리즘이 그중 가장 큰 폭을 가진 경계를 찾아서 너희들은 이쪽이야, 너희들은 이쪽이야.
쉽게 이렇게 나눠주는 역할을 바로 SVM이 해 주고 있지요.

그림을 통해 조금 더 단순하게 설명해 보도록 하겠습니다.
우리는 화면에 있는 다양한 데이터들을 보면서 이 데이터들을 한번 분류해 본다고 가정해 보겠습니다.
그림에서 볼 수 있듯이 가운데 진한 선을 기준으로 아주 분류가 잘되고 있지요. 파란색 점들은 오른쪽에 몰려 있고 노란색 점들은 왼쪽에 몰려 있는데 이 두 개의 데이터가 서로 섞이지 않도록 굵은 선이 딱 경계를 잘 잡아주고 있습니다.
아주 예쁘게 잘 나눠줬어요.

여기서 우리가 알아야 될 개념이 두 가지가 있는데 바로 margin과 Support Vector라는 개념입니다.
가운데 진한 선으로부터 데이터 거리까지 거리를 우리가 측정해야 되는데요.
여기서 이 거리를 우리는 margin이라고 부릅니다.
그리고 결정 경계선, 즉 점선에서 가장 가까이에 있는 데이터들을 Support Vector라고 하는데요.
이 경우에 어떤 모델이 좋은 모델일까요?
당연히 margin이 커야 좋은 모델이 될 겁니다.
그런데 Support Vector는 어떨까요? Support Vector는 잘못 분류될 가능성이 매우 큰 데이터이기 때문에 이 경계가 제대로 그어졌는지 아닌지를 판단하는 데 있어서 매우 유용한 지표로 이용됩니다.

즉, margin이 크고 Support Vector가 섞이지 않도록 이 두 가지의 그룹들을 잘 분류하는 것이 가장 완벽한 경계선이 될 텐데 이런 것들을 자동으로 만들어주는 모델을 바로 SVM, Support Vector Machine이라고 부릅니다.
그런데 이런 것들은 기계로 완벽하게 만들어주는 그런 경계선은 아니에요.
중간 중간에 여러 가지의 outlier도 제거해 주고 문제가 되는 데이터들을 넣고 빼는 이런 작업들을 인간이 직접 해 주는 데 이런 정련화를 통해서 모델은 완벽해지고 이런 모델을 통해서 투입되는 새로운 사물들, 데이터를 완벽하게 분류해낼 수 있게 되는 것입니다.

군집분석은 인공지능을 구현하는 가장 대표적인 알고리즘 중 하나입니다.
각 군집에 할당된 포인트의 평균 좌표를 보고 군집의 중심점을 업데이트시키는 방식으로 알고리즘을 고도화해 나가는데요.
이런 군집분석의 종류에 k-means라는 게 있습니다. k-means의 k는 k개의 중심점을 가지고 데이터를 구분한다는 의미를 갖고 있고 means는 평균값을 가지고 구분한다고 의미를 갖고 있는데요.

즉, k-means는 k개의 중심점을 기준으로 데이터를 군집으로 묶어준다는 의미를 담고 있는 알고리즘입니다.
