-------------------------------------------------------------
09_03. 집합 유형 데이터 처리의 기초
-------------------------------------------------------------

[3페이지]

집합의 데이터처리 기초에 대해서 실습을 해보겠습니다.
로지컬프로세싱 데이터라는 차시 이번 차시를 들어가서 폴더에 들어가서 새롭게 노트를 만들겠습니다.
파이썬3 형태 노트를 만들겠습니다.
처음에는 집합을 문자적으로 정의하는 과정을 보겠습니다.
문자적으로 정의한다는 것은 집합을 그대로 문자적으로 써놓고 정의를 하는 것을 뜻합니다.

그 문법을 잠깐 보면 셋 오브젝트 이콜.
중괄호 열고 아이템 콤마 아이템 콤마 아이템의 형태로.
아이템들을 나열을 시킨 다음에 중괄호를 닫는 형태 이것이 집합의 문자적 표현이고 그 표현 자체로 정의 해 들어가는 것입니다.
코딩을 한번 해보겠습니다.
코딩을 끝마쳤고요.
지금 오브젝트 2개를 생성을 시켰습니다.
set_obj1 = {1, 2, 3 }이라는 원소를 가진 집합으로써 정의를 해서 생성을 했고
set_obj2 = {1, 'two', (3,4,5) } 첫 번째 아이템이 1, 두 번째 아이템이 two라는 문자열, 세 번째 아이템은 3, 4, 5를 항목으로 가진 튜플.
이 튜플 자체가 set_obj2의 세 번째 아이템이 되는 것입니다.
그 결과 집합을 문자적으로 이렇게 정의한 결과를 런을 통해서 확인을 해보겠습니다.

set_obj1 = {1, 2, 3 } set_obj2 = {1, (3, 4, 5), 'two' } 여기서 여러분이 조금 유의해서 보실 부분은 이 3, 4, 5에 해당하는 튜플이 세 번째 아이템으로 주어졌었는데 실제 생성될 당시에는 두 번째 아이템이 돼서 나타나고 있습니다.
이런 현상은 각 아이템 집합 안에 있는 각 아이템은 그 값이 중요한 것이 아니고 그 해시 값이 중요합니다.

그 해시 값을 내림차순 또는 오름차순으로 일방적인 하나의 방향성을 가지도록 정렬을 한 형태로 세트 안에서는 가지고 있기 때문에 우리가 정의를 할 때 준 순서하고는 다르게 집합 내용으로 나타날 수가 있는 것입니다.
다음에는 공집합을 문자적 정의로 생성할 수 있는지 보겠습니다.
원래는 생성할 수 없습니다.

우리가 흔히 생각하기를 공집합을 이렇게 중괄호로 열고 닫으면 집합이 되니까 그 안에 아무런 아이템이 없으면 공집합이 되는 게 아닐까라고 생각을 해서 이와 같은 형태로 집합을 만들겠지만 그 결과가 어떤지 보겠습니다.
print { type(set_obj)}의 결과를 보면 이런 뭐가 나왔죠?
클래스 딕트가 나왔습니다.
그리고 여기에 set_obj는 실제 어떤 값이 들어가 있는지 보겠습니다.
set_obj까지 넣어서 다시 런을 시키겠습니다.

뭔가 마치 공집합인 것처럼 표시는 됐는데 이 중괄호, 속이 비어 있는 중괄호가 집합이 아니고 딕셔너리 타입이라고 하는 점이 우리가 주의를 해야 할 점입니다.
다시 말씀드리면 이와 같은 문자적인 방법으로써는 공집합을 정의를 할 수 없다.
그러면 어떻게 하면 되겠는가.
그건 조금 이따가 말씀을 드리겠습니다.
이제 객체 생성자를 이용한 집합 객체 생성하는 과정을 보겠습니다.

집합을 정의하는 방법 중에 조금 전에는 문자적인 방법으로 정의를 했고 이번에는 set( ) 즉 set라는 제너레이터 함수를 가지고 집합의 객체를 생성한다는 것입니다.
이때 이 집합 객체 안에는 이터러블이 들어갈 수가 있겠고 또는 그 이터러블은 튜플이 될 수도 있고 리스트가 될 수도 있고 문자열이 될 수도 있고 또 다른 set, 집합이 될 수도 있고 딕셔너리가 될 수도 있고 형태로써 이 set안에 파라메터가 주어지는 것입니다.

조금 전에 공집합을 만든다고 그랬죠?
바로 공집합을 만들 때는 이 set안에 아무것도 집어넣지 않고 파라메타가 없이 set 함수를 부르면 런을 시켜보겠습니다.
이제 이 set에 비어 있는 괄호를 가진 이런 형태의 답이 나옵니다.
바로 이것이 파이썬이 이야기하는 공집합입니다.
조금 더 구체적으로 말씀드리기 위해서 set를 뭔가 다른 객체 참조로 받아보겠습니다.
그러고 나서 print(set_obj)를 하는데 타입이 뭔지 보겠습니다.

set_obj의 타입이 무엇인지 그리고 set_obj의 값은 무엇인지 살펴보겠습니다.
다시 한 번 런을 해보겠습니다.
우리가 예상한 대로 집합은 맞습니다.
집합 유형 클래스가 나왔죠.
그리고 그 set_obj의 값은 set이라는 함수 그 자체의 리턴 값이 나오는데 이것이 바로 공집합이 되는 것입니다.
공집합에 대해서 잠깐 알아보았고요.

이제부터는 셋 제너레이션 오퍼레이트, 제너레이터 펑션을 가지고 몇 가지 방법으로 집합을 생성하는 과정에 대해서 살펴보도록 하겠습니다.
문자열로부터 집합을 생성하는 방법을 보겠습니다.
set, abcdefg라고까지 하는 문자열을 가지고 set를 지정해보겠습니다.
이렇게 하면 좀 재미가 없죠.
조금 더 완성된 형태 코딩을 통해서 확인을 해보도록 하겠습니다.
코딩이 됐습니다.
스트링을 먼저 잡았습니다.

this is a base string for a set라고 하는 긴 문장을 주었습니다.
긴 문자열을 주었습니다.
그다음에 이 str_obj를 셋 제너레이터에 파라미터로 집어넣었습니다.
앞에서 말씀드렸듯이 이터러블한 것을 파라미터로 넣을 수 있는데 이 문자열 자체도 이터러블이니까 집어넣는 데는 아무런 문제가 생기지 않을 것입니다.

그러고 나서 두 번째로 set을 셋 제너레이터를 통해서 set을 집합유형을 정의를 하는데 이 셋 오퍼레이터의의 파라미터로써 문자열을 그대로 문자적인 표현 그대로 집어넣어 봤습니다.
어떤 결과가 나오는지 프린트로 확인을 해본 것입니다.
런을 시켜보겠습니다.
런을 시켜봤더니 set_obj1 는 어떻게 나왔나 n, g, `, s, a, i, o 등등 처음에 주었던 이 문자열에 들어가 있는 여러 철자들이 있죠.
알파벳들이 있습니다.

이 알파벳과 스페이스 또는 점과 같은 심볼들이 낱낱이 흩어져서 그 하나하나가 집합의 아이템으로 들어가 있음을 볼 수 있습니다.
그리고 주어진 순서대로 이게 나타났나요?
n 다음에 g가 나타나는 것인지 한번 보겠습니다.
n이 어디 있을까요?
여기에 n이 스트링, n 다음에 g가 나타나는 건 맞을 것 같네요.

그다음에 점이 또 나타났네, 점이 나타났고 s, s는 오히려 n보다 앞에 나타나고 있었지만 이 뒤에 있는 s인지 모르겠죠?
어떻든 s가 지금 하나, 둘, 셋 세 번 나타났는데 s는 여기서 한 번만 나타나고 있습니다.
이와 같이 집합에서는 동일한 객체들을 주었다 하더라도 집합으로 형성될 때에는 그중에 하나만 아이템으로 선택이 된다는 것을 여기서 확인을 할 수가 있습니다.

그리고 일일이 다 확인하기는 어렵지만 이 원래 주어진 스트링에 나온 철자의 순서대로 이 집합의 아이템이 나타나는 것은 아닙니다.
앞에서 말씀드렸듯이 각각의 아이템은 그 값 자체로 들어가 있는 것이 아니고 해시 값이 들어가 있기 때문에 그 해시 값이 뭐가 나올지는 우리도 예측을 할 수는 없습니다.

다만 n의 해시 값이 오늘 해시 값과 내일 해시 값이 같아야 하지만 그러나 그것도 역시 시스템의 상태 또는 파이썬 인터프리터의 초기 상태에 따라서 해시 값이 다르게 나올 수도 있기 때문에 그 해시 값에 따라 정렬되어 있는 순서는 우리가 예측을 할 수 없는 순서로 나타나게 되는 것입니다.
그런 점들을 확인을 해봤습니다.
여기에서는 문자열을 가지고 집합을 생성하는 과정에 대해서 살펴보았습니다.

그다음에는 튜플로부터 집합 객체를 생성하는 과정에 대해서 또 살펴보도록 하겠습니다.
튜플로부터 집합 객체를 생성하는 과정인데 집합 생성자를 통해서 생성하는 과정입니다.
이 집합 생성자에 튜플을 파라미터를 집어넣어봤습니다.
튜플은 무엇이냐 하면 앞에서 주었던 스트링의 각 단어를 튜플의 각 항목으로 삼은 것입니다.

디스라는 항목 이즈라는 항목 어라는 항목 베이스, 리스트, 포, 어, 셋, 점까지.
각각의 단어들을 튜플 오브젝트에 지금 참조를 배정했습니다.
그 튜플 오브젝트를 셋 제너레이터에 넣어서 집합을 만들었을 때 또는 튜플 자체를 그대로 문자적으로 정의해서 셋에 파라미터로 넣었을 때 각각 어떤 집합들이 형성이 되는지 살펴보겠습니다.
런을 하겠습니다.
동일한 집합이 형성이 됐음을 알 수가 있습니다.

그리고 이때는 각각의 철자가 흩어져서 한 철자마다 아이템이 된 것이 아니고 튜플의 항목 항목이 그대로 집합의 항목으로 됐음을 알 수 있습니다.
또 튜플에서는 디스 다음에 이즈, 또 그다음에는 어라고 하는 항목들이 나오지만 이 집합에서는 어가 먼저 나오고 디스가 다음에 나오고 이즈가 그다음에 또 나오고.
좀 뒤죽박죽되는 순서로 나옴을 볼 수 있죠.

이 이유는 앞에서도 말씀드렸듯이 해시를 만들어서 집합을 구성을 하기 때문에 이런 현상이 나타난다는 것을 알 수 있습니다.
리스트로부터 집합 객체를 생성하는 과정에 대해서도 보겠습니다.
지금 계속 우리는 집합 제너레이터 속에 이터러블을 파라미터로 넣어서 집합을 생성하는 과정을 보고 있습니다.
이터러블에 속하는 것들은 처음에 다루었던 문자열, 그다음에 튜플, 그다음에 리스트 지금 리스트를 다루고 있죠.
보겠습니다.
코딩을 했습니다.

리스트로써 문자적으로 정의된 리스트입니다.
첫 항목이 210.115.96.2라고 하는 IP주소입니다.
두 번째 아이템은 또 다른 값을 가진 IP주소죠.
즉 4개의 IP주소를 가진 리스트가 문자적으로 정의됐고 그 객체에 대한 참조를 리스트 오브젝트에다가 배정을 한 상태입니다.
이 리스트 오브젝트를 셋 함수 제너레이터 함수 속에 파라미터로 넣어서 셋을 정의를 했고 그 셋은 어떻게 됐을까.

런을 해봤더니 리스트에 있던 항목들이 각각 셋의 항목이 되어서 항목이 나열이 됐음을 알 수 있습니다.
그런데 리스트에서는 4개의 항목이었는데 셋에서는 3개의 항목만 있네요.
여러분이 짐작하셨듯이 같은 항목이 두 번 들어가 있었기 때문에 그 항목 중에 하나만 선택이 돼서 셋의 항목으로 된 것을 우리는 알 수 있습니다.
어떤 것이 같았을까요.

첫 번째 항목인 210.115.96.2에 해당하는 주소와 맨 마지막 항목인 IP주소도 역시 똑같은 주소 값을 가진 항목이었기 때문에 이 두 항목은 하나만 선택이 되어서 셋에 항목이 된 것입니다.
그다음에 매핑 집합으로부터 객체를 생성하는 과정에 대해서 살펴보겠습니다.
매핑 집합이라는 것은 셋 제너레이터 안에 파라미터로 들어가는 집합, 객체를 뜻합니다.
이 집합이 그대로 매핑이 돼서 다른 집합이 됐다는 걸 의미합니다.

매핑 집합을 통한 또 다른 집합을 생성하는 코딩을 해보았습니다.
set_obj1은 세트에 1, two, 또 3, 4를 항목으로 가지는 튜플.
이런 세 개의 항목을 가진 튜플입니다.
튜플로써 set_obj1을 집합을 만들었습니다.
이 과정은 우리가 앞에 앞에 부분에서 튜플을 사용해서 집합을 형성하는 과정 그 과정과 같은 과정입니다.

중요한 것은 set_obj2를 얻을 때 조금 전에 만들었던 set_obj1 이 자체를 셋 제너레이터에 파라미터로 주어서 또 다른 집합, 객체를 만든다 하는 점입니다.
그러면 이 두 set_obj1과 set_obj2는 내용이 같아야겠죠?
실제로 그런지 확인을 해보겠습니다.
내용이 같음을 볼 수 있습니다.
1, 3, 4 또는 two라고 하는 스트링 역시 set_obj2도 마찬가지입니다.

set_obj1을 매핑을 해서 set_obj2를 만들었는데 그 내용이 원소도 같고 원소 배열순서도 같음을 볼 수 있습니다.
이 두 집합은 같다고 이제 볼 수 있습니다.
같다는 것을 어떻게 표현을 할까 여기서 잠깐 살펴본다면 set_obj1은 set_obj2와 같다는 표시는 더블 이퀄 마크를 사용하죠.
만일 진짜 같다면 여기서 트루라는 값이 리턴이 돼서 나올 것입니다.
보겠습니다, 과연 그런지.
트루가 나왔습니다.
두 값이 같기 때문에 그렇게 된 것이죠.

그럼 조금 더 1, 2, 3이라고 하는 집합과 3, 2, 1이라고 하는 집합은 같을까요, 다를까요.
우리가 수학적으로 생각할 때는 같아야 합니다.
과연 파이썬도 같다고 생각하는지 보겠습니다.
런을 해보겠습니다.
그런데 여기에서는 프린트를 해봐야겠죠?
2가지 값이 다 나오려면 프린트를 해봐야겠습니다.
프린트를 하지 않으면 이 노트에서는 가장 마지막에 출력되는 리턴 되는 값만 표시를 해 줍니다.
이미 답은 나오기는 나왔죠.

1, 2, 3이든 3, 2, 1이든 같은 집합이다 하는 것을 우리는 짐작을 할 수 있는데 좀 더 확인을 해보겠습니다.
트루가 두 번 나왔습니다.
프린트 2개에 의해서 모두 트루가 나왔기 때문에.
원소의 배열 순서와는 관계없이 원소만 동일하게 들어가 있으면 그 두 집합은 동일하다는 것을 알 수 있습니다.
그다음에는 사전으로부터 객체를 생성하는 과정을 보겠습니다.
미리 말씀드리지만 조금 다릅니다.

우리가 지금까지 보아왔던 형상과는 조금 다른 것을 우리는 볼 수 있습니다.
코딩을 한번 시작을 하겠습니다.
코딩을 마쳤고요.
처음 딕셔너리 오브젝트를 생성을 했습니다.
키가 a고 값이 1, 그다음 키는 b고 값이 2인 딕셔너리를 간단하게 생성을 보았고 이 딕셔너리를 파라미터로 삼아서 셋 제너레이터 함수를 호출을 해서 set_obj에 배정을 했습니다.

결과가 어떤지 보겠습니다.
처음 딕셔너리 오브젝트는 문자적으로 정의를 해 준대로 a라는 키, a라는 문자열의 키와 값, 정수 1 또 b라는 문자열의 키와 값 정수 2라는 것으로써 사전이 하나 생성이 됐음을 알 수 있습니다.
그다음 이 사전을 받아서 생성된 집합에는 키만 들어가 있습니다.
밸류는 들어가 있지 않고 키 값만 a와 b가 들어가 있는데 순서는 좀 다르게 들어가 있네요.

이런 형태로 사전을 파라미터로 해서 셋 제너레이터로 셋을 셋 유형을 생성을 했더니 사전에 키만 집합에 원소가 됐다는 점을 확인을 할 수 있습니다.
이번에는 셋을 집합 유형을 생성하는데 집합 유형 객체를 생성할 때 셋 컴프리핸션을 주어서 생성하는 과정에 대해서 살펴보겠습니다.
먼저 셋 컴프리핸션을 가지고 셋 유형에 객체를 생성하려면 셋 제너레이터가 사용될 수도 있고 또 사용되지 않을 수도 있습니다.

여러분이 보는 이 구문 문법에서 첫 번째 것은 셋 컴프리핸션만을 가지고 이 집합 객체를 형성을 한 형태를 보신 거고요.
수직 바 다음으로 or죠.
그렇게 하거나 또는 셋 제너레이터를 사용하는 경우도 있습니다.
큰 차이는 없는데 과정을 좀 더 확실하게 하기 위해서는 셋 제너레이터를 사용을 한다.
대부분의 경우에는 셋 제너레이터를 사용하지 않더라도 직접적으로 중괄호만 가지고도 생성을 할 수 있다고 말씀을 드릴 수 있겠습니다.

코딩을 통해서 한번 실례를 보도록 하겠습니다.
코딩이 길어서 조금 시간이 걸렸네요.
파일스라는 리스트를 먼저 문자적으로 정의를 했습니다.
3개 항목으로 구성되어 있습니다.
각 첫 번째 항목은 index.htm 이라는 문자열, main.exe, HOME.HTML이라는 문자열입니다.
그런데 집합을 이 리스트로부터 만들고자 하는데 어떤 조건을 주어서 만들고자 하냐 하면 끝이 .htm으로 끝나든지 또는 .HTML으로 끝나는 파일을 골라서 집합에 넣고 싶다는 것입니다.

HTML로 작성된 파일만 골라서 집합을 만들고자 하는 것이죠.
이런 내용이 있을 때 이걸 집합 생성자에게는 무엇으로 표현을 하면 되나요?
그것이 바로 셋 컴프리핸션입니다.
셋에 대해서 이해를 좀 해봐라.
셋을 어떻게 만드는지 그 요구 조건을 이해를 해달라는 것이 바로 이 셋 컴프리핸션이 되는 것입니다.

그 셋에 대한 이해를 돕는 주문, 또는 요구 사항은 어떻게 표현이 되냐 하면 이 집합의 원소는 x라고 하자 그러면 x는 파일스라고 하는 리스트에 있는 모든 항목이기는 한데 그중에서도 if 문 다음에 나오는 조건을 만족하는 항목만 골라서 집합의 원소로 만들어달라는 것입니다.
어떤 조건인지 보겠습니다.

우선 x라는 항목 문자열을 전부 소문자로 고쳐놓고 그 소문자로 되어 있는 문자열 중에서도 .htm 이든지 .HTML 로써 끝나는 문자열만 골라서 x가 되도록 해달라는 것입니다.
왜 이런 주문을 할까요?
우리가 일반적으로 파일 이름을 줄 때 대소문자로 구별하기도 하지만 또 대소문자로 구별하지 않는 시스템들도 있습니다.

이런 경우에는 특히 이다음에 보이는 끝에 보이는 이 HOME.HTML이라고 하는 것이 대문자, 모든 것이 다 대문자로써 HTML이 될 수도 있는 것이고 소문자로도 작성이 될 수도 있는 것입니다.
구별을 안 하는 경우도 있다는 것이죠.
그런 경우에는 이렇게 HTML라고 하는 것을 소문자로만 두면 조건을 줄 때 그 조건의 수는 줄어들겠지만 이렇게 대문자로 표현된 파일 이름은 빠지게 된다는 것이죠.

이런 것들을 막기 위해서 아예 어떤 형태로 대문자든 소문자든 어떤 형태로 항목들이 주어지든 간에 모두 소문자로 통일시켜놓고 그 중에서 .htm로 끝나든지 .HTML로 끝나는 것을 고르자 이렇게 하는 것이 가장 안전하다 해서 로워로 사용을 하는 것입니다.
지금까지 설명 드린 과정에서 셋 컴프리핸션이 어떤 의미를 갖고 있고 또 어떤 형태로 작성이 된다 하는 것을 여러분이 이해를 하셨을 것으로 생각을 합니다.

첫 번째 html1은 이렇게 셋 컴프리핸션을 사용하면서 중괄호를 사용해서 직접 집합에 대한 문자적인 표현이 되도록 만든 것이고 두 번째는 집합 중괄호를 사용하는 대신에 이 셋 제너레이터를 사용한 경우를 또 두 번째는 보실 수 있는 것입니다.
의미는 다 똑같습니다.
그러면 이 두 가지가 어떤 셋을 만드는지 보겠습니다.

모두 동일한 집합 유형 객체를 만들고 있음을 확인을 할 수가 있습니다.
이렇게 셋 컴프리핸션을 가지고 셋 객체를 형성을 할 때에는 중괄호를 이용해서 그 속에 셋 컴프리핸션을 넣는 경우도 있고 셋 제너레이터를 이용해서 그 셋 제너레이터의 파라미터로써 이 셋 컴프리핸션을 넣는 경우도 있다 그 두 가지 방법을 코딩으로써 지금 확인을 해보았습니다.

이제는 집합의 원소 수를 계산하는 과정을 실습을 해보겠습니다.
아주 간단합니다.
len이라는 함수를 사용하기만 하면 됩니다.
len의 파라미터로써 집합 객체를 주면 그 집합 객체 속에 있는 아이템의 수를 len이라는 함수가 리턴을 해 주기 때문에 그 수만 확인을 해보면 되는 것입니다.
코딩을 해서 기능을 확인을 해보도록 하겠습니다.

코딩이 끝났습니다.
셋 오브젝트라는 참조 이름은 어떤 셋을 가리키고 있는지 보겠습니다.
헬로우 월드라는 문자열로 생성된 집합입니다.
이런 경우에는 hello 등등의 철자들이 다 독립적인 집합의 항목으로 나오게 되겠죠.
그러나 그 숫자는 우리가 금방 알기는 어렵습니다.
그 숫자가 얼마인지 len 함수를 통해서 이제 확인을 해보는 것입니다.
런을 해보겠습니다.

셋 오브젝트에서 l, w, d 등등의 철자들로 이루어진 항목들이 보이고 있고 이런 항목들의 수는 바로 9개다하는 것을 금방 확인할 수 있습니다.
다음에는 집합 속에 어떤 원소가 있는지 또는 어떤 주어진 객체가 그 집합의 원소인지를 확인해보는 과정을 코딩을 통해서 실습을 해보겠습니다.

그전에 문법적인 구조를 보면 in이라고 하는 오퍼레이터를 사용합니다.
또는 not in 이라고 하는 키워드 오퍼레이터를 사용을 하게 되는데 이런 오퍼레이터를 사용하는 구문은 지금 여러분이 보시는 박스와 같은 형태로 주어지고 있습니다.
이런 in 또는 not in이라는 사실은 파이썬의 키워드들입니다.

키워드를 가지고 구성을 한 오퍼레이터들, 존재 또는 소속을 확인하는 오퍼레이터들의 기능을 코딩을 통해서 확인을 해보겠습니다.
코딩이 끝났습니다.
조금 전에 보셨던 index.htm, main.exe, home.html 이라는 항목을 가진 집합을 생성을 했고 정의를 했고 그다음에 main.exe가 이 집합의 원소인지 확인하려면 in 오퍼레이터를 사용을 해야 하는데 그 결과를 보도록 하겠습니다.

물론 원소니까 트루가 나와야겠죠.
보겠습니다.
트루가 나왔습니다.
즉 이그지스트라고 하는 이 검사 결과를 받은 객체 참조는 바로 불 유형의 객체임을 알 수가 있고 그 값은 트루가 나왔다는 것을 이 코딩을 통해서 확인을 할 수 있는 것입니다.
지금부터는 본격적으로 집합 연산에 대해서 살펴보도록 하겠습니다.

첫 번째가 유니온입니다.
합집합.
이 합집합을 구할 때 셋 점 유니온이라는 메소드를 사용합니다.
메소드를 사용하는 문법 구조는 박스와 같은 모양을 나타내고 있습니다.
메소드 즉 유니온 메소드 속에 집합을 이제 집합 객체를 인수로 주면 되는 것입니다.
한번 보겠습니다.
코드를 보시면 2개의 집합이 지금 정의가 됐습니다.

s1은 abc, 문자열로써 즉 a와 b와 c라는 항목을 가진 집합이 됐고 s2는 bcd라는 문자열로써 b,c,d 3개의 항목을 가진 집합이 됐습니다.
이들을 유니온 메소드를 이용해서 합집합을 구해서 그 합집합의 객체를 us1이라는 객체 참조에 할당을 한 것입니다.

이렇게 유니온이라는 메소드를 사용한 경우도 있고 또 or라고 하는 집합에서는 유니온이 됩니다.
수직 바인데 이 수직 바 오퍼레이터를 사용해서 유니온 계산을 한 2가지 경우를 모두 살펴보았습니다.
결과는 모두 동일해야겠죠.
결과를 확인을 해보겠습니다.
런을 해서 동작을 시켰더니 s1이라는 집합 b,a,c s2라는 집합 b,d,c.
그리고 유니온 집합 1은 us죠.

us1은 d,b,a,c.
순서가 뒤죽박죽이라서 조금 알아보기는 힘들지만 자세히 보면 이런 원소들이 모두 s1집합과 s2집합에서 왔고 공통집합은 중복되어 있는 것들은 모두 하나로 통일되어 있음을 볼 수가 있습니다.
또 us2도 동일한 값을 가지고 있습니다.
그래서 이 유니온 메소드를 통해서 형성한 유니온 합집합이든 또는 오퍼레이터를 통해서 형성한 그 합집합이든 두 집합은 동일하다 볼 수 있습니다.

좀 더 확실하게 확인을 하려면 us1은 us2인가를 보고 확인을 해보면 되겠죠.
대부분은 프린트를 써줘야지 확인하기가 쉽습니다.
런을 해보겠습니다.
트루가 나와서 두 집합은 동일하다는 것을 확인할 수 있었습니다.
이제 두 집합에 대한 합집합을 업데이트 메소드로 찾는 방법을 실습을 해보겠습니다.

업데이트 메소드를 사용하는 방법은 지금 박스에 나와 있듯이 업데이트 메소드 안에 셋 오브젝트를 파라미터로 지금 받고 있는 형태로 문법 구조가 형성되어 있습니다.
코드를 먼저 보도록 하겠습니다.
코딩을 했는데요.
처음에 2개 집합을 정의를 합니다.
그리고 s1.업데이트 s2 형태로 업데이트 메소드를 사용을 했습니다.
이렇게 하면 s1과 s2를 합집합을 만들어서 그 결과를 다시 s1에 반영을 시키는 것을 뜻합니다.

바로 그 점이 앞에서 우리가 다루었던 유니온과 다른 점이라고 할 수 있습니다.
유니온은 s1 .
유니온 s2라고 하더라도 s1 이나 또는 s2에 변화를 주지는 않습니다.
새로운 객체를 만들어서 리턴을 할뿐이죠.
그러면 그 새로운 객체를 배정을 받아서 사용하기 위해서 외부에 이퀄 기호를 넣고 그 왼쪽 객체로써 lhs죠.
그 lhs로써 다른 객체 참조를 두어서 새로운 합집합 객체를 받아 참조를 하도록 하면 되는 것입니다.

그렇지만 현재 우리가 지금 다루고 있는 업데이트는 그렇게 하지 않고 합집합의 구성 요소가 되어 있는 집합을 변화시킨다는 것이 다르다 하는 것입니다.
그리고 이런 것들을 오퍼레이터로 표현하기 위해서는 바로 강화 어사인먼트 기호를 사용할 필요가 있습니다.
수직 바는 앞에서 유니온의 의미로써 사용된 오퍼레이터였죠.

여기에 바로 어사인먼트 기호를 이퀄 기호를 붙임으로써 이것을 강화 어사인먼트 즉 오그먼티드 어사인먼트라고 할 수 있는데 s1과 s2의 합집합을 구한 다음에 s1에 집어넣는다.
그래서 s1의 내용을 업데이트 시키고 완전히 바꾼다는 의미를 가지고 있습니다.
그 결과가 어떤지 프린트물을 통해서 양쪽의 결과를 살펴보도록 하겠습니다.
프린트물이 지금 두 군데 들어가 있습니다.
s1과 s2를 보니까 s1이 바로 s1 원래 있었던 s1 s2의 합집합이죠.

두 번째도 마찬가지입니다.
오퍼레이터를 사용하던 업데이트라는 메소드를 사용하던 그 결과는 모두 동일함을 볼 수 있고 그 결과 가운데에서 s1에 합집함이 들어가 있음을 볼 수가 있는 것입니다.
이제 교집합에 대해서 살펴보겠습니다.
교집합을 위한 메소드는 바로 인터섹션 메소드입니다.
그리고 오퍼레이터로써는 앤드.
앤퍼센트 마크를 교집합 오퍼레이터로 사용을 합니다.

그런 오퍼레이터의 문법들 또는 메소드의 문법들은 박스에 나와 있는 형태로 여러분이 보시면 되겠습니다.
사용을 하시면 되겠습니다.
코딩을 한번 해보겠습니다.
코딩을 했습니다.
두 개의 집합을 생성을 새로 했습니다.
그리고 s1 .
인터섹션 s2를 불렀는데 앞에서의 유니온과 마찬가지로 이 인터섹션은 s1과 s2를 가지고 교집합을 만들지만 s1이나 s2를 변화 시키지는 않습니다.

새로운 교집합을 만들어서 리턴을 하기 때문에 그 리턴을 받아줄 수 있는 lhs 즉 레프트 핸드 사이드 참조자가 필요한 것입니다.
그것을 인터섹션 세트 원이라고 표현을 해보겠습니다.
그다음에 오퍼레이터를 통해서 인터섹션을 또 수행을 해보겠습니다.
이 두 결과는 어떻게 될까요.
모두 같음을 볼 수 있습니다.
s1 s2는 변하지 않았고 is1과 is2는 동일한데 B와 C라고 하는 엘리먼트만 가지고 있습니다.

B와 C는 바로 s1 , s2가 공통적으로 가지고 있는 원소임을 우리는 알 수 있고 is1, is2 는 바로 두 s1 s2 집합의 교집합이다라는 것을 확인할 수 있습니다.
이번에는 조금 전에 보셨던 업데이트와 마찬가지로 업데이트는 유니온의 결과를 어느 한 집합에 반영을 시켜서 변화를 시킨 것이었죠.
인터섹션도 그런 역할을 하는 메소드를 사용을 할 수 있는데 그것이 인터섹션 업데이트입니다.

또 이 인터섹션 업데이트를 오퍼레이터로 표현하는 것이 앤퍼센트와 이퀄 기호를 합쳐서 만든 오그먼트 어사인먼트 오퍼레이트입니다.
이 둘을 사용하는 문법에 대해서는 박스에 있는 내용을 여러분이 보시면서 참조를 하시고 또 사용을 하시면 되겠습니다.
코딩을 통해서 기능을 확인을 해보겠습니다.
코딩을 한번 보시기 바랍니다.

두 개의 집합을 만들었고 s1 .
인터섹션 업데이트 s2 하면, s1과 s2를 교집합을 만든 그 결과가 바로 s1으로 다시 반영이 돼서 들어가는 것입니다.
업데이트를 시키는 것입니다.
이런 과정을 오퍼레이터로 표현한다면 s1 앤퍼센터 이퀄 s2라는 그 강화 배정 연산자로 표현을 할 수가 있습니다.
두 결과는 모두 같게 나올 것입니다.
결과를 보겠습니다.
s1과 s2인데, s1의 이 교집합이 들어가 있음을 볼 수가 있고 s2는 변하는 것은 없습니다.

이렇게 인터섹션 업데이트는 그 메소드를 제공한 집합이 변하도록 업데이트가 되도록 한다는 것을 보여주는 것입니다.
이번에는 차집합에 대해서 보겠습니다.
셋 디퍼런스 메소드이고 또 연산자로써는 마이너스 기호를 사용하면 됩니다.
그 문법에 대해서는 단지 메소드를 제공하는 집합이 하나 필요하고 그 메소드 안에는 다른 집합이 상대가 되는 집합이 빼주는 집합이죠.
빼주는 집합이 파라미터로써 들어가 있게 되는 것입니다.

코딩을 통해서 예를 보겠습니다.
코딩을 했습니다.
두 집합 s1, s2가 있습니다.
s1 .
디퍼런스 s2하면 s1으로부터 s2를 빼고 그 나머지 차를 s3라는 집합으로써 받는 것입니다.
한 번은 메소드를 사용했고 한 번은 마이너스 오퍼레이터를 사용해서 s3와 s4 두 차집합을 구했고 두 차집합은 동일하다는 것을 보면 되는 것입니다.
보겠습니다.
모두 A라는 원소를 가진 차집합이 생성이 됐음을 확인 할 수 있네요.

즉 s1은 abc 또는 s2는 bcd라는 3개의 항들로 구성된 집합들인데 이들의 차는 a로부터 s2를 빼면 뭐가 남을까요.
b와 c가 없어지고 a만 남는다 하는 것이죠.
이 결과를 보여드린 것입니다.
이제는 차집합인데 차집합 빼어진 집합, 빼어진 집합에 그 차집합이 들어가서 업데이트가 되는 과정을 실습으로써 보도록 하겠습니다.

업데이트시키는 메소드는 바로 디퍼런스 업데이트입니다.
그리고 이 디퍼런스 업데이트를 똑같은 기능을 하도록 만들어놓은 오퍼레이터가 마이너스와 이퀄 기호를 합쳐놓은 강화 배정 연산자로 구성을 할 수가 있습니다.
그 코딩을 한번 살펴보도록 하겠습니다.
코딩을 마쳤습니다.
s1, s2 2개의 집합이 만들어졌습니다.

이제는 설명을 안 드려도 이 집합들의 내용이 어떤 원소들로 구성 됐구나 하는 것을 아시겠죠?
s1.
디퍼런스 업데이트 s2의 형태로써 메소드를 사용을 했습니다.
이 두 차집합의 결과가 s1으로 들어가야겠죠.
그것을 오퍼레이터로 사용을 한 것이 바로 이 s1 마이너스 이퀄 s2라고 하는 것입니다.
s1 빼기 s2의 결과를 s1에 배정을 하겠다는 그 수식이 되는 것이죠.
이 두 경우를 모두 s1를 가지고 확인을 해보겠습니다.
s1이 모두 같습니다.

첫 번째 메소드를 사용한 경우에 a라는 항목만 남은 차집합으로써 s1이 변했습니다.
두 번째 오퍼레이터를 통한 경우에 예를 봤을 때에도 s1은 a라는 하나의 원소를 가진 차집합으로 변했음을 확인할 수가 있습니다.
이제는 대칭 차집합에 대해서 살펴보도록 하겠습니다.
스메트릭 디퍼런스입니다.

조금 전에는 차집합을 구하되 한쪽이 어느 한쪽을 빼는 경우에만 있었는데 지금 스메트릭 디퍼런스라고 하는 것은 양쪽에서 다 그 공통부분을 뺀 나머지 결과를 가지고 차집합을 구성하는 경우가 되겠습니다.
먼저 보실 것은 그 결과, 차집합을 형성한 결과 집합이 제3의 전혀 다른 집합 객체로 리턴이 되는 경우이고 또 예상을 하시겠지만 이다음에 볼 것은 업데이트가 되는 경우죠.

차집합에 참여한 두 집합 중에 어느 한 집합이 그 차집합의 결과를 안게 되는 그 내용으로 업데이트가 되는 과정을 살펴보도록 하겠습니다.
우선 차집합을 구하는, 대칭 차집합을 구하되 새로운 객체를 형성하는 과정에 대해서 코딩을 했습니다.
그 오퍼레이터로써는 이 오퍼레이터를 삿갓이라고 표현하기도 하고 캐롯이라고 표현을 하기도 하는데 캐롯이라고 표현을 하겠습니다.
그 대칭 차집합의 결과는 뭐가 될까요?

지금 s3와 s4가 s3는 메소드를 통해서 얻은 차집합이고 s4는 오퍼레이터를 통해서 얻은 차집합인데 모두 ad, ad 동일한 차집합이 얻어졌음을 확인을 할 수가 있습니다.
대칭적인 차집합이죠.
두 번째 예도 업데이트가 되는 경우인데 그 업데이트 되는 경우에 문법 구조 여러분이 잠깐 보고 넘어가시면 되겠습니다.
박스에 표현되어 있는 것과 마찬가지로 셋 오브젝트 1에 차집합의 내용이 들어와서 업데이트가 되는 형태입니다.

또 밑에 있는 오퍼레이트를 사용한 경우에도 셋 오브젝트 1의 셋 오브젝트 1, 셋 오브젝트 2 대칭 차집합의 결과가 셋 오브젝트1으로 들어와서 업데이트가 되는 경우의 문법 구조를 보시게 된 것입니다.
코딩을 해보겠습니다.
코딩을 했습니다.
코딩을 한번 보시기 바랍니다.
두 집합을 새롭게 생성을 했고 시메트릭 디퍼런스 업데이트 메소드를 이용해서 s1과 s2의 대칭 차집합을 구해서 s1에 그 결과를 집어넣은 형태가 됐습니다.

그 결과를 프린트로써 확인을 했고요.
그다음에는 다시 s1을 원상 복구했습니다.
그러고 나서 오퍼레이터를 통해서 대칭 차집합을 구해서 그 결과를 s1에 집어넣는 과정을 또 한 번 실행을 한 것입니다.
그 결과를 프린트문로써 또 확인을 했습니다.
2개의 프린트 문이 같은 결과를 표시를 해야겠죠?
진짜 그런지 확인을 해보겠습니다.

똑같이 a와 d라고 하는 두 원소를 가진 대칭 차집합을 형성을 해서 그것이 s1 집합에 업데이트가 됐음을 확인할 수가 있었습니다.
지금까지 집합을 정의를 하고 그 집합들에 대한 기본적인 연산을 하는 과정에 대해서 살펴보았습니다.
다음 실습에서는 이 바로 다음에 나오는 실습에서는 조금 더 논리적으로 고급에 해당하는 과정을 보겠습니다.
즉 집합들의 관계라든지 그다음에 집합 연산에 대한 좀 더 복잡한 관계를 살펴보도록 하겠습니다.
