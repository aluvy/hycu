-------------------------------------------------------------
09_04. 집합 유형 데이터 고급 처리
-------------------------------------------------------------

[4페이지]

이번 시간에는 집합 유형 데이터에 대한 좀 더 심화된 과정에 대해서 알아보겠습니다.
즉 집합과의 관계.
그리고 동결 집합 또 집합의 원소들을 다루는 방법들에 대해서 알아보겠습니다.
먼저 집합의 관계라고 하면 그 집합 사이에 부분집합이다, 슈퍼셋이다 또는 동일집합이다 하는 관계를 우리가 따져볼 수가 있는데 먼저 부분집합을 검사를 하는 과정을 보겠습니다.

여기에 사용하는 메소드는 섭셋입니다.
셋 이즈 섭셋입니다.
즉 섭셋인가라고 물어보는 메소드죠.
그렇다면 트루를 내놓고 그렇지 않다면 폴스를 내놓는 분류한 밸류를 리턴하는 메소드가 되겠습니다.
이에 대한 연산자로써는 같거나 적다 또는 적다라는 연산자를 사용을 하는 것입니다.
이들의 사용 문법들에 대해서는 박스에 나와 있는데요.
참조를 해 보시기 바랍니다.
이제 코딩을 통해서 그 기능을 확인을 해 보겠습니다.

코딩을 해 놓은 것을 보시면 S1이 A와 B와 C라는 문자로 이루어진 집합이고 S2는 A부터 E까지 5개의 문자로 이루어진 집합입니다.
보시면 S2는 S1의 원소를 다 포함하고 있음을 알 수 있죠.
이런 경우에는 S2가 S1의 슈퍼셋 또는 S1이 S2의 섭셋이 되는 것입니다.
이제 보겠습니다.
S1이 S2의 섭셋인가라고 물어보는 것과 같다고 생각을 해 보시면 됩니다.
이것을 오퍼레이터로 표현을 했을 때에는 S1이 S2보다 작다.

이거는 집합에서 본다면 S1이 S2보다 작은 집합이니까 바로 부분집합이라는 것을 묻는 구문이 되는 것이죠.
또는 같거나 작다는 것도 적다라는 것도 역시 같은 뜻을 가진 오퍼레이터라고 볼 수가 있습니다.
이들의 결과는 어떤지 보겠습니다.
런을 시켜보면 다 모두 트루라는 것을 알 수가 있습니다.
이번에는 상위 집합 검사를 해 보겠습니다.
상위 집합이라는 것은 부분집합의 반대가 되는 개념이죠.

A라는 집합이 B라는 집합의 부분집합이라면 B라는 집합은 A라는 집합의 상위 집합이라고 이야기를 할 수가 있습니다.
이것을 메소드로 검사를 한다면 이즈 슈퍼셋 메소드를 사용하면 되겠고 오퍼레이터를 사용한다면 섭셋 검사를 위해서 사용한 그 오퍼레이터를 반대 방향의 의미를 가진 오퍼레이터를 사용하면 되는 것입니다.
오퍼레이터라든지 메소드를 사용하는 문법은 화면에 나타나 있는 것과 같습니다.

첫 번째 위에 있는 것이 이즈 슈퍼셋 메소드를 사용하는 문법이고 두 번째와 세 번째는 오퍼레이터를 사용하는 문법이 되겠습니다.
참조를 하셔서 코딩 실습을 해 보도록 하겠습니다.
코딩을 한번 보시기 바랍니다.
조금 전에 다루었던 섭셋 검사를 하는 코딩과 다르지 않습니다.
다만 S1이 S2보다 긴 집합이 됐죠.
S1이 S2의 원소 C와 D를 다 포함을 하고 있습니다.
이런 경우에 S1이 S2의 슈퍼셋인가, 라고 지금 물어보고 있는 것입니다.

두 번째 나온 아규먼트는 S1이 S2보다 크냐 즉 슈퍼셋이냐.
슈퍼셋이라고 선언을 하는 명제가 되는 것입니다.
세 번째 아규먼트는 S1이 S2보다 크거나 같다라는 명제를 표현하는 것입니다.
이 세 가지 명제가 다 트루인지 살펴보도록 하겠습니다.
다 모두 트루가 됩니다.
즉 S1이 S2의 슈퍼셋이 맞다는 것을 세 가지 방면에서 다 확인을 해 본 것입니다.
이제는 집합들 간의 동일성 검사를 해 보겠습니다.

동일성 검사를 할 때는 이즈라는 키워드를 사용하든지 또는 더블 이퀄 오퍼레이터를 사용합니다.
그런데 이 두 키워드나 오퍼레이터는 의미가 완전하게 같지는 않습니다.
이즈라고 하는 것은 완벽하게 동일한 객체인가라는 것까지 확인을 하는 것이고, 더블 이퀄 오퍼레이터는 단지 두 집합의 원소의 값이 동일한가.
원소의 수 또는 원소의 값들이 동일한 것들이 들어 있는가라는 정도만 확인을 하는 것입니다.
같은 객체인지 다른 객체인지 확인하지 않습니다.

그것이 더블 이퀄과 이즈의 차이라고 볼 수 있습니다.
사용하는 문법들에 대해서는 역시 화면에 나타나 있으니까 처음에 나타나 있는 이즈를 사용하는 구문과 또 더블 이퀄 오퍼레이터를 사용하는 구문을 구문의 문법을 잘 보시면서 코딩에 적용을 하시면 되겠습니다.
코딩을 한번 해 보겠습니다.
코딩을 보시기 바랍니다.
여기에 S1이 A와 B와 C 3개의 항목을 가진 집합으로 정의가 됐고 S1을 S2에 다시 배정을 했습니다.

이 경우에는 S1과 S2는 동일한 객체를 함께 참조하는 2개의 객체 참조자가 됩니다.
그래서 S1과 S2라는 이 동일 객체 참조자가 이즈인지 즉 같은 객체를 참조하고 있는지 또는 한 하나의 실제로는 하나의 객체인지를 그래서 그런 정도까지의 동일성이 있는지를 확인을 해 보는 것이 이즈 키워드로써 검사를 동일성 검사를 하는 것입니다.

그다음에 이 더블 이퀄이라는 것은 S1과 S2가 가리키는 그것이 다른 객체이든지 동일한 객체이든지 상관없이 그 객체 안에 들어 있는 원소가 동일한지만 판단을 해 보는 것이 이 더블 이퀄 오퍼레이터의 역할이 되는 것입니다.
두 경우에 동일성을 한번 실행을 시켜놓고 결과를 보겠습니다.
여기에서 모두 같은 결과를 나타내고 있음을 볼 수 있습니다.

그다음에는 S1과 S2가 동일한 모양을 가진 집합들이기는 하지만 그러나 실제로는 서로 다른 객체인 경우를 보겠습니다.
즉 S1과 S2를 별도 독립적인 객체로 생성을 해놓고 이즈 검사를 한다든지 더블 이퀄 검사를 해 보도록 하겠습니다.
코딩을 한번 해 보겠습니다.
코딩을 끝냈습니다.
보시다시피 S1은 A, B, C 일단 3개의 문자로 이루어진 집합이고 S2도 역시 독립적인 새로운 객체로써 생성을 했는데 그 원소들은 S1과 동일합니다.

A와 B와 C라는 3개의 문자로 이루어진 집합입니다.
이때 이즈로써 테스트를 한 경우와 더블 이퀄로써 테스트를 한 경우가 어떤 결과를 나타내는지 실행을 시켜보겠습니다.
처음에 이즈는 실패했습니다.
즉 동일한 객체가 아니고 서로 다른 객체라는 것을 의미합니다.
그리고 이퀄은 성공했습니다.
이 두 사실을 종합해서 보건대 S1과 S2는 항목들은 다 동일합니다.
그렇지만 S1과 S2는 전혀 다른 별도의 독립적인 객체라는 것을 알 수가 있는 것입니다.

우리가 집합을 정의를 하고 형성을 할 때 생성을 할 때 처음부터 모든 원소를 다 결정을 해놓고 생성을 하는 경우는 별로 많지 않죠.
심지어는 처음에는 공집합을 만들어놓고 거기에 필요에 따라서 항목을 하나둘씩 추가를 시켜나간다든지 또 필요에 따라서 있던 항목을 제거를 함으로써 항상 우리가 원하는 형태의 집합이 되도록 유지, 관리하는 것이 더 일반적이고 보편적인 모습이라고 할 수가 있습니다.

이제 집합에 필요한 항목을 그때그때 추가시키기 위해서 어떤 기능을 사용을 하는지 보도록 하겠습니다.
바로 애드 메소드를 사용을 합니다.
이 애드 메소드를 사용하는 문법 구조는 화면에 나타나 있으니까 참조를 해 보시고 그 문법대로 코딩이 이루어지는지도 확인을 해 보시기 바랍니다.
코딩을 한번 해 보겠습니다.
코드를 보시면 처음에 S1 집합을 A와 B와 C 3개의 문자 항목으로 이루어진 집합으로 생성을 했습니다.

여기에 필요에 따라서 2라는 정수 항목도 추가를 시켰고 C 또는 D라는 문자로 된 항목도 추가를 시켰습니다.
결과적으로 S1에는 A, B, C, D 그다음에 숫자 2가 원소로 들어 있는 집합이 될 것이 예상이 되는데 과연 그런지 프린트문을 통해서 내용을 확인을 해 보도록 하겠습니다.
런을 해 보겠습니다.

2, D, A, C.
B.
순서는 좀 다르지만 우리가 예상했던 대로 5개의 항목이 들어 있음을 볼 수 있습니다.
처음에 3개였고 그다음에 추가한 것이 3개인데 왜 6개가 아니고 5개인가라고 이상하게 생각하실 분이 혹시 계실지 모르겠는데 그러면 안 되겠죠.
여기에서 원래 C라는 문자 항목이 있었고 또 애드로써 똑같은 문자 항목을 더해 주고 있기 때문에 중복된 항목은 더하나 마나라고 말씀을 드렸었죠.
하나만 나타나게 되는 것입니다.

그래서 6개가 아닌 5개가 나타나는 것을 알 수가 있습니다.
어떤 경우에는 집합을 잘 사용하다가 그 집합에 있는 내용들이 이제 더 이상 필요가 없다.
싹 없애고 처음부터 새로 한번 시작을 해 보자라는 경우도 있을 겁니다.
이때 사용하는 것이 클리어 메소드가 됩니다.
클리어 메소드는 사용 방법은 굉장히 단순한데 화면에 있는 문법 구조를 따르시면 되겠습니다.
실습을 해 보겠습니다.

S1의 세트 제너레이트를 통해서 A와 B와 C 3개의 항목이 들어 있는 집합을 생성을 했습니다.
그리고 내용을 확인을 했고요.
클리어 메소드를 이용해서 내용을 싹 비우고 또 한 번 프린트문으로써 내용이 어떻게 됐는지 확인을 해 보는 코딩입니다.
실행을 시켜보겠습니다.
처음 의도했던 대로 3개의 항목이 들어 있음을 확인했고 두 번째 확인에서는 바로 공집합이 되어 버렸음을 확인을 할 수가 있습니다.

클리어 메소드에 의해서 모든 항목들이 다 삭제가 되고 이 집합이 공집합이 됐음을 알 수가 있습니다.
그다음에는 조금 전에는 그 원소가 몇 개가 있든지 한꺼번에 다 없앴는데 실제로 그런 경우는 또 많지는 않죠.
원하는 원소만 없애는 과정이 필요합니다.
이때 사용하는 것이 디스카드 또는 리무브가 되는데 먼저 디스카드 메소드를 보겠습니다.
디스카드 메소드를 사용하는 문법은 화면에 나와 있는 내용을 확인을 해 주시기 바랍니다.

코딩을 시작을 해 보겠습니다.
코드를 보시면요.
S1에 공집합을 처음에 만들어서 할당을 했습니다.
그러고 나서 다짜고짜 디스카드 메소드를 적용을 합니다.
A라는 항목을 없애라.
그럼 언뜻 생각하면 이거 공집합 아무것도 없는 데에서 엉뚱한 것을 지정을 해서 없애라고 하니까 뭔가 오류가 발생하겠구나라고 조마조마한 마음이 들기는 합니다.
그렇지만 디스카드라고 하는 메소드는 엄격하지는 않습니다.

없는 것을 삭제하라고 해도 있으면 삭제하지만 없으면 아무런 동작을 하지 않는 좀 점잖은 행동을 하는 메소드가 됩니다.
그 내용을 그래서 S1의 내용을 확인을 해 보겠고요.
그다음에 S1을 다시 한 번 새롭게 생성을 시켜보겠습니다.
이제는 3개의 항목을 가진 집합으로 생성을 해서 여기에 디스카드를 해 보겠습니다.
그런데 이때도 마찬가지로 없는 항목을 D라는 항목을 삭제를 하라고 해 보겠습니다.

그러고 나서 결과는 어떻게 되는지 또 B라는 항목을 이제는 삭제를 하라고 했을 때 또 어떤 행동을 하는지 이렇게 여러모로 디스카드 메소드가 어떤 행동을 하는지 실습을 통해서 코딩을 통해서 확인을 해 보겠습니다.
이제 보겠습니다.
아무것도 없는 데서 디스카드 A를 하라고 했을 때에는 그 결과는 공집합 그대로 남아 있음을 볼 수가 있습니다.
또 A, B, C에서 없는 D를 삭제하라고 했을 때에는 바로 A, B, C는 그대로 남아 있음을 볼 수 있습니다.

그리고 A, B, C 중에서 B을 삭제하라.
이때는 B가 있었죠.
존재하는 B를 삭제하라고 했으니까 A와 C만 남고 B는 없어졌음을 확인할 수가 있습니다.
이와 같이 B는 웬만하면 화를 내지 않고 여러분의 요구를 잘 들어주는 디스카드 메소드는 그런 역할을 한다고 보시면 되겠습니다.
그에 반해서 리무브는 어떠한 역할을 하는지 보겠습니다.
리무브도 조금 전에 보셨던 디스카드와 비슷한 행동을 하는데 조금 예민합니다.

좀 없으면 잘못된 요구를 하면 화를 잘 내는 메소드라고 할 수가 있습니다.
우선 리무브의 문법 구조를 보시기 바랍니다.
집합에서 빼고자 하는 아이템을 주는 모습은 디스카드와 같습니다.
코딩을 통해서 리무브가 어떤 성격을 가지고 있는지 확인을 해 보도록 하겠습니다.
리무브의 행동을 확인하기 위한 코딩을 일단 보겠습니다.
리무브를 확인하기 위한 코딩을 해 봤습니다.

첫 번째 줄은 A와 B와 C라는 항목을 가진 집합으로써 S1을 생성을 했고 이제 있는 원소를 삭제하라고 리무브를 불렀습니다.
그러고 나서 그 동작 결과를 프린트문으로써 확인을 했습니다.
그다음 줄은 3이라고 하는 원소.
이 3이라고 하는 원소는 S1에는 원래 없는 원소이죠.
이럴 때 리무브는 어떤 행동을 할까요?
이런 내용들을 실행을 통해서 확인을 해 보도록 하겠습니다.

이와 같이 첫 번째 세 줄까지는 잘 동작이 된 것을 우리가 확인할 수 있습니다.
B를 없애고 A와 C만 남았죠.
그렇지만 없는 원소를 삭제하라고 명령을 주었을 때는 화를 냅니다.
키 에러라고 없는 키인데 왜 삭제하라고 했는가라는 항의를 지금 하고 있는 것입니다.
잘못된 키다 3이라는 것을 불만을 이야기하는 것입니다.
디스카드는 웬만한 요청은 다 화를 내지 않고 들어주고 못하는 것은 슬며시 못하는 것으로 남겨놓습니다.

그렇지만 리무브는 명확하게 할 수 있는 일과 못 할 일을 다 여러분들에게 알려주는 것입니다.
어느 쪽이 여러분한테는 사용하시기 편한 대상이 될까요?
디스카드가 더 쉬운 상대인가요?
리무브가 더 쉬운 상대인가요?
이거는 누가 좋다, 누가 나쁘다 이렇게 이야기는 할 수 없습니다.
그때그때 여러분의 코딩의 목적에 따라서 적당한 메소드를 여러분이 선택 사용하실 수 있도록 하는 것이 중요한 것입니다.

이번에는 팝 메소드에 대해서 살펴보겠습니다.
팝 메소드는 집합에서 맨 뒤에 있는 원소를 꺼내서 리턴을 하고 그 원소를 집합으로부터 삭제를 하는 기능을 하는 메소드입니다.
만일 집합이 공집합일 때에는 키 에러 오류를 발생하게 됩니다.
팝의 팝 메소드의 기능을 코딩을 통해서 확인을 해 보도록 하겠습니다.

첫 번째에는 S1을 생성을 했고 그다음 WHILE 반복문을 통해서 이 세트.
S1이라는 집합이 이 공집합이 아닌 동안에는 계속 반복을 하도록 했습니다.
어떤 작업을 반복하냐면 팝이라는 메소드를 실행하는 것을 반복을 하도록 했습니다.
그럼 S1이 공집합이 되면 결국은 WHILE 루프 해서 빠져나오게 되겠죠.
팝을 실행하지 않고 빠져나오기 때문에 오류가 나타나지는 않습니다.

정상적으로 WHILE 루프 돈이라고 하는 메시지까지는 표시가 될 것입니다.
그런데 문제는 공집합이 되어 있음에도 불구하고 S1에 대해서 다시 팝 메소드를 적용을 했다는 것입니다.
이때는 S1이 공집합이기 때문에 더 이상 꺼낼 것이 없기 때문에 뭔가 에러를 내고 프로그램 앤드라는 메시지는 표시하지 못할 것입니다.
그런지 실행을 통해서 확인해 보겠습니다.

이와 같이 이 WHILE 루프를 돌면서 B, A, C라는 S1 집합의 원소를 하나씩 꺼내서 프린트를 했습니다.
그리고 WHILE 루프 돈이라는 메시지까지 표시를 했는데 그리고 마지막에 S1 팝을 실행하는 순간에 키 에러가 발생을 한 것입니다.
앰프티 셋으로부터 팝을 하려고 했다는 오류 이유를 표시를 하고 있네요.
오류가 나서 이미 이 프로그램은 중간에 죽어버렸기 때문에 프린트 프로그램 앤드라고 하는 메시지는 표시가 되지 않은 것입니다.

이렇게 팝이라고 하는 것도 역시 리무브와 같이 좀 엄격한 메소드다라는 것을 알 수가 있겠습니다.
이번에는 집합을 복사하는 과정을 살펴보도록 하겠습니다.
셋 카피.
카피 메소드를 사용할 텐데 카피라고 하는 것은 파라메터가 필요하지는 않습니다.
파라메터를 지정해 두지는 않았기 때문에 인수를 쓸 필요는 없겠고 그냥 카피라는 함수만 불러주면 됩니다.

이러한 경우에는 셋 오브젝트에 있는 내용을 카피를 해서 새로운 객체를 만들고 그 객체에 대한 참조를 셋 오브젝트 투에 배정을 하는 형태가 됩니다.
그 문법을 참조를 해 보시면 되겠습니다.
코딩을 통해서 한번 기능을 확인을 해 보겠습니다.
코드에 보시면 처음 S1은 A, B, C로 항목이 구성된 집합입니다.
이 S1을 카피 메소드를 통해서 내용을 똑같은 내용을 가진 서로 다른 객체를 새로 만들어서 S2에 배정을 한 것입니다.

그럼 이 S1과 S2가 동일한 객체인지 서로 다른 객체인지 확인을 하려면 이즈 키워드로써 동일성을 테스트를 해 보면 알 수 있을 것입니다.
만일 이 부분이 트루라면 S1과 S2는 동일한 객체인데 카피는 동일한 객체가 아니죠.
새로운 객체를 만들어서 S2에 배정을 한 것이기 때문에 서로 다른 객체가 되어야지 맞습니다.

즉 폴스 거짓이라는 결과가 나와야 되는 것이죠.
그렇지만 항목들을 보면 서로 동일한 항목들을 가지고 있음을 예상할 수 있는데 그 항목들이 같으면 더블 이퀄로써 테스트를 할 수 있습니다.
두 결과가 어떤지 살펴보도록 하겠습니다.
처음 이즈 테스트는 폴스가 나왔고 더블 이퀄 테스트는 트루가 나왔습니다.

이와 같이 두 S1, S2라는 집합은 항목은 같지만 그 속에 들어 있는 내용은 같지만 서로 다른 객체로 구성된 집합이라는 것을 알 수가 있는 것입니다.
그런 역할, 그런 결과를 나타낼 수 있는 것이 카피 메소드라 하는 것을 기억을 해 주시기 바랍니다.
이번에는 동결 집합에 대해서 알아보겠습니다.
프로즌셋라고 영어로 불리는 집합이죠.

동결 집합은 바로 인뮤터블 집합입니다.
우리가 지금까지 다루었던 집합은 뮤터블 즉 가변성 객체 집합입니다.
그렇지만 동결 집합은 불변성이기 때문에 애드라든지 리무브라든지 디스카드 또는 합과 같은 메소드를 적용을 할 수가 없습니다.
이런 메소드들은 전부 대상 집합들의 내용을 변경시키는 것이죠.

없애기도 하고 추가시키기도 하는 그런 항목들을 집합 내용 자체를 변경시키는 메소드들이기 때문에 인뮤터블 객체에 대한 메소드는 될 수가 없는 것들이죠.
다만 크기를 비교한다든지 관계를 비교한다든지 또는 합집합을 만든다든지 교집합을 만드는 이런 집합 연산의 대상이 될 수는 있습니다.

이 동결 집합도.
그런 관계에만 생각을 하신다면 조금 주의만 하신다면 우리가 지금까지 다루어왔던 일반적인 집합과 매우 유사하고 그 방법 그대로 동결 집합도 다룰 수 있다는 것을 알 수가 있습니다.
동결 집합을 표현하고 생성하는 문법은 집합과 다르지 않습니다.
다만 다른 점은 타입.

객체 유형이 프로즌셋라고 하는 말이 하나 더 들어 있다는 것만 다를 뿐입니다.
나머지는 문자적으로 생성을 하든 또는 이터너블로써 생성을 하든 또는 셋 컴프리엔존으로 생성을 하든 모든 과정들이 앞에서 보셨던 과정과 동일함을 기억을 해 주시면 이 동결 집합을 생성하는 데는 전혀 문제가 없을 것입니다.
실습을 통해서 확인을 해 보겠습니다.
코딩의 첫 번째 줄은 FX1 즉 프로즌셋 1이라고 생각을 해 주시면 되겠습니다.

생성을 하는데 프로즌셋라고 하는 생성 자를 사용을 했습니다.
제너레이트 펑션을 사용을 했습니다.
여기에 이터너블이 들어갔네요.
A, B, C라고 하는 문자율 자체가 하나의 이터너블이죠.
이터너블을 넣음으로써 A, B 그리고 C라는 각각의 문자 3개의 문자로 이루어진 동결 집합이 이루어지는 것입니다.

두 번째 줄은 셋 컴프리엔존을 이용을 한 것입니다.
레인지 0에서부터 5까지 정수를 내놓는데 그것이 집합의 원소가 되는데 그대로 원소가 되는 것은 아니고 그 범위에 해당하는 숫자들에게 일괄적으로 일을 더해서 원소로 삼겠다는 뜻을 이해를 시키는 가운데 형성된 동결 집합이 되는 것입니다.
그리고 세 번째는 하나의 래핑 세트를 씨앗으로 해서 만들어진 동결 집합이 되는 것입니다.

이런 FX1, FX2, FX3가 어떤 내용으로 구성이 되는지 한번 내용을 확인을 해 보겠습니다.
FX1은 A.
B, C의 원소를 가진 동결 집합이 되고요.
두 번째 FX2는 1, 2, 3, 4, 5라고 하는 값을 가진 항목을 가진 동결 집합이 됩니다.
또 세 번째 동결 집합은 B, A, C.
역시 3개의 문자를 가진 동결 집합이 형성이 되는데 내용은 다 세트, 집합과 같습니다.

다만 이들이 인뮤터블이기 때문에 이 항목들을 더하거나 빼거나 또는 항목의 값을 변화시킬 수는 없다는 것을 다른 점으로 갖고 있는 집합이라 할 수 있습니다.
동결 집합의 공집합은 어떻게 표현을 할까요?
집합과 마찬가지로 집합에서는 셋 제너레이터에 아무런 아규먼트를 주지 않은 채로 호출을 하면 바로 공집합이 만들어졌죠.
프로즌셋에서도 마찬가지입니다.

그 제너레이터인 프로즌셋 함수에 인수를 주지 않고 비어 있는 상태로 호출을 하면 바로 동결 집합의 공집합이 형성이 되는 것이고 그 길이는 확인을 해 보면 0이 되는 것입니다.
코딩을 통해서 과정을 확인을 해 보도록 하겠습니다.
앰프티 프로즌셋 약자라고 보셔도 되겠죠.
EFS는 바로 앰프티 프로즌셋의 약자이고 그 공집합을 생성하기 위해서는 프로즌셋 제너레이터 함수를 아규먼트 없이 호출을 한다.
그리고 길이를 확인을 해 보겠습니다.

그 공집합의 길이를 확인해 보면 결과는 어떻게 될까요?
프로즌셋 공집합이라는 것입니다.
또 그 길이는 0이라고 하는 것이 확인이 됐습니다.
동결 집합 키워드와 연산자를 다시 한 번 정리해서 보면 in, not in, 그리고 랭스에 해당하는 키워드와 또 빌트인 함수를 사용을 할 수가 있습니다.
또 동결 집합에 대해서는 카피 디퍼런스 인터섹션 이즈 디스조인트, 이즈 섭셋, 이즈 슈퍼셋, 유니온 그다음에 프로즌셋, 시메트리디퍼런스.

이와 같은 지난번에 세트에서 보셨던 대부분의 메소드들을 다 사용을 하실 수 있습니다.
다만 업데이트는 사용하실 수 없다 하는 것입니다.
이런 메소드들 뒤에 업데이트들이 붙어 있는 것들이 있었죠?
이런 것들은 집합에서는 사용했지만 동결집합에서는 사용할 수 없다는 것을 그 차이만 기억을 하고 계시면
일반 집합이든 동결 집합이든 전혀 문제없이 사용하실 수 있고 이 동결 집합을 사용하는 이유는 데이터를 좀 더 신뢰성 있게 다루기 위해서 필요한 것이니까 동결 집합에 대한 쓰임새라든지 필요성에 대해서는 또 나중에 우리가 좀 더 코딩을 진행해나가면서 확인을 해 보도록 하겠고 이것은 이 차시는 아니고 후속된 차시에서 확인 과정이 일어날 것입니다.

이제 조금 한 가지만 더 확인할 것은 그럼 일반 집합과 동결 집합을 혼합해서 사용할 수는 있겠는가.
맞습니다.
혼합해서 사용할 수 있습니다.
그럼 혼합해서 사용할 때는 어떤 점을 주의를 해야 될까 하는 점만 확인을 해 보겠습니다.
첫 번째는 연산 결과의 유형은 연산자의 왼쪽 유형을 따른다.

일반 집합이 연산자의 왼쪽 유형은 그 결과는 일반 집합이 되는 것이고 동결 집합이 연산자의 왼쪽에 있다면 그 연산 결과는 동결 집합으로 나타난다 하는 점만 여러분이 유의를 하시면 됩니다.
코딩을 통해서 이 이야기를 확인을 해 보고 좀 더 이해를 도와드리도록 하겠습니다.
코딩을 했습니다.
프로즌셋을 생성을 해서 FS에 배정을 했고 일반 셋을 생성을 해서 S에 배정을 했습니다.

이제 유니온이라고 하는 오퍼레이터를 통해서 그 혼합사용에 대한 규칙을 한번 살펴보도록 하겠습니다.
이 오퍼레이터, 유니온 오퍼레이터의 왼쪽에 프로즌셋이 있습니다.
이럴 때 U1은 유니온1이라고 하는 것은 프로즌셋이 될까요?
또는 일반 셋이 될까요?
바로 앞에서 말씀드렸던 대로 프로즌셋이 돼야 되겠죠.
오퍼레이터의 왼쪽에 프로즌셋이 있으니까 결과도 프로즌셋이 되는 것입니다.

그 반대로 오퍼레이터의 왼쪽에 S라고 하는 일반 셋이 있을 때는 U2라고 하는 둘을 유니온 시킨 결과는 일반 셋이 되는 것입니다.
그 결과를 프린트문으로써 확인을 해 보시기 바랍니다.
실행을 해 보겠습니다.
U1은 바로 타입이 프로즌셋이 됩니다.
바로 이와 같이 U1의 타입은 클래스 프로즌셋이고 내용은 바로 A, B, C, D, E가 들어가 있는 5개의 원소로 구성돼 있는 유니온이 되는 것이죠.

그 타입이 프로즌셋임을 확인할 수가 있습니다.
그와 다르게 U2는 일반셋이죠.
원소는 동일합니다.
A, B, C, D라는 5개의 문자로 이루어진 원소이고 타입은 일반 집합임을 알 수가 있습니다.
이 규칙만 여러분이 기억을 하신다면 일반 셋을 다룰 때나 동결 셋을 다룰 때나 이 둘을 섞어서 다룰 때 문제없이 여러분이 사용하실 수 있게 되는 것입니다.

이번 차시에서는 이제 집합에 대한 일반적인 개념 또 집합 연산, 집합의 관계에 대한 검사 그리고 집합의 엘리먼트들을 즉 원소를 다루는 모든 기능들 오퍼레이터와 메소드들에 대해서 살펴보았고 마지막으로 동결 세트에 대해서도 그 개념과 사용하는 과정에 대해서 살펴보았습니다.
