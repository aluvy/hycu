10. 짧고 명확하게 코딩하기

-------------------------------------------------------------
10_02. 함수와 정식으로 인사하기
-------------------------------------------------------------

[2페이지]

이번 차시에는 코딩을 짧고 명확하게 하는 목적을 달성하는 방법에 대해서 알아보도록 하겠습니다.
구체적으로 말씀드리면 함수를 이용하는 것입니다.
파이썬이 제시하는 19가지 선에 보면 이 코딩을 짧고 명확하게 한다는 것이 굉장히 중요하지요.
그만큼 중요하기 때문에 함수에 대해서도 굉장히 많은 노력을 들여서 정의를 해놓고 있습니다.
첫 번째 시간을 시작하겠습니다.
첫 번째 시간의 주제는 함수와 정식으로 인사하는 시간이 되겠습니다.

그동안 몇 번 언뜻언뜻 함수와 만난 적이 있지요.
그렇지만 함수와 정식으로 인사하는 시간은 이번이 처음이 될 것이기 때문에 한번 잘 만나보시기 바랍니다.
함수의 목적과 정의를 한 번 더 정리를 해보겠습니다.
첫 번째는 프로그램 개발 속도를 향상시키는 데 목적이 있습니다.
함수로 대규모 프로그램 코딩 속도 증대가 가능한데, 어떻게 하면 가능할지 여러분이 코딩을 통해서 경험을 해보시면 직접 아시게 될 것입니다.
그리고 프로그램 관리 효율을 증대하는 데에도 중요한 목적이 있습니다.

프로그램의 기능을 수정과 보완하는 노력을 줄일 수 있고, 그만큼 효율을 증대시킬 수 있는 것입니다.
이런 함수는 어떻게 정의를 할 수 있을까?
함수란 반복적으로 사용해야 하는 코드의 블록을 함수로 정의해 두고 프로그램에서 필요한 장소와 때마다 함수를 호출하여서 사용할 수 있도록 하는 것입니다.
함수의 작용을 알아보겠습니다.

함수를 잘 이해하고, 함수가 어떤 행동을 하는지 그리고 함수와 서로 상호작용을 하기 위해서는 이 함수의 내부적인 작용을 조금은 우리가 이해를 할 필요가 있습니다.
함수 호출의 프로그램 제어 흐름 변경 과정을 보면 위에는 메인 프로그램이 있습니다.
그 메인 프로그램이 쭉 구문을 수행하다가 함수 호출 구문과 만납니다.
함수 호출 구문은 별것 아닙니다.
함수 이름에 괄호만 쳐주면 함수 호출이 되는 것입니다.

그 괄호 속에는 parameter에 지정되어 있는 인수를 집어넣어주면 되는 것이지요.
그러면 그 순간에 메인 프로그램에서 흐르던 프로그램의 제어 흐름이 함수 쪽으로 건너오게 됩니다.
그 함수 안에서 구문들이 쭉 수행이 되다가 return 구문을 만나든지 그렇지 않으면 함수의 끝까지 다다르게 되면 다시 그 호출된 바로 다음 구문으로 되돌아가게 됩니다.
이것이 기본적인 함수 호출과 return에서 발생하는 제어 흐름 변경이라고 할 수 있는 것입니다.

이 함수에는 여러 가지 종류가 있는데 간단하게 정리해서 전역 함수와 지역 함수로 나누어볼 수 있습니다.
전역 함수 global function인데, 여러분이 파이썬 프로그램을 작성하시면 하나의 파일이 형성이 됩니다.
이것을 프로그램 파일이라고도 하고 또는 모듈 파일이라고도 이야기합니다.
그 파일의 확장자는 .py가 됩니다.

파이썬의 첫 두 글자를 따서 지정을 해주는 것이지요.
이것은 바로 파이썬 프로그램이 들어있는 텍스트 파일이라고 알려주는 정보를 확장자가 이야기를 하는 것입니다.
이런 파일 안에서 처음에 나타나는 것들이 바로 global function에 대한 정의들입니다.
global function에 대한 정의가 쭉 몇 개가 나타나고, 그다음에 그 global function을 사용하는 main-function이 하나가 마지막쯤에 나타나게 됩니다.

그것을 main-function이라고 이야기하지요.
이 main-function 안에는 또 다른 함수들이 정의가 될 수 있는데, 이런 것들을 local function이라고 이야기합니다.
정리해서 말씀드리면 전역 함수라는 것은 그 함수가 정의된 모듈 파일 안에 있는 모든 코드뿐만 아니라 다른 모듈 안에 있는 코드도 함수를 호출하거나 액세스할 수 있는 함수를 뜻합니다.
지역 함수라는 것은 다른 함수 안에서 정의된 함수 또는 지역 함수를 정의한 함수의 코드만 자신의 지역 함수를 호출하거나 액세스를 할 수 있는 함수를 뜻합니다.

이렇게 정의를 했는데, 말로서 정의를 하는 것보다는 그림이 조금은 더 여러분에게 이해하시기 편할 것이고 또 그림보다는 나중에 실제로 코딩을 하신다면 더 이해하시기가 편할 것입니다.
함수의 종류 중에는 또 무명 함수 anonymous function이 있습니다.
이름이 지정되지 않은 함수로서 parameter 규격, 스위트 코드, 리턴 규격이 일반 함수와 동일하게 정의할 수 있는데 다만 이름이 없는 함수를 뜻합니다.

주로 래퍼를 제작한다든지 다른 함수에 대한 인수로서 넘겨지기 위한 용도로서 이 함수를 사용하는 것입니다.
파이썬은 이런 anonymous function을 lamda 함수라고 이름을 붙여서 사용하고 있습니다.
그 이름의 기원은 1930년대에 시작된 수학의 한 분야로서 lamda 계산법이 있습니다.
그 lamda 계산법이 이 무명 함수와 비슷한 역할을 하고, 그 비슷한 행동 양식을 보이기 때문에 거기에서 이름을 따서 lamda 함수라고 이름을 붙이는 것입니다.

그리고 이 무명 함수에 대해서는 조금 이따가 조금 더 자세하게 그 구조에 대해서 또 말씀을 드리겠습니다.
함수의 종류에는 또 메소드가 있습니다.
이 메소드에는 객체 클래스의 내부에서 정의해서 제공하는 함수를 뜻합니다.
클래스 내부의 속성과 다른 메소드를 다룰 목적으로 액세스할 목적으로 사용하는 것이 이 메소드가 되는 것입니다.
그 구조를 보시면 프로그램 파일 속에 class-statement로서 클래스가 정의됩니다.

클래스는 아마 다음 차시에 여러분과 또 알아볼 예정인데요.
이 class-statement 속에는 적절한 인덴트가 있고, 그 속에 attribute와 메소드가 있습니다.
인덴트를 가진 상태에서 이게 class-statement의 한 몸체 또는 블록을 이룬다는 뜻으로 인덴트를 가진 상태에서 attribute와 메소드가 나오는데, 이 메소드는 같은 클래스 속에 있는 attribute 또는 같은 클래스 속에 있는 다른 메소드들을 액세스해서 이용하는 용도로서 생겨난 함수가 되는 것입니다.

이런 클래스들이 여러 개가 모여서 이 파일 안에 정의가 되어 있고, 그 마지막에는 아까와 마찬가지로 main-function이 들어있는 것입니다.
이 클래스들뿐만 아니고, main-function 위에는 global function이 또 정의가 되어 있는데 여기에는 주제에서 조금 벗어났기 때문에 표현이 안 됐을 뿐이지 클래스와 이 global function은 같은 레벨로서 이 program.py라는 파일 안에 정의가 되는 것입니다.

또는 조금 이따가는 프로그램 대신에 모듈이라는 이름도 쓰는데, 프로그램이라는 것은 특정 응용에 맞게 작성된 프로그램의 파일이라는 뜻을 가지고 있고, 모듈은 다른 프로그램에서 이용하기 위해서 작성된 프로그램 코드 파일이라는 것을 뜻하는데 형태는 거의 비슷합니다.
그렇지만 이 메인 함수가 있고, 없고의 차이에 따라서 메인 함수가 있다면 대부분 프로그램 파일이 되는 것이고, 없으면 모듈 파일이 되는 것입니다.

이번에는 함수를 정의하는 과정에 대해서 알아보겠습니다.
함수를 정의하는 문법을 박스에 표현해놓고 있습니다.
function-definition이라고 하는 전체적인 함수 정의 구문은 def라는 키워드로 시작해서 func-name이 주어지고 괄호 열고 parameters를 옵션으로서 제공할 수 있고 또 괄호를 닫고 콜론으로 한 그 줄을 끝맺음을 한다.
여기까지가 definition-statement가 됩니다.

그리고 그 function-definition statement 밑에는 func-suite가 있습니다.
func-suite는 펑션의 실제 기능을 수행하고 담당하는 코드의 부분을 뜻하지요.
블록이라고도 이야기할 수 있습니다.
펑션 블록이라고 이야기할 수 있는데, 대개의 경우는 func-suite라는 용어를 더 자주 사용합니다.
parameters에 대해서 조금 더 자세하게 문법을 분석해보겠습니다.
이 parameters는 하나의 parameter로 구성될 수도 있고, 여러 parameter들이 콤마를 세퍼레이터로 해서 나열이 될 수도 있다는 것을 그다음 줄이 보여주고 있습니다.

그러면 하나의 parameter는 무엇으로 정의를 할 수 있는가?
identifier로 정의를 하거나 또는 identifier=default value로서 정의를 하거나 또는 unpacking-operator를 앞에 주고, 그다음에 identifier를 주는 형태로 이 하나의 parameter를 정의할 수 있다고 규정을 할 수 있습니다.
이런 것들이 함수를 정의하는 문법에 하나하나 탑다운 형태로 정의를 해 들어가면 방식을 여러분에게 보여드린 것입니다.

그리고 unpacking-operator는 하나의 스타 표시로서 표현되거나 또는 2개의 연속된 스타로, 더블 스타로 표현된다는 것.
이것이 스타나 더블 스타는 리터럴이라고 하지요.
또는 터미널이라고 이야기합니다.
그 바로 옆에 있는 unpacking-operator 또는 이 꺾은 괄호로 표현되어 있는 것은 None-terminal 터미널이 아닌 일종의 언어에서는 문법 표현에도 이런 BNF 자체를 언어라고 표현할 수 있는데, 그 언어에서는 변수가 되는 것이지요.

그 변수들은 바로 터미널로 대체될 수 있는 것들인데 최종적으로 이 unpacking-operator는 터미널로서 스타 또는 더블 스타를 가지고 있을 수 있다는 것입니다.
그 외에 identifier라든지 default value라든지 이런 것들은 지금 제가 의미만 말로 설명을 드리고, 이것도 조금 더 정확하게 하려면 알파벳으로 구성된다든지 또는 digit로 구성된다든지 조금 더 터미널로 내려가는 수순을 밟아야 되는데 거기까지는 표현을 안 하고 있을 뿐입니다.

중간 단계에서 끊었을 뿐이지요.
이미 전에도 여러분에게 설명을 또 드린 부분도 많이 있기 때문에 혹시 더 필요하신 부분이 있으면 그 부분을 복습해보시면 좋을 것입니다.
return statement는 appropriate-indentation을 먼저 준 다음에 return이라는 terminal string을 주든지 또는 return value를 주는 것으로 구문을 형성하게 됩니다.
여기에서 appropriate-indentation이라고 표현을 한 이유는 return이 오는 자리는 이 func-suite에서 어디든지 올 수 있습니다.

다만 블록의 구조에 맞춰서 if문이면 한 번 더 indentation을 해야 되지요.
if 속에 또 if 또는 if 속에 또 for 루프문이 있으면 indentation을 2번, 3번을 해야 되는 경우도 생기지요.
그런 경우를 모두 고려해서 막연하게 또는 적절하게 표현하는 것이 appropriate-indentation이라고 표현을 한 것뿐입니다.
이런 정의 문법을 가지고 여러분은 함수 정의를 하게 되시는데 이런 정의 문법만 가지고는 굉장히 추상적인 내용으로 표현이 됐기 때문에 이해하기가 어려우실 수도 있습니다.

오히려 전에부터 잘 써오던 것까지 헷갈리실 위험이 있는데 그러나 실제 코딩하는 부분과 잘 결합해서 왔다 갔다 하면서 이 부분은 바로 여기에 이런 parameters에 해당하는 부분이다.
또 이런 부분은 parameter에 해당하는 부분이라고 비교를 하면서 여러분이 보시면 훨씬 더 이런 문법을 다루지 않고, 바로 코딩을 하시는 것보다는 훨씬 더 빠르게 이 코드 자체를 이해하게 될 것입니다.

이런 함수 정의 문법에 대해서 박스에서 주로 설명을 드렸는데, 이 부분을 그림으로 표현을 해서 조금 더 여러분이 이해하기 쉬운 형태로 다시 한번 설명을 드리겠습니다.
옆에 그림을 보시면 def-statement가 있습니다.
앞 페이지에서 이미 말씀드렸지요.
그리고 indents를 적절하게 주면서 func-suite가 구성이 됩니다.
그 내부에 있는 박스 자체 전체가 func-suite지요.
 그 안에는 어딘가에 return-statement가 있을 수 있습니다.
없을 수도 있겠고요.
만일 없다면 그 func-suite가 쭉 수행이 돼서 맨 마지막에 끝을 내야지 펑션에서 리턴이 되는 것입니다.
또 return-statement가 있다면 그 조건이 맞게 이 return-statement를 만나게 될 텐데, 그때 바로 리턴을 하게 되는 것이지요.
이것을 다시 텍스트로 왼쪽에 있는 부분으로 정리해서 설명을 드리면 func-suite에 속한 모든 부분은 def구문보다 한 수준 이상 더 깊은 indentation을 한다.

그리고 func-suite의 어디에라도 return 구문을 들 수 있고, return 구문이 수행되면 즉시 func-suite로부터 함수 호출자로 실행 제어 흐름이 되돌아간다.
unpacking-operator나 return-statement는 뒤에 또 말씀을 드리겠습니다.
이제 함수를 정의해놓고, 나중에 이 함수를 사용해야 될 때 호출을 한다고 했지요.
이 함수를 호출하는 구문의 문법을 살펴보겠습니다.

function-call-statement라고 하는 것은 lhs-identifier를 이퀄 기호와 함께 둘 수 있다.
옵션입니다.
다만 필수적으로는 function-name을 줘야 하고, 이 function-name은 정의했을 때 function-name과 동일한 것입니다.
괄호 열고 arguments를 둘 수 있다.
바로 정의할 때는 parameter가 들어가는 자리에 이 arguments가 들어가게 되는 것입니다.
역시 옵션으로 주어져 있습니다.

이 arguments도 parameter와 비슷한 구조로 정의가 되고 있습니다.
arguments는 단일 argument 또는 여러 개의 argument들이 콤마로 구별이 되면서 쭉 나열된 형태로 줄 수 있는 것 또는 keyword-argument도 줄 수 있고, unpacked-item-list로서 이 argument를 줄 수 있다는 것입니다.
이 argument와 앞 페이지에서 다루었던 parameter와 비교를 해보시면 어느 정도 짝이 매칭이 됨을 여러분이 아실 수 있게 될 것입니다.

그래서 이 단일 parameter들과 대응이 되는 것들은 positional-argument라고 이야기합니다.
또 그것과는 조금 다른 개념으로서 keyword 어떤 자리라도 상관없이 둘 수 있는 것이 keyword-argument 그렇지 않으면 그 개수가 제한되지 않고, parameter의 수와는 관계없이 argument의 수를 조절할 수 있는 것이 바로 이 unpacked-item-list가 되는데 이러한 내용들도 뒤에 가서 코딩 실습을 하는 과정에서 더 자세하게 여러분과 다루어보도록 하겠습니다.
밑에 있는 설명문을 보시면 lhs-identifier는 함수의 리턴 객체의 참조를 배정 받는 용도가 됩니다.

만일 함수에서 리턴 되는 것이 중요하지 않을 때는 lhs-identifier를 두지 않아도 된다는 것입니다.
또 arguments는 함수 정의 시 지정된 parameters에 대응한다고 말씀드렸고요.
keyword-argument나 unpacked-item-list는 뒤에 코딩과 함께 설명을 또 드릴 것입니다.
이제 함수를 정의하는 예를 간단한 코딩 예로서 보겠습니다.

이 부분에 대해서 코딩 실습을 하는 부분은 아니고, 너무 간단하기 때문에 여러분이 실제로 코딩을 해보시면 또 확인을 해보시면 좋을 것 같습니다.
def hello 괄호 열고 닫고 콜론.
여기까지가 def statement입니다.
definition statement이고, indentation 주고 print 그다음에 괄호 열고 hello를 했지요.
이 print라는 자체도 파이썬이 기본적으로 제공하는 built-in 또는 내장 함수인데 이 print를 호출한 것이지요.

그렇지만 여기에서 우리가 직접 작성한 함수는 아니기 때문에 이것은 생략하겠습니다.
그리고 그 print의 argument로서 hello라는 string을 주었습니다.
여기까지가 hello라는 함수의 정의 부분이 됩니다.
그다음에 한 칸 띄든 안 띄든 상관은 없습니다.
다만 중요한 것은 indentation을 다시 원상복구 해서 왼쪽으로 옮겨서 hello가 global 영역에 있도록 한 다음에 그 hello를 써주고, 이 괄호의 쌍을 열고 닫고 해주면 바로 이 부분을 지날 때 파이썬 인터프리터는 함수를 호출하게 되는 것입니다.

호출을 하면 바로 print문으로 들어와서 hello라는 string이 바깥으로 출력이 되는 것입니다.
이런 함수 정의와 호출한 예를 간단하게 여러분이 보셨습니다.
지금까지 함수를 정의하고 호출하는 과정에 대해서 문법까지 동원을 해가면서 구문의 그 문법까지 동원을 해가면서 자세하게 뜯어봤습니다.
족보를 보는 것이지요.
이력서도 보고 해서 이 대상이 어떤 특징을 갖고 있고, 어떤 능력을 갖고 있는지 또 어떤 요구사항을 갖고 있는지 자세하게 파악을 한 과정을 거친 것입니다.

그다음에 함수 설명문 작성하는 부분이 있습니다.
작성 형식은 함수 설명문이라는 것은 무엇이지요?
내가 작성한 함수라 하더라도 내가 정의해서 작성해놓은 함수라 하더라도 나중에 내가 쓰려고 하면 '이게 도대체 내가 왜 이런 함수를 만들었지?', '어떻게 사용하는 거지?'라는 의문이 들 수 있습니다.
그런데 내가 아닌 다른 사람이 내가 만든 함수를 사용한다면 더 많은 정보를 요구하겠지요.

이 함수가 어떤 행동을 할 것이고, 어떤 정보를 요구하고 또 어떤 정보를 내놓을 것인지 그 모든 것을 설명해주는 것이 함수 설명문이 되는 것입니다.
이런 설명문을 작성하는 형식은 관례적으로 함수 정의 구문에서 def-구문의 바로 아래에 작성이 됩니다.
3중 따옴표로 설명문의 시작과 끝을 표시하고, 설명문의 시작은 func-suite와 동일한 수준으로 들여쓰기를 해야 합니다.

또 설명문을 여러 줄로 작성할 수 있고, 들여쓰기 규칙을 적용할 필요가 없습니다.
이런 경우는 바로 코멘트 부분에서 이미 다룬 적이 있습니다.
그래서 자세하게 설명을 드리지는 않았고요.
다만 이 함수 설명문이라고 하는 것은 이른바 docstring이라고 이야기합니다.
document의 첫 글자, 세 글자 doc를 합쳐서 docstring이라고 이야기하는데 string은 string입니다.

삼중 따옴표로 시작이 되고, 끝이 되고 그 안에는 쭉 무엇인가 string이 들어있는데 그 string이 바로 하나의 document를 뜻한다고 해서 docstring이라고 하고, 그 document는 무슨 용도의 document인가?
함수의 모든 것을 설명해주는 document가 된다는 것입니다.
그런 설명문을 작성한 예입니다.
hello() 함수를 definition을 만들었습니다.
그리고 그 밑에 바로 indentation, func-suite와 같은 레벨의 indentation을 가지면서 docstring이 시작하고 있습니다.

A docstring describing the function이라고 하는 자기 스스로를 소개하는 문장이 들어있는데 원래는 hello라는 것은 이러이러한 기능을 하는 함수라는 설명이 들어있어야 조금 더 적당한 내용이 되겠지요.
그렇지만 지금은 docstring이 여기에 있다는 것을 강조하기 위해서 이 docstring이라는 것을 주어로 해서 만든 문장을 넣었습니다.
그다음에 print가 들어오고, 그다음에 pass가 나왔습니다.

여기까지가 hello() 함수에 대한 정의 부분이 됩니다.
그러면 마지막에 pass라는 것은 무엇일까?
이것은 하나의 no operation이나 마찬가지입니다.
처음에는 이름만 hello라고 정해놓았지 이 hello가 어떤 행동을 할지 구체적으로 코딩을 하지 않은 단계에서 이 hello라는 함수만 definition 구문을 만들어놓을 필요가 있을 수 있습니다.

이럴 때는 print hello라든지 docstring도 필요 없이 그냥 pass만 바로 그 밑에 집어넣으면 하나의 완전한 함수의 정의가 되는 것입니다.
실제로 함수를 정의할 때 def hello 괄호 열고 닫고 콜론만 넣어서 엔터를 치고 또 엔터를 치면 나중에 에러가 나게 됩니다.

몸체가 없는 껍데기만 있는 유령과 같은 존재라고 해서 이 인터프리터는 오류를 발생시키게 되는데, 그 안에 뭐라도 하나 pass가 들어있게 되면 no operation이기는 하지만 그래도 하나의 몸통과 머리를 갖춘 완전한 함수 형체가 됐구나, 해서 오류로 취급하지 않고 그대로 넘어가게 되는 그런 것을 노려서 pass라는 키워드를 자주 사용하게 됩니다.

이제 hello를 호출했습니다.
또는 help(hello)를 해보면 여러분이 이 함수가 정의된 효과를 금방 확인하실 수 있는데요.
hello를 호출하면 바로 그 안에 있는 print문이 동작을 해서 hello라는 string을 print를 합니다.
그다음에 help(hello)를 하면 이 hello 함수에 대한 정보를 알려주게 되는데, Help on function hello in module_main.
이 main이라는 것은 main function을 뜻합니다.

메인 함수 안에서 불려진 def hello인데 그러나 이 def hello는 글로벌 함수지요.
메인과 동일한 하나의 레벨을 가진 함수가 됩니다.
이런 함수에 대해서 설명을 하겠다.
무엇이라고?
A docstring describing the function 조금 hello하고는 동떨어진 이야기라고 아까 말씀드렸지요.
그런 것이지만 그래도 이 docstring 포지션에 적혀있는 대로 이 help 함수가 hello에 대한 정보를 읽어내서 여러분에게 표시를 해드린 것입니다.

그다음에는 함수의 작명 원칙에 대해서 말씀드리겠습니다.
그 원칙의 목적은 프로그램을 이해하기 쉽게 함으로써 프로그램의 버그를 줄이고, 개발 기간을 단축하고, 유지보수와 관리비용을 줄이는 데 있습니다.
모듈, 클래스, 메소드, 함수, 파라미터 그리고 객체참조의 이름을 작명 원칙의 대상으로 합니다.
특히 지금은 함수를 다루고 있는 과정이니까 이 함수의 이름에 대해서 염두에 두시면서 이 원칙을 한번 같이 살펴보면 좋겠습니다.

원칙 중에 하나는 일관성입니다.
한 번 정한 작명 원칙을 프로그램 전체에 일관적으로 적용하는 것이 중요합니다.
그리고 설명성입니다.
대상을 잘 이해할 수 있게 설명하도록 충분히 긴 이름을 불이는 것이 중요하고, 약자는 널리 알려진 것만 조심스럽게 사용하고 임의로 약자를 만들어서 이름에 붙이지 않도록 하는 것이 좋습니다.
만일 약자를 임의로 만든 경우에는 반드시 설명 문서의 그 약자가 무엇을 뜻하는지를 설명해두어야 할 필요가 있습니다.

그리고 함수의 용도나 기능 그리고 경우에 따라서는 리턴 값의 데이터 유형을 이름에 표현하는 것도 좋습니다.
그러나 함수 구현에 사용한 알고리즘을 이름에 너무 자세하게 필요 이상으로 표현하는 것은 좋지 않습니다.
너무 길어지게 된다든지 또는 알고리즘을 바꾸게 되면 그 이름 자체가 의미를 잃어버리기 때문에 그런 이름을 붙이지 않는 것이 좋다는 것입니다.

그다음에 가독성은 대소문자와 언더바를 사용해서 이름을 구성하는 단어를 각각 구별할 수 있고 또 읽기에 좋도록 만들 필요가 있습니다.
그다음에 이런 작명 원칙의 예로서는 여러 가지 원칙들이 있는데 UPPERCASE 원칙이 있고 또는 TitleCase 원칙이 있고, camelCase 원칙이 있고 또 lowercase_with_underbar 원칙이 있습니다.
대부분의 경우 상수는 UPPERCASE 원칙을 붙입니다.

모든 것들을 전부 UPPERCASE 대문자로 붙여주는 것입니다.
클래스와 예외 이름 등은 TitleCase 한 단어 단어를 다 붙여 쓰기는 하는데 실제 단어가 시작되는 부분은 대문자로 써주고, 단어의 나머지 부분은 소문자가 되도록 하는 것입니다.
Title과 Case는 별개의 단어지요.
이것이 붙어 있다 하더라도 Title의 T와 Case의 C는 대문자로 써주는 것을 TitleCase라고 이야기를 합니다.

camelCase라는 것은 그림에 보시듯이 camel의 등이 지금 단봉낙타를 표현하고 있습니다.
쌍봉낙타가 아니고.
단봉낙타는 camel 머릿 부분에 해당하는 것은 소문자로 시작합니다.
그러나 몸통에 해당하는 것은 TitleCase를 따릅니다.

그래서 대부분의 경우 이 함수의 이름을 정할 때, 이럴 때는 무엇무엇을 하라 할 때, 그 동사에 해당하는 부분은 소문자로 맨 앞에 붙여주고 do 무엇, do Something, do Something 할 때는 do, d-o는 d를 소문자로 써주고 Something 할 때 S는 대문자로 써주는 이런 형태로서 붙여주는 것이 camelCase 이름이 되는 것입니다.

변수와 파라미터 이름은 대부분 lowercase_ 형태로 표기를 해주면 이것이 대부분의 경우 파이썬 프로그램 코드에 적용되는 작명 원칙이 되는 것입니다.
작명의 예는 find라는 함수를 정의하는데 소문자로 다 정의를 했습니다.
그다음에는 소문자 언더 바로 정의를 했고, 그다음에는 camelCase로서 정의를 했습니다.
getFirstIndex 이것은 TitleCase처럼 보이지만 그 앞에 있는 동사에 해당하는 부분 또는 형용사에 해당하는 부분이 소문자로 시작을 했기 때문에 이것은 camelCase라고 이야기를 합니다.
이런 부분들.

그다음에 옆에는 pass들이 다 붙어 있지요.
함수는 syntax error가 나지 않도록 define을 해놓았는데 syntax error가 나지 않으려면 속에 채울 것은 아직 당장 생각은 나지 않고 했을 때는 나중에 채울 것을 예상하고, 그냥 pass라고 하는 no operation 키워드로서 채워주면 그것으로 이 인터프리터는 넘어간다는 뜻입니다.
지금까지는 일반적인 함수에 대해서 말씀드렸습니다.

그리고 함수의 종류에 대해서 처음에 말씀드렸을 때 글로벌 함수, 로컬 함수, 익명 함수 또 메소드 이렇게 4가지 종류를 말씀드렸고, 익명 함수에 대해서는 조금 더 나중에 자세하게 말씀드린다고 했지요.
이제 그 익명 함수에 대해서 잠깐 더 자세하게 말씀드리겠습니다.
파이썬에서는 이 익명 함수를 람다 함수라고 한다고 말씀드렸습니다.
이 람다 함수를 정의하는 문법은 어떻게 되는지 박스 안을 같이 한번 보시면 좋겠습니다.

function name이 lhs 즉 left hand side로서 주어졌습니다.
펑션 네임은 일종의 펑션 객체에 대한 참조 이름이 되는 것이지요.
identifier가 됩니다.
그런데 대괄호로 둘러싸여 있기 때문에 이 부분이 옵션입니다, 사실은.
그래서 줘도 되고, 안 줘도 되는데 대부분의 경우 람다 함수를 정의하면서 문자적으로 그대로 이 프로그램 코드 속에서 이용할 때는 이 펑션 네임 파트를 쓰지는 않습니다.

그렇지만 대부분의 경우 이 펑션 네임으로 람다가 정의한 함수 객체의 참조를 받아서 사용하는 경우가 대부분이기 때문에 또 대부분의 경우 이 펑션 네임을 사용한다고 할 수 있습니다.
본론으로 들어가서 람다라는 키워드를 주고, 그 옆에는 바로 파라미터를 optional하게 주고 있습니다.
필수적으로 콜론이 나오고 그다음에 또 필수적으로 expression이 나옵니다.

그러면 여기에서 중요한 것은 parameters가 중요한데, 조금 더 이 문법을 자세하게 풀어보겠습니다.
parameters는 파라미터 단일 한 개만 나오든지 그렇지 않으면 여러 개의 파라미터가 콜론으로 구별이 되면서 나열이 될 수 있다는 것을 표현하고 있습니다.
하나의 파라미터는 identifier 하나로서 표현이 되거나 그렇지 않으면 identifier=default-value로서 표현이 된다고 할 수 있습니다.

이 부분만 보면 일반 함수에서 파라미터를 정의하는 그 구문 문법과 같다고 볼 수 있습니다.
다르지 않습니다.
같다고 생각을 하셔도 좋은 것입니다.
그래서 이 람다 키워드는 이름 없는 함수 참조를 생성합니다.
그리고 만일 이 함수 참조를 function name에 배정한다면 function name이 바로 그 함수의 이름이 되는 것입니다.

function name 괄호 열고 argument의 구문으로서 일반 함수와 똑같이 함수를 호출할 수 있게 되는데 그렇게 되면 지금까지 우리가 다루었던 일반 함수와 이 람다 함수는 무엇이 다른 것이지?
라고 여러분이 의심스럽게 생각하실 수도 있을 거예요.
람다 함수를 왜 사용하는가?
이런 익명 함수를 왜 사용하는가?
그 부분에 대해서는 나중에 코딩하는 과정에서 여러분과 함께 조금 더 자세하게 살펴보도록 하겠습니다.

그리고 파라미터라는 것은 def 구문으로서 함수를 정의하는 경우가 동일하다고 조금 전에 말씀드렸고, expression은 분기 또는 루프 구문을 가질 수 없습니다.
즉 for 루프라든지 while 루프라든지 이런 것들이 이 expression에 들어올 수는 없습니다.
그다음에 분기 자체는 if else도 분기에 속하기는 하는데 이 expression에서 if else는 들어올 수 있습니다.
if else는 들어올 수 있는데 if, else if, else if, else 이런 형태로는 사용하지 못한다는 제약점이 있습니다.

이런 몇 가지 제약점이 있기 때문에 파이썬은 다른 언어에 비해서는 이 람다 함수 자체로만 보면 익명 함수로서는 제한성이 많아서 많이 사용되지는 않는 약간의 제한점이 있습니다.
그렇지만 이 람다 함수를 잘 활용하면 앞에서 말씀드렸듯이 여러분의 코드를 조금 더 짧고 명확하게 작성하실 수 있는 좋은 수단이 될 것입니다.

이렇게 이번 첫 번째 교시에는 함수의 모든 구석구석을 자세하게 들여다보면서 이 함수가 어떻게 생겼는지 살펴보았습니다.
그러면 다음 시간에는 이 함수와 어떻게 사이좋게 놀 수 있는지 그 방법에 대해서 코딩을 통해서 하나하나 확인을 해보고 실습을 해보도록 하겠습니다.
