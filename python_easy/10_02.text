-------------------------------------------------------------
10_03. 함수와 함께 춤을
-------------------------------------------------------------

[3페이지]

이번 시간에는 조금 전에 살펴보았던 함수들을 어떻게 상대하고, 어떻게 다룰지 코딩을 통해서 확인해보도록 하겠습니다.
아나콘다로부터 주피터를 런칭을 시키겠습니다.


**********************************실습영상***********************************
PythonProgramming 디렉터리로 들어갑니다.
여기에 이번 차시에 다룰 내용들을 디렉터리를 생성해보겠습니다.
New에서 Folder를 넣고 다시 이 Folder에 대해서 Rename을 하겠습니다.
파워포인트 프로그래밍 제 10차시 코딩 짧게 하기.


코딩을 짧게 한다는 뜻은 함수를 사용하면 우리가 코드를 짧게 할 수 있다는 뜻으로 지은 이름입니다.
이제 노트북을 펼치겠습니다.
New에서 다시 Python3 형태의 노트북을 펼치겠습니다.
이름이 지워지지 않았지만 나중에 정하든지 지금 정하고 들어갈 수도 있겠습니다.
지금 정한다면 File, Rename하면 역시 이 노트 이름도 ShorteningCoding이라고 이름을 붙이겠습니다.
이제 첫 번째 코딩을 하기 전에 지난 바로 전 타임에 다루었던 내용을 조금 정리를 해보겠습니다.

*************************************끝**************************************

첫 번째 함수와 함께 노는 과정에서 중요한 것이 parameter를 통해서 정보를 함수에 제공해주는 것입니다.
이 parameter와 argument라고 하는 용어를 우리가 흔히 사용하는데요.
parameter와 argument는 분명히 뜻이 다릅니다.
파라미터는 함수를 정의할 때 함께 정의가 되는 데이터 항목들입니다.
그 형태를 보면 구문의 형식을 보면 def라는 키워드가 나오고 func-identifier 그다음에 괄호가 열리고 parameters가 들어가게 됩니다.

바로 이 parameters가 우리가 이야기하는 파라미터에 해당하는 부분이 되지요.
그런데 옵션으로서 파라미터가 주어질 수도 있고, 주어지지 않을 수도 있습니다.
이 함수에 정보를 제공하는 방법은 여러 가지가 됩니다.
지금은 대표적으로 파라미터를 통해서 정보를 제공한다고 했는데, 전역 변수를 통해서 정보를 제공할 수도 있습니다.
그럴 경우에는 굳이 파라미터를 사용하지 않아도 되기 때문에 옵션으로서 이 파라미터를 표현해놓은 것입니다.

그리고 괄호를 닫고 콜론으로서 이 def statement를 완성하게 됩니다.
그 아래에는 func-suite가 따라오게 되는 것이지요.
argument라는 것은 함수를 호출할 때 호출자가 함수에 제공하는 데이터 값들을 이야기합니다.
그래서 파라미터는 모두 이 데이터 객체에 대한 identifier가 주어지게 되는데 argument들은 identifier 또는 value가 주어지게 되는 것입니다.

함수 호출자는 파라미터와 매칭이 되는 형태로 이 argument를 주어야 합니다.
그런 규칙이 잘 이루어지지 않으면 잘못된 정보가 전달이 된다든지 또 syntax 오류가 발생하게 되는 것이지요.
이런 규칙들에 대해서 코딩을 통해서 구체적으로 확인을 해보겠습니다.
또 파라미터의 지역성을 우리는 고려를 할 필요가 있습니다.

즉 파라미터의 이름 공간이 그 함수 자체의 func-suite 안에만 한정이 된다는 것입니다.
함수 호출자가 가진 객체 identifier의 이름과 함수 내부에서 파라미터로서 사용하는 이 identifier의 이름이 같아도 문제는 없습니다.
우선적으로 이 파라미터 이름이 함수 내부에서는 사용이 되고, 그 호출자가 가진 이른바 다시 말씀드리면 이 함수의 입장에서 보면 전역 변수가 되는 것이지요.

이 전역 변수는 건드려지지 않는 상태가 되기 때문에 변경이 되지 않기 때문에 서로 충돌될 위험이 없는 것입니다.
이렇게 이 함수의 파라미터의 이름이 제한된 이름 공간을 갖게 되는 것으로 인해서 이 함수는 그 외부에 대해서 독립적으로 행동을 할 수 있게 되는 것입니다.
그리고 또 독립적으로 존재할 수 있게 되는 것입니다.


**********************************실습영상***********************************
코딩을 통해서 확인해보겠습니다.
첫 번째 함수를 정의를 했습니다.
def hello라는 함수 이름을 가지고 괄호를 열고 x라는 파라미터를 가졌습니다.
이 x 자체 하나의 문자로 되어 있지만 훌륭한 하나의 identifier가 됩니다.
즉 파라미터의 이름이 되는 것이지요.
그 바로 밑에는 docstring 즉 이 함수를 설명하는 문서가 작성이 되어 있습니다.

하나의 string 형태인데 document를 형성하는 string이라고 해서 이름을 document string의 약자로서 docstring이라고 이름을 붙여서 흔히 부르고 있습니다.
나중에 이 hello에 대해서 help를 요구하면 help 함수에 hello를 넣어서 help를 보면 바로 이 A docstring describing the function이라고 하는 이 문장이 나타나게 되는 것이지요.
그 밑에 func-suite로서 print('Hello' + x) 파라미터로 주어진 string이 되어야겠지요.

이 string과 string을 + operator로서 더하려면 이 x 자체가 string이 되어야 합니다.
이 부분은 우리가 함수를 호출할 때, x에 무엇을 넣어야 되는가 하는 점에 대해서 규정을 하게 되는 것이지요.
만일 우리가 x를 integer 값을 주었다.
또는 플로팅 값이라든지 튜플이라든지 스트링과 다른 유형의 데이터를 argument로 준다면 바로 이 부분에서 걸리게 됩니다.

Hello라는 이 string과 x를 서로 + operator로 concatenate 연결을 할 수 없다는 오류 메시지가 나타나게 되는 것입니다.
즉 Type Error가 나타나게 되는 것이지요.
그렇다면 이 함수를 사용하고자 할 때, 그 argument를 string으로 주어야 되는지 어떻게 알아야 되는가, 궁금해지실 것입니다.

바로 그 부분을 위해서 이 docstring에 그런 이야기가 들어가 있어야 되는 것입니다.
그래서 이 부분에서 조금 더 우리가 구체적으로 docstring을 작성한다면 한 칸을 내리든지 이어 붙여서 써서 상관은 없지만 parameter x는 문자열이어야 한다는 말도 포함이 된다면 이 help를 통해서 hello라는 함수를 어떻게 사용하면 되겠구나, 라는 것을 분명하게 알게 되시는 것입니다.

*************************************끝**************************************

C언어 같은 경우 또는 Java 언어 같은 경우에는 이 x의 유형이 이미 결정이 되어 있기 때문에 compiler의 프리 프로세싱 단계에서 이미 Syntax Error를 잡아낼 수 있지만 Python은 그렇지 않습니다.

이 x에 대해서는 다이내믹하게 어떤 유형의 데이터도 들어올 수 있기 때문에 처음 단계에서 그 Syntax type Error를 잡아내지는 못합니다.
않는다.
또는 못한다.
못한다고 하는 게 더 정확한 표현이 되겠지요.
그래서 사용자가 이 함수를 사용할 때는 반드시 이런 docstring을 참조를 해야 되는 것입니다.


**********************************실습영상***********************************
그리고 그 docstring에는 이 파라미터를 어떠한 형태의 파라미터를 주어야 되는지, 어떠한 유형의 파라미터를 argument로서 주어야 되는지 분명하게 설명이 되어 있어야 하는 것입니다.
그리고 x를 Banana라는 string으로서 변경을 했습니다.
여기까지가 함수에 대한 정의 부분입니다.
그다음 이 다음 부분에는 호출자의 원래 프로그램 부분입니다.
x는 Potato라고 집어넣었습니다.
그리고 hello를 호출합니다.

x라는 argument를 주어서 이 hello라는 함수를 호출합니다.
이때 우리가 유심히 볼 부분이 이 hello를 호출할 때 쓰는 argument는 호출자의 바로 전역 변수입니다.
x라는 전역 변수인데, 파라미터의 이름도 또 똑같은 이름 x라는 전역 변수와 똑같은 이름이 파라미터 이름으로 되어 있는 것이지요.
그러면 함수 내부에서 x에 준 Banana라는 이 값이 나중에 이 함수가 호출이 돼서 수행을 다 한 다음에는 그 값으로 변해있지는 않을까, 하는 의심이 들기도 하는 부분이 되는 것이지요.

그런데 이 부분은 바로 조금 전에 말씀드렸듯이 함수 내부에서 파라미터로서 주어진 이름이 이 호출을 한 호출자의 변수의 이름과 같다면 이 파라미터의 이름으로서 우선적으로 결정이 된다는 것입니다.
즉 x라는 것은 바로 파라미터라는 것이 결정이 된다는 것이지요.
그 파라미터를 아무리 바꿔보아야 이 호출을 한 호출자의 변수 x는 변동이 없다는 것입니다.
왜냐하면 서로 별개의 이름은 같지만 전혀 다른 객체이기 때문에 그렇다는 것이지요.

과연 그렇게 되는지 이 코드를 실행시켜봄으로써 확인을 해보겠습니다.
Hello Potato라는 것이 바로 이 print문 함수 내부에 있는 print문에 의해서 나온 것입니다.
그다음에 이 print문을 수행하고 나서 Banana를 x에 집어넣고, 리턴을 했습니다.
리턴을 한 다음에 호출자로 돌아가서 이 호출자의 print문이 수행이 되는 것이지요.
그러면 이 x 안에 Potato가 그대로 유지가 될지 또는 함수 내에서 변경이 된 Banana라는 문자가 들어있을지 그것을 보겠다는 것이었지요.

그런데 Potato가 들어가 있는 것이지요.
함수 내부에서 아무리 바꿔보아야 소용이 없고, 그대로 이 호출자의 변수에 있는 내용이 변경이 되지 않고 유지가 되었다는 것을 여기에서 확인할 수 있는 것입니다.
그다음에 파라미터를 지정해놓았는데 우리가 인수를 줄 때, 호출을 할 때 인수를 주지 않았다면 어떻게 될까?
그 파라미터를 정의했지만 그 파라미터에 대한 인수를 주지 않고 호출을 했을 때는 오류가 발생하게 되어 있습니다.

그 오류에 대해서 어떤 것이 나타나는지 보도록 하겠습니다.
코딩을 보시기 바랍니다.
역시 조금 전 hello라는 함수와 같은 함수를 define을 했습니다.
그런데 호출자가 호출을 할 때, x에 해당하는 argument를 주지 않았지요.
이렇게 파라미터는 정의를 해놓았지만 거기에 매칭이 되는 argument를 주지 않았을 때는 어떻게 될까?
Run을 시켜보겠습니다.
TypeError가 발생하고 있습니다.

바로 hello로 호출하는 부분에서 TypeError가 발생했고 이 함수의 유형은 하나의 argument를 요구하는데 아무 argument도 주지 않았다.
그러므로 이 함수의 요구 타입과 맞지 않기 때문에 TypeError가 발생한 것입니다.
1 required positional argument라고 되어 있습니다.
x로 표현된 이 파라미터와 같은 위치에 argument를 주어야 되는데 주지 않았다는 뜻입니다.

*************************************끝**************************************

이제 전역 객체를 통한 정보 제공에 대해서 보겠습니다.
지금까지 보신 것은 파라미터를 통해서 정보가 전달되는 아주 간단한 예를 보신 것입니다.
그 파라미터를 통하지 않고 전역 변수를 통해서 정보가 전달되는 과정은 어떻게 될까?
보겠습니다.
전역 객체라고 한다면 func-suite에서 글로벌 구문으로서 지정을 해놓은 객체가 되겠습니다.
지정한다.
또는 선언해놓은 객체가 되는 것입니다.

이 글로벌 구문은 func-suite 내부의 실행 제어 흐름과 관계없이 어디에서나 놓일 수 있고, 그 구문 이후에 블록 전체에 효과를 발휘하는 구문이 되겠습니다.
이 글로벌 구문이 if문 안에 들어와 있어도 상관은 없습니다.
if 구문이 실행이 되든 안 되든 즉 if의 컨디션이 만족이 돼서 if 블록이 실행이 되어야지 그 글로벌 변수 선언문이 효과를 발휘하는 것이 아니고, 이런 function의 흐름과는 전혀 관련이 없습니다.

이 안에 어디에 있느냐 하는 것이 중요한 것이고, 그 이후에는 바로 글로벌 변수로서의 효력이 발생하는 것입니다.
구문의 문법은 아래와 같습니다.
def function 정의가 되어 있지요.
그 정의가 되어 있는 중간에 func-suite 중간 중간에 글로벌 구문이 나타날 수 있습니다.
앞에는 적절한 indentation만 지켜주면 됩니다.

그리고 그 글로벌 구문이 어디에 있든지 조금 전에 말씀드렸던 대로 이 글로벌 구문 자체는 실행이 실제로 프로그램 코드가 실행이 될 때 실행된다기보다는 인터프리터에게 정보를 제공하는 역할을 해주는 것입니다.
어떤 이름의 변수가 또는 어떤 이름의 객체 레퍼런스가 이 글로벌 변수로서의 작용을 하는가, 안 하는가 하는 정도만 인터프리터에게 정보를 주는 것이기 때문에 어디에 있든지 그 function 내부에 suite에 control flow에 관계없이 효력을 발생한다는 것입니다.


**********************************실습영상***********************************
이런 내용들은 코딩으로 바로 확인을 해보도록 하겠습니다.
hello라는 함수를 정의를 하는 과정에서 global x 즉 x라는 이름을 가진 객체 레퍼런스를 글로벌 변수로 삼겠다.
글로벌 객체로 삼겠다는 선언을 한 것입니다.
그 이후에는 이제 이 x라는 것은 함수 호출자의 변수 즉 객체라고 보시면 되겠습니다.

그래서 이것은 함수 내부에서 정의가 된 지역 객체가 아니고 전역 객체이기 때문에 여기에 함수에서 배정이 돼서 변경이 된, 그 값이 변경이 된다면 호출자의 변수 즉 객체에 그대로 변경된 사항이 반영이 되는 것입니다.
그 과정을 살펴보겠습니다.
호출자가 potato라고 자기의 객체의 값을 string을 넣었습니다.
그리고 hello를 불렀습니다.

여기 hello에 아무런 argument가 없어도 되는 이유는 hello를 정의할 때, 파라미터를 정의해놓지 않았지요.
여기에 파라미터가 없는데, 여기에 무언가 argument를 넣는다면 이 역시 TypeError를 발생시킬 것입니다.
매치가 되지 않기 때문에 그렇지요.
그 파라미터와 argument가 매치가 되지 않기 때문에 TypeError가 발생하게 됩니다.
그리고 print를 하면 hello를 수행시키면 어떻게 될까요?
hello potato가 나타날 것입니다.

왜냐하면 x에 potato라는 string 객체를 넣어서 줬기 때문에 그렇지요.
그리고 전역 변수이기 때문에 그렇습니다.
그다음에 print문을 수행한 다음에 Banana라는 string을 x에 넣었습니다.
이 자체가 바로 함수 호출자의 객체에 영향이 끼치는 것이지요.
변경이 된 것이지요.
그러니까 after hello에서는 Banana라는 것이 나타나게 되는 것입니다.
Run을 시켜보겠습니다.
hello Potato가 나왔고, x는 Banana로 변경돼서 표현이 됨을 알 수 있습니다.

그 위에 것과 비교를 해보시지요.
여기에서는 x가 변경이 되지 않았지요.
Potato가 그대로 남아 있었지만 이 전역 변수로 준 경우에는 Banana가 들어가 있음을 알 수 있습니다.
이런 과정 때문에 될 수 있으면 전역 변수를 통해서 함수의 정보를 제공하는 것보다는 parameter를 통해서 함수의 정보를 제공하는 것이 훨씬 안전하고 나중에도 오류를 적게 유발시키는 방법이 된다는 것입니다.

왜 그럴까요?
즉 함수 내부에 있는 코드를 우리가 하나하나 다 이해하고 함수를 사용하지는 않지요.
그 사용하는 과정에서 우리가 준 변수가 전역 변수로서 함수 내에서도 사용이 된다면 그 값이 어떻게 변해서 나올지 모르기 때문에 예측을 할 수 없는 것이지요.
그런 문제를 미연에 방지하고 또 거기에서 나타나는 여러 문제를 예방하기 위해서는 parameter를 사용하는 것이 좋은 방법이라는 것입니다.

또 글로벌 구문을 선언하기 전에 전역 객체를 사용한다면 어떤 일이 발생할지 보겠습니다.
아까 말씀드렸을 때는 오류가 발생하겠지요.
그 전역 객체 또는 전역 변수가 선언된 이후부터만 효력을 발생한다고 했으니까 선언하기 전에 객체를 전역 변수로서 사용하고자 한다면 문제가 발생하는 것입니다.
보겠습니다.
코딩한 내용을 보시면 hello 함수를 정의를 했는데, 이 global x라는 구문을 이것의 뒤 마지막에 집어넣었습니다.

그 앞에서 print('hello', x)를 구문을 사용을 하는 것이지요.
바로 이 x를 사용하는데 이 x는 어디에서도 함수 내에서는 정의가 되어 있지 않지요.
의도한 것은 호출자가 가진 x라는 이름을 가진 객체 레퍼런스를 사용하려고 한 것인데, 이 함수 내부에서는 이 x가 무엇인지 알 수 있는 방법이 없습니다.

나중에 가서야 global x라는 구문이 나타나서 '아 그랬구나.' 하고 그 의도는 이해를 할 수 있지만 컴퓨터는 사람이 아니기 때문에 조금 참았다가 나중에 그 뜻을 알아보거나 하지는 않지요.
바로 이 부분에서 나는 모르겠다는 오류를 나타내게 되는 것입니다.
그 과정을 실행을 시킴으로써 살펴보겠습니다.
오류가 발생했습니다.
그 오류는 Syntax Error인데 x라는 이름을 가진 객체가 이 global declaration 앞에서 먼저 성급하게 사용될 뻔 했다는 뜻으로 오류를 발생시킨 것입니다.

파이썬 인터프리터도 전후 사정을 파악해서 조금 알기는 압니다.
그렇지만 너무 봐주다 보면 또 다른 2차, 3차적인 문제가 나타나기 때문에 차라리 이 순서에 대한 문제를 오류로서 취급하고, 제대로 코딩을 하도록 유도를 하는 것이 더 안전한 방법이 되기 때문에 이런 오류를 나타내게 된 것입니다.

*************************************끝**************************************

자, 그다음에는 기본 값을 가진 선택적 파라미터를 정의하는 과정에 대해서 우리가 실습을 해보겠습니다.
함수 호출 시 인수를 선택적으로 제공할 수 있는 파라미터를 사용하는 경우가 있었지요.
그 목적은 파라미터에 대한 인수를 선택적으로 부여할 수 있도록 해서 만일 인수를 부여하지 않는다면 기본적으로 주어진 값이 인수로 작용할 수 있도록 해주는 목적으로 사용을 하는 것입니다.

그렇게 함으로써 파라미터에 매칭이 되는 인수가 누락이 돼도 오류가 발생하지 않도록 하든지 또는 그 호출 당시에 주는 값이 그다지 큰 의미를 갖지 않은 경우에는 이렇게 기본 값을 가진 선택적 파라미터를 정의하는 것입니다.
그 구문의 형태를 보면 parameters는 identifier=value의 형태 default value로서 나타나게 됩니다.
이런 구조로서 쓰여진 것은 기본 값을 가진 선택적 파라미터라고 할 수 있는 것입니다.
코딩을 통해서 확인을 해보겠습니다.
