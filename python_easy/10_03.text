
**********************************실습영상***********************************
코딩을 보시면 hello라는 함수를 정의할 때, user name이라고 하는 parameter를 같이 정의를 하고 있습니다.
다른 점은 앞에서 우리가 보았던 것과 다른 점은 이퀄 기호 다음에 nobody라고 하는 string을 기본 값으로 준다는 것입니다.
그리고 이 함수의 func-suite는 Hello 그다음에 user name이 나오도록 하는 것입니다.

여기까지가 함수이고, 함수에 대한 정의 부분이고 이 hello와 2개의 hello가 호출자가 사용하는 호출 코드가 되겠습니다.
hello('Alan')이라는 argument를 넣어서 호출을 해보았습니다.
그리고 아무런 argument를 주지 않은 상태에서 또 호출을 해봤습니다.
그렇다면 예상하기를 알란 또는 앨런이라고 하는 이 스트링을 주었을 때는 hello('Alan')이 될 것이고, 아무런 argument를 주지 않았을 때는 hello nobody라는 문장으로 이 함수가 print를 할 것이 예상되는 것이지요.
확인을 해보겠습니다.
Run을 했습니다.

Hello Alan 또는 Hello nobody라는 것을 확인을 할 수 있습니다.
이 파라미터를 지금까지는 하나만 우리가 다루어보았지요.
이제 파라미터가 여러 개가 있을 경우에는 어떻게 할까, 보겠습니다.
이미 지난 시간에 여러 개의 파라미터가 주어질 때는 파라미터 이름 콤마 그다음에 또 파라미터 이름 콤마 이런 식으로 파라미터 이름과 이름 사이를 콤마로 구별을 해서 여러 개의 파라미터를 준다고 말씀을 드린 적이 있지요.

그런 형태로 한번 코딩을 해보겠습니다.
이번 코딩에서도 hello 함수를 정의를 하고 있습니다.
첫 번째 파라미터의 이름은 fname입니다.
콤마 lname='unknown' 이건 무슨 뜻인가요?
두 번째 파라미터인데 바로 선택적 파라미터로서 기본 값을 가진 선택적 파라미터로서 정의가 된 것입니다.
세 번째는 datestring으로서 null string을 기본 값으로 가진 선택적 파라미터가 또 주어지고 있습니다.

이렇게 3개의 즉 다수의 파라미터가 주어졌는데, 첫 번째 것은 반드시 argument를 요구하는 파라미터가 되는 것이고, 두 번째와 세 번째는 선택적으로 그 argument를 요구하는 파라미터가 되는 것입니다.
이 함수 내에서 func-suite는 메시지를 구성하고 있습니다.
자기가 기본적으로 가지고 있는 Hello라는 string에 주어진 fname을 우선 플러스를 합니다.
string과 string을 플러스 하려면 역시 fname은 string이 되어야 하지요.

그리고 lname이 unknown이 아닐 때에만 msg에 이 lname을 또 더해놓습니다.
스페이스 하나를 추가하면서 lname을 덧붙여놓는 것이지요.
그리고 호출자가 의도적으로 datestring을 주었을 때, 즉 이 datestring의 길이가 0보다 클 때는 역시 그 datestring을 msg에 덧붙여놓는 과정을 거치게 됩니다.
그리고 최종적으로 이 msg를 print하는 것입니다.
이제 호출자가 호출을 하는 과정을 보겠습니다.
그 정의된 hello 함수를 호출합니다.

Alan이라고 하는 첫 번째 argument 주고, Simpson이라고 하는 두 번째 argument 주고 12월 31일 2019, 2019년 12월 31일을 세 번째 argument로 주었습니다.
또 한 번 hello를 호출을 했는데, 이제는 3개의 argument를 준 것이 아니고, 하나의 argument만 주었습니다.
이 Henry라는 것을 주었는데, 이 Henry가 fname에 해당하는 argument인지, lname에 해당하는 argument인지 또는 datestring에 해당하는 argument인지 그것을 어떻게 구별을 해낼까요?

파이썬은 규칙으로서 이게 위치에 민감한 argument 또는 위치에 민감한 파라미터라는 것과 또 keyword-argument라는 것을 함께 정의를 하고 있습니다.
이런 경우에는 이 Henry라고 하는 것은 바로 위치를 따져서 첫 번째 파라미터에 해당하는 argument라고 자동적으로 해석을 하는 것입니다.

이런 상태에서 호출을 하면 Henry는 바로 fname에 해당하는 argument로서 인식이 되는 것입니다.
Run을 시켜보겠습니다.
Alan 당연히 첫 번째 argument로 들어갔고, Simpson이 의도적으로 주어졌기 때문에 unknown이 아니어서 msg에 합산이 되었습니다.
concatenate가 된 것이지요.

you mentioned 12/31/2019 이 you mentioned와 datestring이 같이 합쳐져서 이런 긴 문장이 형성이 되고 print가 된 것입니다.
두 번째 Henry만 argument로 주어서 호출을 했을 때는 Hello Henry 이 한 마디만 하고 끝이 납니다.
왜 그럴까요?
lname은 unknown이었고, datestring의 길이는 제로였기 때문에 이 if문 내부에 있는 if 블록들이 하나도 수행이 되지 않은 것이지요.

그러므로 msg는 최종적으로 처음에 Hello Henry 이 해당하는 부분만 가진 상태로서 print가 된 것입니다.
이렇게 여러 개의 argument를 주는 경우에 단순히, 이 예를 볼 때 단순히 3개 또는 4개의 argument를 줘야 되는 경우뿐만 아니고, 선택적 파라미터를 같이 혼합해서 줌으로써 이 argument를 우리가 다양하게 줄 수 있다는 모습까지 코딩을 통해서 확인을 해보았습니다.

*************************************끝**************************************

지금까지 우리가 살펴본 것에 의하면 위치에 따라서 argument를 줘야 되는구나, 하는 것을 알게 된 부분이 있습니다.
조금 전에 다루었던 이 fname, 이 fname, lname이라는 것은 사실 first name 또는 last name의 약자라고 보시면 되겠습니다.
first name의 첫 번째 argument를 준다는 것은 첫 번째 fname이라고 하는 파라미터와 매칭이 되는 것입니다.

위치가 매칭이 되는 것이지요.
이런 경우를 위치 인수라고 이야기합니다.
파라미터의 위치와 똑같은 위치로서 주어야지 그 해당되는 파라미터로 들어갈 수 있는 경우가 되는 것이지요.
정의를 다시 해보면 위치 인수는 함수 호출자가 파라미터가 정의된 순서대로 제공한 인수가 됩니다.
제공되는 인수의 위치가 해당 파라미터의 순서와 다르면 잘못된 정보가 전달되는 것이지요.

엉뚱한 데로 인수의 값이 엉뚱한 파라미터로 할당이 되는 것입니다.
그리고 제공된 인수의 개수가 파라미터의 개수보다 많거나 적어도 안 됩니다.
그럴 때는 많거나 적으면 TypeError 오류가 발생합니다.
이런 경우에 위치 인수를 주는 문법은 positional-argument들의 열로서 쭉 형성이 되는데 그 argument와 argument 사이에는 역시 콤마로 separate 구분이 된다는 점만 여러분이 알고 계시면 되겠습니다.


**********************************실습영상***********************************
이제 코딩하는 예를 보겠습니다.
코딩이 상당히 깁니다.
update_persons라는 것은 지난 차시에 우리가 다루었던 종업원의 신상 정보에 대한 딕셔너리 타입의 데이터를 다루는 함수가 됩니다.
여기에서 persons는 global로서 주었습니다.
이 자체가 persons라는 것이 하나의 테이블이 되는 것이지요.
테이블의 특정한 사람에 대한 항목을 추가하거나 변경하기 위해서 update_persons를 이 함수를 만든 것입니다.

파라미터로서 aname, fname 또 year 3개의 파라미터를 주었고, 에이네임 또는 어네임이라는 것은 첫 번째 positional parameter로 주었고, 두 번째와 세 번째는 optional parameter로 주었습니다.
그 optional parameter로서 인수가 주어지지 않을 때 사용하는 기본적인 값은 No name 또는 제로라는 값을 사용하는 것이지요.
person을 딕셔너리 형태로 만들기 위해서 literal 형태의 정의를 했습니다.
딕셔너리 객체를 생성했습니다.

aname이라는 것을 key로 해서 그 value는 또 다른 딕셔너리가 되는데 2개의 key를 가지고 있습니다.
이 딕셔너리는 name이라는 key와 year hired라는 key를 가진 딕셔너리가 됩니다.
2개의 key로 구성이 된 것이지요.
그리고 각각의 key에 대한 value는 fname과 year가 됩니다.
여기에서 fname은 first name이 아니고 full name의 약자라고 생각하셔도 좋습니다.

그러고 나서 이 person이라고 하는 복합적인 딕셔너리를 persons라고 하는 역시 복합적인 딕셔너리에 업데이트를 시키는 것입니다.
person이라고 하는 항목을 persons라는 딕셔너리에 추가를 시키거나 이미 있다면 그 값을 변경시키는 것이 이 업데이트 메소드의 기능이 되는 것이지요.
이렇게 해서 이 update_persons라고 하는 함수를 만들었습니다.
이제 함수 호출자는 persons라고 하는 비어 있는 딕셔너리를 생성을 했습니다.

객체를 생성하고, 최초로 update_persons를 호출을 했습니다.
'asmith' 그다음에 'Alan Smith', 2019라는 3개의 파라미터를 주었습니다.
여기에서 'asmith'라는 것은 'Alan Smith'의 약자, 이름의 약자라고 보면 되겠지요.
그리고 'asmith'는 그에 대한 full name이라고 보면 되겠습니다.
그리고 persons를 일단 print를 합니다.
이 항목이 제대로 잘 등록이 됐는지 업데이트가 돼서 들어왔는지 persons를 일단 print를 해서 확인을 하고, 다시 그다음에 또 테스트를 하기 위해서 이 persons를 다시 비어 있는 객체로 리셋을 했습니다.

그리고 update (2019, 'hjackson', 'Henry Jackson')이라는 문자열 숫자를 주었는데, 여기에 보면 여기 처음에 우리가 의도한 파라미터하고는 조금 다르지요.
이 aname이라고 하는 것은 원래 우리가 의도한 것은 string 문자열인데 여기에는 정수를 주었네요.
또 세 번째 보니까 이게 'Henry Jackson' 이게 원래 full name에 해당하는 것인데 year에 해당하는 argument로서 주었습니다.
원래 year는 정수가 들어와야 되겠지요.

그런데 string이 들어왔어요.
이럴 때 파이썬 인터프리터는 이 잘못 주어진 파라미터, 위치가 뒤바뀐 파라미터를 보고 잘못이라는 것을 알 수 있을까요?
알지는 못합니다.
이 함수 내부에는 그 어디에도 정수를 분별하거나 또는 string이 아니면 안 된다는 부분들이 없기 때문에 그대로 이 인수를 정상적으로 들어온 것처럼 취급을 하게 됩니다.
다만 우리가 의도한 정보의 배분이 일어나지는 않았지요.

엉뚱하게 이름의 약자에 2019라는 숫자가 들어가게 되고, full name에는 이름의 약자가 들어가고 숫자가 들어가야 되는 'year_hired'에는 'Henry Jackson'이라는 엉뚱한 스트링이, 뜻이 뒤바뀌게 된 것입니다.
그렇지만 오류는 발생하지 않는다는 것입니다.
그리고 print를 해서 persons를 해보아도 그 값이 뒤죽박죽이 돼서 들어가 있기는 하겠지만 오류는 나타나지 않은, 의미상의 오류는 나타나지만 type이라든지 syntax에 대한 오류는 나타나지 않은 것을 볼 수 있습니다.

그다음에 update_persons에서 아무런 argument를 주지 않았을 경우와 또 update_persons를 해서 원래 요구하는 파라미터의 수보다도 더 많은 argument를 4개를 주었습니다.
원래는 3개인데 4개를 주었습니다.
이럴 때는 또 어떻게 반응을 할까?
이 3가지, 크게 봐서 3가지 케이스에 대해서 이 반응을 보기 위해서 코딩을 한 것입니다.

Run을 시켜보겠습니다.
Run을 시키면 여기에서 첫 번째, 두 번째는 아무런 오류 없이 print가 실행이 됐습니다.
실행이 됐다는 것은 이 definition된 update_persons라는 함수에서는 오류를 잡아내지 못한 것이지요.
그런데 두 번째를 주목해서 보면 우리가 의도한 딕셔너리의 구조와는 전혀 의미가 다른 데이터들이 들어앉아 있음을 볼 수 있는 것입니다.

*************************************끝**************************************

지금까지 positional parameter 또는 positional argument에 대해서 살펴보았습니다.
positional argument라는 것은 순서가 뒤바뀌게 argument가 제공되면 파라미터에 뒤죽박죽으로 argument가 배정이 돼서 원래 의도한 정보 전달이 되지 못하게 된다는 부분도 코딩을 통해서 확인을 했습니다.

이제 키워드 인수를 통해서 정보를 제공하는 방법에 대해 실습을 해보겠습니다.
키워드 인수는 함수 호출자가 함수의 파라미터 이름의 인수를 배정하는 형식으로 인수를 제공하는 것을 뜻합니다.
파라미터의 정의 순서에 관계없이 인수를 제공할 수 있는 점이 특징이 되지요.

조금 전에 보셨던 위치에 민감한 인수들은 그 순서가 파라미터의 순서와 다르게 되면 매치가 되지 않으면 전혀 엉뚱한 정보가 전달이 되는 것을 보셨을 텐데요.
그 형식은 밑에 있는 박스와 같습니다.
argument들은 positional argument와 keyword argument를 혼합해서 줄 수 있는데 기본이 되는 것은 positional-argument들입니다.
그 뒤에 선택적으로 keyword argument를 줄 수 있습니다.

또는 전체를 전부 keyword argument로만 줄 수도 있지요, 물론.
이런 형태를 구문이 표현하고 있는 것입니다.
keyword argument라는 것은 그 파라미터 이름의 argument를 값으로 배정하는 형태로 주어지게 되는 것입니다.
이런 문법에 따라서 여러분이 argument를 주시면 되겠습니다.


**********************************실습영상***********************************
실습을 해보겠습니다.
코딩된 프로그램을 보시겠습니다.
먼저 hello 함수를 정의를 하고 있습니다.
이때 파라미터를 3개를 주었는데, 하나는 argument를 반드시 요구하는 파라미터가 되겠고, 두 번째와 세 번째 파라미터는 optional parameter지요.
선택적 파라미터입니다.
argument를 주어도 되고, 안 주어도 되는.
안 준다면 자기들이 가지고 있는 기본 값을 사용하겠다는 파라미터들이지요.

이제 그 코드는 앞에서 보셨던 것과 거의 비슷합니다.
그래서 구체적으로 설명은 드리지 않겠고, 이 함수를 어떻게 사용하는지 그 점이 중요합니다.
호출을 할 때, 어떻게 사용하는지 보겠습니다.
바로 키워드 형태, 키워드 인수 형태로 인수를 제공하는 것이지요.
date=31/12/2019라는 스트링으로 주었습니다.

fname='Alan'이라는 스트링으로 주었고, lname='Smith'라는 스트링으로 주었습니다.
이러한 형태로 준 경우와 또 'Alan'이라고 하는 하나의 positional-argument를 준 경우, 두 경우를 비교해보는 코딩이 됩니다.
실행을 시켜보겠습니다.
첫 번째 hello 함수 호출은 그 정보를 순서에 관계없이 이러한 fname, lname, date가 정의된 파라미터에 정의된 순서와 관계없이 날짜도 처음 주고, 그다음에 fname을 두 번째, lname을 세 번째로 주었습니다.

다만 다른 점은 이 파라미터의 이름을 각각 배정 기호 즉 이퀄 기호 왼쪽에 붙여준 것이 다른 것이지요.
이런 keyword-argument를 주었을 때는 그 준 순서와 관계없이 제대로 해당되는 파라미터의 그 argument값이 다 배정 되어서 우리가 원하는 대로 정확한 정보를 가진 문자열이 print가 됨을 알 수 있습니다.

'Alan'이라고 하는 하나의 스트링만 주었을 경우에도 역시 첫 번째 positional-argument로서 잘 받아서 fname에 들어가서 msg가 Hello Alan 그다음에 또 else 부분에 들어가서 date가 주어지지는 않았지만 else 부분으로 가서 'may I help you'라고 하는 다른 문장이 나오도록 잘 정보가 조합이 됐음을 확인이 되는 것이지요.
지금과 같이 키워드, 중요한 것은 이 keyword-argument를 주는 부분에 대해서 우리가 확인을 해본 것입니다.

*************************************끝**************************************

이번에는 위치 인수와 키워드 인수의 혼합 사용하는 경우에 대해서 실습을 해보겠습니다.
위치 인수와 키워드 인수를 혼합 사용하는 경우에는 위치 인수가 반드시 먼저 나와야 됩니다.
그다음에 키워드 인수가 놓여야 하는 것이지요.

그 밑에 있는 구문 문법의 박스를 참조해보시면 positional-keyword-mixed-arguments 이렇게 그런 두 종류의 argument가 혼합되어 있는 형태는 먼저 positional-argument가 나오고 그다음에 keyword-argument들이 나와야 된다는 것을 표현하고 있는 것입니다.
위치 인수와 키워드 인수의 섹션 구별을 하는 경우가 있는데 위치 인수와 또 키워드 인수를 정상적으로 사용한 경우와 잘못 사용한 경우의 코딩 예를 보면서 이 혼합 사용의 예를 보도록 하겠습니다.


**********************************실습영상***********************************
코딩이 간단합니다.
f라는 함수를 정의를 했습니다.
(x, y, z)라는 3개의 파라미터를 같이 정의를 했고, func-suite는 (x, y, z)를 그대로 print하는 것으로 삼았습니다.
이제 호출자가 함수 f를 부릅니다.
1, 2 그다음에 z=3이라고 하는 키워드 인수를 주었습니다.
처음 2개의 1과 2라고 하는 것은 positional 인수지요.

앞에서 말씀드린 대로 positional 인수 2개를 먼저 주었고, 그다음 마지막으로 이 키워드 인수를 준 것입니다.
다음 부르는 함수인 f를 부르는 경우에서는 1이라는 positional 인수를 주고, y라는 키워드 인수를 주고 그다음에 또 positional 인수를 주는 형태로 호출을 했습니다.
이것은 앞에서 말씀드린 키워드 인수와 positional 인수의 혼합 규칙에 위배가 되는 것이지요.

무엇이라고 했지요?
항상 positional 인수가 키워드 인수보다는 앞에 나와야 된다.
그런데 여기에서 그 규칙을 위배한 것이 y=2와 3 이 부분이 그 규칙을 위배한 것이지요.
이런 경우에 어떤 결과가 나오는지 실행을 해보겠습니다.
실행하지도 않은 상태로 여기에 SyntaxError가 났습니다.

즉 인터프리터에서는 이 프로그램 전체를 인터프리트를 할 때, 위치 인수와 키워드 인수의 혼합 규칙에 위배가 된 것을 먼저 발견해서 이 함수 호출을 실행하지 않은 상태에서 바로 SyntaxError를 내놓게 된 것입니다.
무엇이라고 SyntaxError를 내놓았는지 정확하게 보면 positional argument가 keyword argument를 따라오고 있기 때문에 안 된다고 에러를 나타낸 것이지요.
이런 경우에는 아예 함수가 호출이 되지도 않는 것을 알 수 있습니다.

*************************************끝**************************************

조금 전까지는 함수의 정보를 주는 과정에 대해서 살펴보았고, 이제는 반대로 함수로부터 호출자가 정보를 받는 함수가 정보를 제공하는 과정에 대해서 살펴보도록 하고 또 그에 대한 실습을 코딩을 통해서 해보겠습니다.
리턴 값으로 정보를 받기인데요.
키워드 리턴에 의한 함수로부터 리턴을 할 때, 리턴 값을 받는 과정을 보겠습니다.

그림에서 보시면 위에 있는 것이 메인 프로그램이지요.
함수의 호출자가 됩니다.
함수를 호출했습니다.
앞에서 설명을 드렸던 대로 함수 부분으로 control flow가 점프를 하게 되지요.
그래서 펑션 내부로 들어갑니다.
쭉 실행을 하다가 왼쪽에 있는 것은 중간에 return-stmt를 만난 경우입니다.
그러면 강제적으로 이 return-stmt에 의해서 함수가 다시 호출자 쪽으로 되돌아가게 되지요.

이때 빈손으로 가는 것이 아니고, 무엇이든 간에 return-value를 손에 쥐고 갑니다.
또 오른쪽에 있는 경우는 쭉 함수의 func-suite가 실행을 하다가 리턴을 만나지 않고 그대로 끝난 경우입니다.
이런 경우에도 자동적으로 리턴을 해서 함수의 호출자 쪽으로 돌아가게 되는데 이때도 마찬가지로 return-value를 손에 쥐고 가게 됩니다.

오른쪽에 있는 경우 코드를 모두 다 실행을 시키고 return-stmt가 아닌 자동 엔드가 돼서 리턴을 하는 경우에는 None이라고 하는 value를, None value를 return-value로 갖고 귀향을 하게 되고 return-stmt에 의해서 귀향을 할 때는, 리턴을 할 때는 return-stmt에 함께 주어진 값을 가지고 리턴을 하게 됩니다.
만일 리턴이라는 키워드만 있고, 그 옆에 값이 주어지지 않은 경우에는 역시 None이라는 값을 가지고 귀향을 하게 되는 것입니다.

그래서 모든 함수는 리턴 값을 제공한다.
None이든 또는 특별하게 지정된 값이든 리턴 값을 가지고 리턴을 한다고 볼 수 있습니다.
그 문법을 보겠습니다.
함수의 리턴 구문은 리턴 키워드와 선택적 리턴 값 values로 구성이 됩니다.
두 번째 줄을 보시면 return-value는 return-value들의 열로서 이루어져 있지요.
또 이 return-value는 object-literal 즉 문자적으로 구성이 된 object값 그 자체가 될 수도 있고, 그렇지 않으면 identifier가 될 수도 있고, function에 대한 identifier가 될 수도 있습니다.

여기에서 표현은 function이라고 했는데 function identifier를 뜻합니다.
이런 것들을 가지고 리턴을 한다면 이런 값을 return-value로 가져가게 되는 것입니다.
그렇지 않으면 리턴 구문에 아무 것도 값이 주어지지 않았다면 None이라는 값을 가지고 가게 되는 것이지요.
리턴 유형에 대해서 생각해보겠습니다.

리턴 구문에 value가 없거나 자동 리턴할 때 함수는 None을 리턴하고 이의 유형은 None Type이 되는 것이고요.
return-values가 단일 값이면 함수는 return-value의 유형을 유지하며 리턴을 하게 됩니다.

그리고 return-value가 각각 콤마로 분할된 여러 아이템들로서 그 value 아이템들로서 구성이 될 때는 이 아이템들을 하나로 묶어서 자동적으로 튜플로 묶어줍니다.
이 튜플의 유형으로서 리턴을 하게 됩니다.
리스트로 유형이 정해지는 것이 아니고, 튜플로서 여러 항목들을 묶어서 return-value로 가져가게 된다는 것을 조금 기억을 해주시면 좋겠습니다.
이제 단일 값을 리턴한 경우에 대해서 코딩을 통해 그 기능을 실습을 통해 확인을 해보겠습니다.


**********************************실습영상***********************************
코딩된 부분을 보시면 prduct3라는 함수를 정의를 했습니다.
parameter로는 a와 b와 c를 주었는데 무슨 일을 하는가 보았더니 a와 b와 c 그리고 이 세 a, b, c의 곱을 각각 항목으로 하는 list를 구성해서 리턴을 하도록 하는 것입니다.
이렇게 단일 유형으로 리턴을 하게 되지요.

어떤 유형인가?
바로 list라는 유형으로 리턴을 할 때는 이 함수의 리턴 유형은 list가 되는 것입니다.
이제 함수를 호출을 해보겠습니다.
product3를 호출하되 1과 2와 3이라는 정수 3개를 인수로 주어서 호출을 했습니다.
그 결과 리턴 되는 값을 받기 위해서 lhs로서 p를 두었습니다.
그리고 p를 print를 했지요.
그 결과를 실행을 통해 보겠습니다.

인수는 3개를 주었고, 결과는 4개의 항목이 들어있는 a, b, c 그다음에 a와 b와 c의 곱 이렇게 4개의 항목이 들어있는 list를 받아서 print가 된 것입니다.
1, 2, 3과 1, 2, 3의 곱 6이 나왔지요.
이렇게 이 type를 확인해보지 않더라도 이 p의 유형이 list인 것을 이 print문을 통해 출력된 이 내용을 보면서 자동적으로 또 확인을 할 수 있었습니다.

*************************************끝**************************************

이제는 다수의 값을 리턴을 하는 경우에 대해서 실습을 통해 어떻게 리턴이 되는지 확인을 해보겠습니다.
앞에서도 말씀드렸듯이 콤마로 분할된 각각의 값을 아이템으로 삼은 튜플 유형으로서 하나로 묶여서 역시 리턴이 된다는 것을 확인이 되는지 실행을 해보겠습니다.


**********************************실습영상***********************************
코딩 쪽에서 처음에 product3와 이 정의 구문, definition 구문은 동일하지요.
위에 것과 동일합니다.
그런데 리턴을 할 때 보니까 list로서 묶여서 리턴이 되는 것이 아니고, 지금 4개의 항목 a와 b와 c 그리고 a, b, c를 곱한 것까지 해서 4개의 콤마로 구별된 항목들이 제각기 리턴이 되고 있음을 볼 수 있는데, 이들이 어떻게 리턴이 되는지 보겠습니다.

여기는 print문을 쓰지 않고, 바로 이 product3를 호출해서 이 파이썬 인터프리터가 내놓는 값을 통해서 확인을 해보겠습니다.
실행을 해보겠습니다.
파이썬 인터프리터가 출력하면 이렇게 out이라는 항목이 따로 표시가 되는데 지금 괄호로 묶여져 있지요.
(1, 2, 3, 6)이 괄호로 묶여져 있습니다.
즉 이들은 이 리턴된 항목은 하나의 객체 유형인데 튜플입니다.
튜플 속에는 1, 2, 3 그리고 6이라는 항목이 들어있음을 확인할 수 있습니다.

*************************************끝**************************************

다음에는 리턴 구문을 통하지 않고 자동 종료가 돼서 함수 suite가 자동 종료가 돼서 리턴이 되는 경우 어떤 유형의 값이 리턴이 되는지 보도록 하겠습니다.
앞에서 말씀드리기는 None 유형이 리턴이 된다고 말씀드렸지요.
확인을 해보겠습니다.


**********************************실습영상***********************************
코딩된 프로그램을 보시면 앞부분 product3에 해당하는 이 함수 정의 부분은 동일합니다.
그리고 p라는 내부 지역 변수를 정의를 했는데, 지역 변수 또는 지역 객체지요.
지역 객체를 정의했는데 파라미터로 주어진 a와 b와 c를 모두 곱해서 그 값을 받는 객체로서 지역 객체를 정의를 했습니다.
이제 호출자는 product3를 호출을 했습니다.

1과 2와 3이라는 숫자를 주어서 호출을 했고, 그 결과값을 p로서 받고자 하고 있습니다.
이 의도가 무엇인지는 우리가 지금 잘 모르는데 아마 1과 2와 3을 곱한 값을 받으려고 하는 것 같지요.
그런데 어떤 값이 나오는지 print를 통해서 확인을 해보겠고, 조금 값이 이상하니까 그 타입이 무엇인지 또 이 타입을 확인을 해보도록 하겠습니다.

지금 여기 product3지요.
실제 이 함수에서 리턴 되는 값의 타입이 무엇인지 확인을 해보도록 하겠습니다.
p를 받아서 print를 했더니 None이라는 값이 나왔습니다.
이상하다?
None이면 내가 의도한 값은 아닌데 6이 나와야 될 텐데, 왜 None이 나왔을까?
이 함수가 리턴한 값의 유형은 과연 무엇일까?

또 함수를 한 번 더 호출을 해서 타입을 불러서 타입을 확인시킨 다음에 그 타입 결과를 print문을 통해서 찍어봤더니 class 'NoneTyoe'이 됐네.
이렇다면 여기에서는 리턴을 구체적으로 실행하지 않았고, 자동 종료가 된 유형이구나.
이런 형태에서 제대로 값을 얻으려면 어떻게 해야 될까요?
이럴 때는 우리가 한 가지 방법을 아는 점은 있지요.

여기에서 global p를 지정해놓으면 되는 것이지요.
그리고 다시 Run을 해보면 이제 여기에서는 p를 받으면 안 되지요.
받으면 안 되고, 여기에서는 그대로 실행만 시킨 다음에 함수를 실행시키고, p를 전역 변수를 통해서 그 정보를 받는 형태로 사용해야 되는 것이지요.
Run을 해보겠습니다.
이렇게 해서 p값은 6을 의도한 대로 가지고 있습니다.

다만 이 함수는 자동 종료를 했기 때문에 None 타입을 리턴하는 것에는 변함은 없습니다.
이런 종류의 함수를 여기에 p를 주든지 해서 객체 참조를 왼쪽에 두어서 무엇인가 배정을 받으려고 한다면 전혀 의도하지 않은 결과가 나타나게 되겠지요.
이런 점을 우리는 조심해야 될 것입니다.

*************************************끝**************************************

이렇게 해서 이번 차시에는 함수에 대해서 우리가 아주 자세하게 살펴보았고, 이 함수와 이제는 매우 디테일하고 또 우리의 모든 요구를 주고받고 또 해결 받을 수 있는 정도까지 이 함수를 이해하고, 함수와 이야기할 수 있는 그런 지식을 여러분과 함께 이번 차시에 나누어보았습니다.
