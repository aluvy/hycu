11. 파이썬 클래스

-------------------------------------------------------------
11_02. 클래스의 성질 파악하기
-------------------------------------------------------------

[2페이지]

이번 차시에는 파이썬 클래스에 대해서 알아보겠습니다.
이번 차시에 주로 다룰 내용은 첫 번째 클래스의 성질을 파악하고 그 파악한 지식을 이용해서 클래스를 잘 다루는 방법에 대해서 알아보도록 하겠습니다.
이번 차시를 통해서 여러분은 클래스의 개념과 기능적 특징에 대해서 설명하실 수 있게 될 것이고 응용에 적합한 클래스를 설계하고 활용하는 프로그래밍을 코딩할 수 있게 되실 겁니다.

첫 번째 교시 클래스의 성질 파악하기입니다.
사람이든 무엇이든 그 이름을 잘 지어야 하지요.
파이썬 또는 그 밖의 다른 프로그래밍 언어에서도 객체들의 이름을 정하는 것이 굉장히 중요한 의미를 가지고 있습니다.
그리고 그 이름을 어떻게 해석을 하고 사용하느냐 하는 것이 그 프로그래밍 언어를 익숙하게 또 능숙하게 다룰 수 있느냐 못하느냐를 판가름 하는 중요한 원인 중에 하나가 되는 것입니다.

이제 객체 이름에 대해서 생각을 해 보겠습니다.
객체라는 것은 개별성을 가진 존재들입니다.
그 객체 이름은 하나 이상의 그 이름을 객체들에게 하나의 객체에 부여할 수 있습니다.
즉 사람이 자기의 본명이 있고 별명을 가지고 있듯이 또는 그 사람을 부를 때 여러 가지 방법으로 식별할 수 있도록 부르듯이 이 객체에도 이름이 하나만 있는 것이 아니고 여러 가지의 이름이 있습니다.

그리고 파이썬에서는 이름 공간을 개념을 사용하고 있습니다.
이름 공간이라고 하는 것도 파이썬뿐만 아니고 다른 일반적인 프로그래밍 언어에서도 사용하는 개념인데 우선 파이썬을 중심으로 해서 그 개념을 알아보도록 하겠습니다.
파이썬에서는 이름 공간을 어떻게 정의하는지 보겠습니다.

이름과 객체, 매핑이다.
즉 1:1로 관계를 맺어주는 것입니다.
파이썬은 이름 공간을 항목이 키는 이름이 되고 value 값은 그 object-id가 되는 사전유형의 객체로 구현을 해 놓은 것이 바로 이름 공간이라고 하고 있습니다.
여기에서 object-id라는 것은 그 오브젝트가 메모리에 있을 때 그 메모리의 주소를 뜻한다고 보시면 되겠습니다.

이름 공간에는 지역성이 있습니다.
이름 공간의 지역성의 수준은 파이썬 인터프리터의 built in 또는 내장 수준으로부터 모듈 수준, 함수나 클래스 수준으로 나누어볼 수 있고 내장 수준으로 갔을 때는 지역성이 가장 희박합니다.
그 대신에 전역성이 가장 크다고 할 수 있고 함수나 클래스 쪽으로 가면 지역성이 크다고 할 수 있습니다.

지역성이라고 하는 것은 그 한 영역 안에서만 통용되고 다른 곳에서는 의미를 잃어버리는 성질을 뜻하는 것이지요.
그래서 지역성이 클수록 어느 한 곳에서만 사용되는 성질이 강하고 전역성이 클수록 광범위하게 모든 모듈에 걸쳐서, 모든 함수에 걸쳐서 사용할 수 있는 이름이라는 성질을 가지고 있습니다.
거기에 맞게 이름 공간도 각각 생성이 되고 설정이 되는 것입니다.

이름 공간의 독립성을 한번 보겠습니다.
이름 공간은 지역성 수준이 동일한 다른 이름 공간과는 독립성을 가지고 있습니다.
다른 이름 공간과 상관없이 같은 이름을 가질 수 있다고 표현하는 것이 쉽게 이해를 할 수 있는 표현이지요.
예를 보겠습니다.
import 두 개 모듈을 import를 했습니다.

import module1, module2 해서 두 개 모듈을 import 하고 module1에도 func라고 하는 이름을 가진 함수가 있습니다.
module2 안에서도 똑같은 이름을 가진 함수가 있을 때 그런 이름들은 동일하게 사용할 수 있습니다.

그런데 사용하는 입장에서 볼 때는 module1의 func이나 또는 module2의 func이라는 동일한 이름을 가진 함수를 사용하려면 그 앞에 Qualifier를 붙여줘야 합니다.
그 Qualifier는 바로 module1, module2라고 하는 각각의 이름이 되는 것입니다.

이런 방법으로 그 동일한 이름을 가진 함수에 액세스 할 수가 있다면 그래서 레퍼런스를 잘 resolution 한다.
즉 해석을 할 수 있도록 한다면 이름이 동일해도 문제가 없다.
그럼으로써 이 이름 공간 간에는 이름에 대한 독립성을 부여할 수 있다고 이야기하는 것입니다.

이름 공간의 생성과 수명에 대해서 이야기해 보겠습니다.
앞에서 말씀드렸을 때 내장 또는 모듈 그리고 함수와 클래스라는 이름에 대한 대상을 이야기했었는데요.
거기에 맞춰서 내장 이름 공간, 내장이라고 하면 좀 어감이 이상하기도 하니까 built in이라는 이름을 자주 사용하도록 하겠습니다.
built in 이름 공간, 모듈 이름 공간 그리고 함수나 클래스 이름 공간 등으로써 이름 공간을 나누어볼 수 있습니다.

내장 이름 공간, 이것은 파이썬 인터프리터가 시작될 때 생성되고 파이썬 인터프리터가 종료될 때 사용된, 그때까지 사용되는 것입니다.
내장 이름 공간의 이름은 module builtins나 또는 __builtins__ 해서 정의가 된 것입니다.
여러분이 이 더블 builtins를 어디서 볼 수 있냐 하면 파이썬 인터프리터에서 dir 하고 그 dir 함수를 파라미터를 두지 않은 상태에서 호출을 하면 그 안에 builtins가 있음을 볼 수 있고 그 __builtins__ 내용을 다시 dir을 해 보시면 그 안에 들어있는 모든 이름 공간에 들어있는 이름들이 여러분 눈앞에 나타날 것입니다.

모듈 이름 공간은 어느 한 모듈에 대한 이름 공간을 그 모듈에 대한 전역 이름 공간이라고 하는데 그 모듈에서 정의된 모든 데이터 속성이나 함수 속성의 이름이 전역 이름 공간에 등록이 되는 것입니다.
이런 것들을 모듈 이름 공간이라고 하고 이것들을 그 모듈 안에 있는 데이터나 함수에 대해서는 전역 객체의 이름으로써 또는 전역 이름으로써 사용되는 것입니다.

함수 이름 공간이 있습니다.
각 함수마다 자기만의 지역 이름 공간을 가지게 되는데 이것을 함수 이름 공간이라고 이야기합니다.
이 함수의 지역 이름 공간은 함수가 호출될 때 생성이 되고 리턴을 할 때 삭제가 됩니다.
그리고 함수가 재귀적으로 호출이 될 때, 물론 그 호출될 때마다 호출된 실체가 생기게 되는데 그 실체마다 지역 이름 공간이 생성되게 됩니다.

클래스 이름 공간도 함수 이름 공간과 마찬가지의 수준의 지역성을 가지고 있다.
즉 가장 강한 지역성을 가지고 있습니다.
역시 클래스마다 지역 이름 공간을 가지게 되고 클래스의 지역 이름 공간은 클래스가 정의될 때 생성되고 삭제될 때 함께 삭제됩니다.
클래스를 삭제한다는 것은 무엇으로 삭제하지요?
델이라는 키워드로 삭제를 하지요.

클래스 이름 공간을 동적으로 변경을 할 수도 있습니다.
이것은 함수에 이름 공간과 좀 다른 성질이 되는 것이지요, 특징이 되는 것입니다.
속성을 수시로 추가, 삭제를 함으로써 그 이름 공간에 들어있는 이름들이 추가가 되기도 하고 삭제가 될 수가 있다는 것입니다.

이것을 프로그램 코딩을 하는 그 단계 또는 인터프리팅을 하는 단계에서 수행이 되는 정적인 이름 공간의 변경이 아니고 동적으로 그 코드가 수행되는 과정에서 그걸 뭐라고 하지요?
코드가 수행되는 흐름을 실행 제어 흐름이라고 그랬지요.
그 실행 제어 흐름에 따라서 이 이름 공간의 변화가 일어날 수 있는 것입니다.

이제 이름 공간과 조금 비슷한 개념이기는 한데 이름 범위에 대해서 알아보겠습니다.
이름 공간이라고 하는 것은 built in 레벨 또는 모듈 레벨 또는 함수나 클래스 레벨에서의 포괄적인 그런 개념으로써의 이름 공간이라고 이름을 붙여주었었는데 이제 이름 범위, scope라고 하는 것은 바로 여러분이 작성한 프로그램 코드 위에서의 범위를 scope라고 이야기를 합니다.

정의를 해 보면 이름 공간에 직접 액세스 가능한 파이썬 코드의 영역이라고 하는 것입니다.
이름 공간에 직접 액세스 한다는 것은 directly accessible은 접두사가 붙지 않은 이름, 또는 Qualifier가 붙지 않은 이름 그 자체만으로 가지고 바로 레퍼런스를 해서 사용할 수 있는 그런 이름들이 적용이 되는 코드의 영역을 이름 공간이라고 하는 것입니다.

조금 설명이 복잡하기는 합니다.
그러나 이름 공간하고 이름 범위의 구별을 여러분이 잘 해 두셔야 합니다.
한마디로 말씀을 드리면 이름 공간이라는 것은 객체라든지 모듈에 맞게 형성되어 있는 사전이다.
이름과 그 이름에 대한 주소에 대한 사전이라고 말씀할 수 있는 것이고.

그다음에 이름 범위라는 것은 이런 이름 공간, 즉 그 사전을 펼쳐서 사용할 수 있는 사용하되 바로 이름을 찾아들어갈 수 있는 그런 일을 할 수 있는 코드의 범위이라는 것을 뜻하는 것입니다.
가장 안쪽 범위에 둘러싼 범위, 전역 범위 그리고 최외각 범위로 구별할 수 있습니다.

그 그림을 보시면 지금 말씀드렸던 대로 가장 안쪽에 되어 있는 것은 가장 안쪽에 있는 네모난 작은 사각형들이라고 보시면 되겠습니다.
local scope1부터 N까지 local scope들이 enclosing scope1 속에 들어있습니다.
이런 local scope를 몇 개를 품고 있는 enclosing scope들이 L개까지 들어있는 것이 global scope1이라고 하는 것입니다.

그 global scope1에는 enclosing scope와 함께 그 enclosing scope가 포함할 수 있는 local scope가 enclosing 밖에서도 존재할 수 있습니다.
local scope가 M개까지 하나에서부터 M까지 존재하고 있는 것을 표현하는 것입니다.
global scope가 하나만 있는가?
그렇지 않지요.
K개까지 있을 수 있다.

그래서 하나의 파이썬 인터프리터에서 동작을 하는 응용 프로그램 속에서는 global scope가 K개까지 존재할 수 있다.
이 이야기는 뭐냐 하면 응용 프로그램이 K개의 모듈을 끌어서 다 포함하면서 구성이 되어 있다는 것을 의미하는 것입니다.
이런 구조 프로그램의 구조에 맞춰서 global scope라든지 enclosing scope라든지 local scope가 형성되는 것이고 또 이들이 scope 안에서 사용할 수 있는 이름 공간, name 스페이스들이 제각기 다르게 존재하는 것입니다.

그리고 잠깐 또 말씀을 드리면 local scope라고 하는 것은 하나의 함수 또는 클래스라고 말씀을 드릴 수 있습니다.
또 enclosing scope라는 것은 그 함수라든지 클래스를 정의한 것은 포함하고 있는 그 내부에서 정의하고 있는 좀 더 큰 함수라고 이야기할 수 있고 또는 좀 더 큰 클래스라고 이야기할 수 있습니다.

nested function이라든지 nested class라는 이야기를 우리가 할 수 있습니다.
러시아의 목각 인형이 있지요.
뚜껑을 열면 또 안에 작은 인형이 들어있고 또 그 작은 인형의 윗부분을 열면 또 작은 인형이 계속 들어있는 이런 것을, 이름은 제가 기억은 못하겠는데 이런 인형들의 개념으로써 nesting을 할 수 있지요.

이렇게 함수 하나라고 하더라도 그 함수 속에서 또 다른 함수가 정의될 수 있고 그 안에는 또 더 낮은 수준의 함수가 또는 지역성이 강한 함수가 정의가 될 수 있는 구조를 보이는 것입니다.
이런 구조에 맞춰서 scope도 같은 모습으로써 나타나게 되는 것입니다.

이제는 파이썬 객체 지향성 구성 요소에 대해서 말씀을 드리겠습니다.
파이썬 객체 지향성을 구성해 주는 제공해 주는 여러 가지 개념에 대해서 말씀을 드리는 시간이 된 것인데요.
먼저 클래스에 대해서 말씀을 드리겠습니다.

클래스와 지금까지 사용해 왔던 데이터 타입이라는 것은 어떤 관계가 있을까?
같다고 보시면 되겠습니다.
파이썬에 built in 데이터 유형을 기본 클래스로 사용해서 사용자 클래스를 파생시킬 수도 있는 것입니다.
이 부분에 대해서는 파생한다는 것은 조금 이따 상속에 대해서 말씀을 드릴 때 좀 더 말씀을 드리겠습니다.
이제 또 밑에 있는 내용을 보겠습니다.

클래스의 구성 요소를 보면 클래스는 데이터 속성, 메소드 속성 그리고 property로 구성이 됩니다.
어떤 분들은 속성과 메소드 이걸 서로 다른 개념이 다른 용어가 아니냐고 생각하실 수도 있어요.

C나 C++ 같은 경우에는 attribute를 데이터, 그 클래스 안에 정의된 데이터라고 생각을 하고 메소드는 그 클래스 안에서 전용적으로 사용되는 함수라고 생각을 하는 개념이 강했기 때문에 attribute, 즉 속성이라는 것과 메소드는 서로 동등한 그리고 독립적인 용어가 아니냐는 생각을 할 수도 있는데 파이썬에서는 속성이라는 것으로 전부 포괄을 시켜버립니다.

그리고 속성 중에서 종류가 몇 가지 있는데 그중에 데이터 속성, 메소드 속성, 그다음에 property 속성이 있다고 생각을 하는 것입니다.
property는 데이터와 메소드의 성질을 모두 가진 속성이라고 할 수 있는데 뒤에 가서 자세하게 설명을 드리겠습니다.

클래스를 정의하는 방법에 대해서 보겠습니다.
클래스의 역할은 바로 클래스를 정의하는 자체는 무엇인가?
클래스 객체를 생성한다.
어, 이상하다?
전에 혹시 자바라든지 또 C++의 경우에는 클래스라고 하는 것은 하나의 설계도, 디자인 된 설계도이고 그 설계도에 따라서 실제로 만들어 놓은 것이 오브젝트가 아닌가라고 생각을 하실 수도 있어요.

그런데 ‘이 클래스 자체가 어떤 객체라니, 이상하다?’라고 생각하실 수도 있는데 그렇지만 이 파이썬에서는 객체라는 것을 굉장히 큰 범위의 개념으로 생각을 하고 그 안에 클래스도 있고 인스턴스도 있고 인스턴스가 C에서 이야기하는 C++에서 이야기하는 오브젝트의 개념이 되는 것입니다.
이런 것들을 전부 하나로 다 뭉쳐 넣어서 커다랗게 객체 오브젝트라고 이야기하는 것뿐입니다.

조금씩 그 정의된 개념이 다르기 때문에 그 점에 대해서 유의를 하시면 되겠고 이런저런 객체 지향성 언어를 접해보지 않은 상태에서 이 파이썬을 먼저 공부를 하시는 분들은 또 다른 언어들과는 이런 개념의 차이가 있으니까 다른 언어를 나중에 접할 때는 어떤 점에 생각을 할 때 조심해야 하겠구나, 라는 것을 먼저 알고 계시면 좋을 것 같습니다.
이런 클래스 정의 구문 문법에 대해서 보면 클래스라는 키워드를 두고 그 옆에 class-name 그다음에 괄호 열고 base-class-names을 옵션으로 줄 수가 있습니다.

그다음에 괄호 닫고 콜론을 치면 이게 클래스 정의 구문의 해독 파트가 됩니다.
그리고 그 밑에서 내용은 나중에 실습을 할 때 우리가 보겠지만 class-suite가 존재하게 됩니다.
이 class-suite는 docstring이라든지 data-attribute라든지 method-attribute라든지 property 등이 뒤섞여서 조합이 되어서 구성되는 것이라는 것을 밑에 표현해 놓은 것입니다.

이런 클래스 정의 구문의 실행 개요를 보면 class-def-statemnet가 실행되면 클래스 객체를 생성하고 클래스 지역 이름 공간을 생성하고 클래스 이름을 현재 이름 범위에 이름 공간에 등록하는 일이 발생하게 됩니다.
이런 정의 구문의 실행 여부는 파이썬 프로그램 코드의 실행 제어 흐름에 따라서 결정됩니다.

만일 if문 속에 if condition문 속에 이 클래스 정의문이 들어가 있다면 그 조건이 맞지 않으면 그냥 스킵을 할 수 있는 것입니다.
그렇게 되면 이 클래스가 생성되지 않고 나중에 이 클래스를 이용해서 오브젝트를 생성시키려고 한다면 오류가 발생하게 되는 경우도 있게 됩니다.
그다음에 class-suite에서 객체에 대한 배정 구문이 실행되면 그 객체의 이름이 바로 클래스 지역 이름 공간에 등록이 되어버립니다.
지역 이름 우선 원칙에 의해서 이런 일이 발생되는 것이지요.
전역 객체나 비지역 객체의 배정 구문을 적용하려면 그래서 global 구문이나 nonlocal 구문을 명시적으로 여러분이 사용해야 하는 것입니다.

이제 클래스 다음에 속성에 대해서 말씀을 드리겠습니다.
클래스는 속성들의 그 결합체이다.
또 그렇다면 속성은 무엇인가?
속성의 일반적인 정의는 클래스의 여러 가지 특징을 표현하는 클래스 내용 구성 요소의 포괄적인 명칭입니다.
클래스 안에서 정의된 member data, method, property 등을 뜻한다, 조금 전에 말씀을 다 드렸지요.

모듈 안에서 정의된 함수, 데이터를 뜻합니다.
클래스가 아니고 모듈 안에서도 속성이라고 이야기할 수 있는데 모듈 파일 안에서 가장 최상위 레벨에서 정의된 함수나 데이터 객체를 이야기하는 것입니다.

또 속성에 대한 액세스 범위에 따라서 공개 속성, 비밀 속성 그리고 특수 속성으로 구분을 합니다.
액세스 범위라든지 그 용도에 따라서 이런 공개, 비밀, 특수라는 이름을 붙이기도 합니다.

이제 비밀 속성이라는 것은 클래스나 모듈의 메소드 그리고 함수들만 액세스하고 사용하려는 목적으로만 만들어놓은 속성이 됩니다.
관행상 이름 앞에 싱글 언더바를 붙입니다.
예를 들면 sys._clear 또는 sys._git 이런 것들이 바로 전형적인 비밀 속성의 이름이 될 수 있는 것입니다.
레퍼런스가 될 수 있는 것이고 그중에서 _git는 비밀 속성 이름이 되는 것이지요.

클래스의 특수 속성이 또 있습니다.
이건 모듈에는 없는 것인데 아, 모듈에도 있을 수 있습니다.
모듈에도 있는데 클래스에서 주로 우리가 생각을 해 볼 수 있는 것이 파이썬의 내장 함수가 클래스나 실체 객체를 다룰 때 직접 액세스 하는 속성이 됩니다.
이건 일반 프로그래머가 사용하기 위해서 제공되는 것이 아니고 파이썬이 제공하는 built in func들이 이 클래스를 다룰 때 호출을 하는 함수가 됩니다.

예를 들어서 len이라는 내장 함수, built in 함수가 있지요.
무엇이었지요?
우리가 지금까지 많이 사용을 해 본 것인데 이 len 함수 안에다가 string을 넣으면 string을 이루고 있는 글자의 수를 리턴을 해 주지요.

그 len 안에다가 list를 넣으면 그 list 안에 들어있는 항목, 아이템들을 몇 개인지 개수를 리턴을 해 주지요.
tuple도 마찬가지이고.
그런데 len이 integer나 plot에 대해서 그 길이를 말해줄 수 있었던가요?
그건 됩니다.

왜 그러냐 하면 우선 len을 호출을 하면 그 len은 argument로 주어진 객체의 유형이 무엇인지 보고 그 객체의 유형에 따라서 그 객체 유형, 즉 객체 클래스가 가지고 있는 __len__라는 특수 함수를 호출을 합니다.

str.__len이라는 것은 바로 글자를 하나하나 집어넣어서 카운트 하는 기능을 가진 함수가 되는 것이고 list._len이라고 하는 것은 그 list 속에 있는 항목들, 덩어리들을 헤아려서 그 숫자를 리턴을 해 주는 기능을 하는 것이니까 내장 함수 len은 동일한 모양이지만 거기에 들어가 있는 객체 유형에 따라서 제각기 다른 의미의 숫자를 내주게 되는 것이지요.
이런 일들을 할 수 있도록 이렇게 특수 속성이 존재하게 되는 것입니다.

그다음에 클래스 데이터 속성이 있고 또 클래스 메소드 속성이 있습니다.
클래스의 지역 이름 공간에 등록된 데이터 객체를 데이터 속성이라고 하고 또 지역 이름 공간에 등록되어 있는 함수 객체를 메소드 속성이라고 이야기합니다.

이제 클래스 객체에 대해서 이야기를 해 보겠습니다.
조금 전에는 클래스에 대해서 이야기를 했는데 그리고 클래스의 정의에 대해서 이야기를 했습니다.
그 정의 과정을 통해서 생겨난 것이 바로 클래스 객체입니다.
클래스라는 일반적인 개념의 설명을 먼저 드렸고 이제는 클래스 객체라는 것에 좀 더 구체적인 설명을 드리는 순서가 된 것입니다.

클래스 객체의 역할은 클래스 객체는 속성, 참조와 클래스의 실체화를 지원하는 것입니다.
속성 참조라 함은 파이썬에서 사용되는 모든 객체의 속성, 참조와 동일한 구문 구조를 따릅니다.
조금 전에 말씀드렸기 때문에 설명은 크게 드리지 않겠습니다.
attr-qualifier, attr-name을 점으로 연결한 구조이다.
그리고 attr-qualifier는 obj-name이라든지 class name이라든지 module name이 들어올 수 있다.
이미 말씀드린 거지요.

그다음에 property는 클래스 데이터 속성과 메소드 속성을 동시에 가지고 이것은 데이터에 대한 액세스를 제한하는 데 사용됩니다.
그리고 이 클래스에 대한 일종의 backward portability 또는 backward 역방향의 호환성을 보장하는 용도로써도 이 property를 자주 사용하게 되고 이 property를 잘 사용하느냐 못하느냐에 따라서 좋은 프로그램을 할 수 있느냐, 없느냐 하는 것도 판가름이 나게 됩니다.

이제 클래스 실체화에 대해서 보겠습니다.
조금 전에 클래스 객체는 클래스 실체화를 지원한다고 했는데 이 클래스 실체화는 무엇인가.
클래스 실체화는 말 그대로 이 그 클래스의 속성을 가진 객체를 만들어내는 것입니다.

클래스 실체화는 클래스 객체를 실행하여서 실체화 된 객체, 좀 말이 좀 복잡하기는 한데 instance object를 생성하는 과정을 수행하는 것입니다.
이 클래스 실체화는 바로 클래스 객체 함수 호출 방식으로 이루어지게 됩니다.

그 밑에 구문을 보시면 class-instantiation이라는 것은 class-name을 바로 argument를 주면서 함수 호출하듯이 사용을 하고 거기에서 리턴 되는 참조를 왼쪽에 있는 이름으로써 받아주는 것이라는 것을 이 문법 체계는 이야기를 하고 있습니다.

이때 argument는 <class-name>.__init의 파라미터에 의해서 결정이 될 수가 있습니다.
그리고 클래스 실체화 함수, class name이 실행되면 메소드 속성에서 그 <class-name>.__init가 있는지 검색해서 실행해 줍니다.
없으면 실행 안 하면 그만이고요.
이건 옵션입니다.
이 __init에 대한 역할은 나중에 실습 시간에 조금 접해보시면 그 기능과 역할에 대해서 좀 더 분명하게 이해하실 수 있게 될 것입니다.

이 객체 동적 변형에 대해서도 말씀을 드려야겠네요.
파이썬 코드의 실행 과정에서 클래스 객체의 속성을 추가하거나 삭제를 할 수 있다, 그렇게 함으로써 객체의 내부적인 속성을 변경할 수 있다는 것을 가능하다는 것입니다.

이제 조금 전에 말씀드렸던 클래스 객체로부터 생성이 된 실체, 객체에 대해서 말씀을 드리겠습니다.
또 비교해서 말씀을 드리지만 자바라든지 C++에서는 클래스에 의해서 generation 된 object 그 자체가 지금 파이썬이 이야기하는 instance object, 즉 실체 객체가 되는 것입니다.
실객체, 체 체를 두 번 연속하면 발음하기도 나쁘고 어감도 이상하니까 실객체라고 이야기를 할 수도 있습니다.

역할은 클래스 객체를 구체화 하여서 파이썬 코드가 직접 액세스하고 사용할 수 있게 한 객체가 됩니다.
컴퓨터의 하드웨어 자원을 직접 사용해서 형성이 됩니다.
메모리도 사용해야 하고 이것이 수행되려면 CPU도 그때그때 사용이 되어야 하는 것입니다.

클래스와 객체 그리고 클래스 객체와 실체 객체의 관계는 뭐가 될까.
실체 객체의 기본 형태를 만들기 위한 하나의 몰드, 즉 형틀의 역할을 한다, 거푸집의 역할을 한다고 할 수 있습니다.
클래스도 객체는 객체인데 존재하는, 실제로 존재하는 객체입니다.
메모리에 등록은 되어 있습니다.
등록되어 있지만 실체 객체와 같이 그렇게 바로 코드를 실행할 때 사용하는 목적은 아니고 하나의 레퍼런스로서 기준으로 존재하는 객체가 되는 것입니다.

제가 객체라고 이야기한 것, 또는 파이썬의 객체라고 한다는 것은 그 클래스에 대한 정보가 실제 메모리에 기록이 되고 등록이 되어 있다는 것을 뜻합니다.
그래서 클래스 객체라고 또 이야기하는 것이지요.

이런 클래스 객체는 실체 객체의 기본 형태를 만들기 위한 거푸집의 역할을 한다.
그리고 실체 객체 역시 동적으로 변형을 시킬 수 있습니다.
파이썬 코드가 실행하는 과정에서 객체의 속성을 추가하거나 삭제함으로써 실체 객체의 형태를 변형시킬 수 있습니다.
이제 메소드 객체에 대해서 말씀을 드리겠습니다.
지금까지는 큰 틀에서 클래스 또는 클래스에 의해서 만들어지는 오브젝트의 개념으로 말씀을 드렸고 이제 클래스를 구성하는 구성 attribute 중에서 method attribute에 대한 객체에 대해서 말씀을 드리는 것입니다.

메소드 객체의 정의는 클래스의 메소드로 정의된 속성 개체가 되는데 모든 메소드는 하나 이상의 파라미터를 가지도록 정의되고 제1파라미터는 항상 self라는 이름으로써 지정이 됩니다.
이건 자동적으로 부여해주는 것입니다.
그리고 함수와 같이 방법으로 호출을 하여서 실행을 합니다.

메소드 객체의 문법은 위에 맨 위를 보시면 method-object-name이라는 것은 instance-object-name.
method-name으로 구성되고 또 method-call-statement는 어떻게 구성이 되는가.
메소드를 호출하는 구문은 어떻게 구성이 되는가.
이것은 instance-object-name.
method-name에 괄호 열고 argument를 주면 된다는 것입니다.

또는 class-name.
object-name에다가 또 괄호 열고 instance-object-name과 argument를 함께 주면 된다 하는 것입니다.
실체 객체로부터 메소드 객체를 호출할 수도 있는 것이고 또는 클래스 객체로부터 메소드 객체를 호출할 수 있는 두 가지 방법이 있다는 것은 이 문법에서는 보여주고 있는 것입니다.

메소드 객체 중에서는 특수 메소드 객체가 몇 개 있다고 말씀을 드렸지요.
그중에서 대표적인 것이 조금 전에도 말씀드렸던 __init__입니다.
이것은 클래스 실체화 과정에서 속성을 정의하고 이름 공간을 구성하는 용도로 주로 사용이 됩니다.

또 이 __init__는 옵션이니까 전혀 사용하지 않아도 상관없습니다.
그렇지만 기본적으로 모든 클래스의 베이스가 되는 것이 오브젝트라고 하는 클래스가 있습니다.
여기에는 비어있는 형태로 이 init 메소드가 정의는 되어 있습니다.
이런 init는 항상 존재는 하지만 사용하고 안 하고는 클래스를 설계하는 분의 마음에 달린 것이지요.

iter라고 하는 메소드와 next라고 하는 메소드는 두 개가 합쳐서 이 클래스를 iterable하게 만들어주는 메소드가 됩니다.
이런 iter나 next method가 동작을 할 수 있도록 채워져 있다면 바로 for loop라든지 주로 for loop를 통해서 iterables 하게 클래스에서 제작된 실객체를 iterable로써 사용을 할 수 있게 하는 것입니다.

상속에 대해서 알아보겠습니다.
inheritance.
이것을 클래스의 전문화 또는 클래스 파생 또는 custom class generation 등 여러 가지로 이야기할 수 있는데 클래스의 전문화, 좀 더 스페셜 하게 만든다는 것으로 의미를 표현하겠습니다.
클래스의 전문화는 다른 클래스의 속성과 메소드를 받아들여서 새로운 클래스를 정의하는 것입니다.

이 전문화된 클래스, 즉 파생된 클래스는 또 subclass라고 이야기하기도 하고 파생 클래스라고도 이야기합니다.
subclass의 직계 부모 클래스를 super class라고 이야기를 하고 또는 base class라고도 이야기합니다.

클래스 전문화 과정에서 서브 클래스의 새로운 데이터나 메소드 속성을 추가함으로써 customize 하는 것이지요.
그리고 상속 받은 데이터나 메소드 속성을 오버라이드 해서 그 내용을 변경시킬 수도 있습니다.
특히 메소드를 오버라이드 한다는 것은 베이스 클래스에서 정의되어 있는 코드들을 전부 걷어낼 수도 있고 새로운 코드로서 내 코드로서 집어넣을 수도 있는 것입니다.

그렇게 함으로써 클래스, 파생 클래스라든지 전문화 된 클래스를 자기만의 것으로 customize 할 수 있는 것이지요.
이런 과정이 클래스의 전문화 과정에서 일어나게 되는 것이고 그런 클래스 전문화 과정을 지원하고 받쳐주는 것이 바로 상속이라고 하는 개념이 되는 것입니다.

이 클래스 상속 구문 문법은 클래스 키워드 그다음에 derived-class-name 즉 파생 클래스 name이 있고 <base-class-name>를 주면 되는 것입니다.
그렇게 하면 base-class로부터 derived-class로 그 속에 있는 내용들이 전부 상속이 되는 것입니다.

그러고 나서 class suite를 통해서 새로운 속성을 추가하기도 하고 기존에 상속 받은 그 속성들을 변경시키기도 하는 일이 class suite 안에서 일어나게 되는 것입니다.
base-class-name이라는 것은 base-class-name 또 base-class-name 이렇게 여러 개의 base-class-name들이 나타날 수 있습니다.
이것은 무엇을 의미하는가요?

바로 상속을 받을 때 하나의 base-class만으로부터 상속을 받을 수 있는 게 아니고 두 개 이상의 여러 클래스로부터도 상속을 받을 수 있다 하는 것입니다.
다중 상속을 받을 수 있다 하는 것입니다.
그렇게 되면 base-class1, base-class2가 있다면 1, 2가 가지고 있는 모든 속성을 다 가지고 오게 되는 것이지요.

이 조금 전에 말씀드렸던 상속 과정 중에 메소드의 오버라이드라는 것은 베이스 클래스로부터 상속한 메소드의 코드를 변경하는 것입니다.
베이스 클래스 메소드를 호출하여서 이용할 수도 있습니다.

서브 클래스 내부에서 베이스 클래스 메소드 호출 구문 문법을 보면 클래스 헤더가 있고 derived-class, base-class가 나오지요.
그 class suite 중간에 definition을 하는데 method-name을 definition을 합니다.
이 method-name은 바로 베이스 클래스가 가지고 있는 method-name과 동일한 것이면 바로 이때부터 오버라이드가 일어나게 되는 것입니다.
그 안에서 혹시 오리지널 메소드를 사용하고 싶다.
이럴 때는 슈퍼를 사용한다든지 또는 base-class-name.
method name으로 그 베이스 클래스가 가지고 있는 그 객체가 가지고 있는 메소드를 직접 레퍼런스를 해서 호출을 하는 것을 통해서 이 베이스 클래스의 오리지널 메소드를 호출해서 원래 기능을 또 사용할 수 있습니다.

이렇게 이 구문 자체가 derived, 즉 파생 클래스 안에서 method-name이라는 메소드를 변경시키는 과정 중에 이렇게 변경된 메소드 말고 오리지널 메소드가 혹시 필요할 때는 슈퍼 키워드를 사용한다든지 그렇지 않으면 base class.method-name 형태로서 오리지널 메소드를 호출해서 사용할 수 있다는 것을 보여주고 있습니다.

이제 프로퍼티에 대해서 알아보겠습니다.
프로퍼티는 조금 전에 말씀드리기를 데이터 속성과 메소드 속성을 함께 가진 이상한 속성이라고 말씀을 드렸지요.
이 내장 클래스 프로퍼티의 객체 생성 구문 문법을 사용하면 됩니다.

즉 프로퍼티라고 하는 것은 파이썬이 제공하는 built in 클래스인 것입니다.
일종의 built in 데이터 유형이라고 볼 수 있지요.
프로퍼티라고 하는 데이터 유형을 클래스 안에서 사용하면 프로퍼티 속성, 클래스의 프로퍼티 속성이 되는 것입니다.
property object는 프로퍼티라는 그 클래스 이름과 함께 괄호를 열고 getter, setter, deleter 그다음에 docstring이라고 하는 파라미터에 대한 argument를 부여를 함으로써 property attribute object를 만들어낼 수 있다는 것을 이 문법 구조에서 이야기하고 있습니다.

그리고 전부 다 대괄호로 둘러싸여져 있지요.
얘네들은 전부 기본값을 가지고 있습니다.
getter나 setter나 deleter 등은 다 기본값을 뭐로 가지고 있냐 하면 none으로 가지고 있습니다.
아무것도 아니라는 none으로 가지고 있어서 만일 getter를 특별하게 지정하지 않으면 그냥 아무 getter는 동작을 안 하는 none에 해당하는 동작을 하겠지요.
None operation을 동작을 할 것입니다.
이런 옵션에 argument를 가지고 프로퍼티 객체를 만드는 것입니다.

getter는 데이터 속성값을 읽어내는 메소드 속성이 되는 것이고, 즉 메소드에 해당하는 주소 레퍼런스가 이 getter를 통해서 할당되는 것입니다.
그다음에 setter는 데이터 속성값을 세팅하는 지정하는 또는 assign하는 메소드 속성이 됩니다.

deleter는 데이터 속성을 삭제하는 메소드 속성이 되는 것이고 docstring은 데이터 속성에 대해서 주성문을 지정하는 메소드 속성이 되는 것입니다.
여기에서 메소드 속성이라고 하는 것은 바로 어떤 메소드에 대한 identifier라고 볼 수 있습니다.
이런 것들을 전부 이 argument로 줌으로써 property object가 형성이 되는 것입니다.

프로퍼티 정의 구문 문법을 보겠습니다.
이 구문 문법 자체는 뒤에 우리가 실습을 할 때 그대로 사용되는 것이니까 조금 유의하셔서 보실 필요가 있습니다.
class definition 안에 init 메소드가 definition이 되어 있고 그 밑에는 getter, setter, deleter 또는 docstring 등이, docstring은 따로 없지요.

getter, setter, deleter 3개의 method attribute가 지금 definition 되고 있습니다.
여기서 getter, setter, deleter라고 하는 것은 바로 메소드 이름이라고 보시면 돼요.
여러분이 자유롭게 이름을 정해주실 수가 있습니다.
getter나 setter나 deleter, 메소드들의 argument는 self가 기본으로 들어갑니다.

그리고 필요한 argument가 그대로 주어지게 되면 되고 없으면 하나도 주지 않아도 상관없지요.
이런 상태로 정의가 됩니다.
그러고 나서 데이터 attribute는 프로퍼티라는 키워드를 가지고 이제 getter, setter, deleter, docstring으로써 property attribute가 정의가 되는 것입니다.

이런 프로퍼티 속성을 정의하는 구문 문법을 보기 위해서 지금 구문 문법이 두 가지가 있습니다.
하나는 문법 박스의 맨 밑을 보시면 property attribute는 프로퍼티라고 하는 클래스를 함수처럼 호출하고 있습니다.
그 안에서 getter, setter, deleter, docstring이라는 조금 전에 보셨던 네 가지의 argument를 주면서 호출을 하고 있지요.

이렇게 함으로써 property attribute 객체가 생성되는데 그전에 해야 할 일이 그 위에 보시면 getter, setter, deleter라고 하는 세 개의 메소드를 여러분이 정의를 해 주셔야 합니다.
만일 deleter를 쓰지 않으신다면 그 deleter에 해당하는 메소드는 여러분이 정의하지 않으셔도 됩니다.

그러면 None이라는 값으로 들어가겠지요.
또 setter도 마찬가지입니다.
getter도 마찬가지이고.
이런 필요에 따라서 필요한 것만 여러분이 define을 해 주시면 되고 그 이름을 argument로서 프로퍼티 호출을 할 때 넣어주시면 되는 겁니다.

그러면 여기에 getter, setter 또는 deleter라고 하는 bnf variable들에는 여러분이 자유롭게 메소드 이름을 적절하게 지정해서 넣어주시면 되는 부분이 되는 것입니다.
이런 부분이 property class generator를 이용한 방법의 문법이 되는 것이고요.

그다음 페이지는 데코레이터를 사용하는 방법이 있습니다.
이 데코레이터라고 하는 것은 파이썬뿐만 아니라 현대의 프로그래밍 언어에서 자주 사용하는 것인데 일종의 매크로와 같은 의미를 가진 것을 뜻합니다.
그런 파이썬에서는 @ 마크가 앞에 붙어있으면 그 앞에는 프로퍼티라고 하는 속성이 계속 붙어 따라다니는 그런 데코레이터의 역할을 하는 것입니다.

그 중간쯤에 보시면 @property라고 하는 문자열이 나타나고 있지요.
그러고 나서 def가 나오고 data attribute 그다음에 self 해놓고 여기 args가 주어지고 그다음에 그 definition의 바디에 들어가 보면 suite를 보면 docstring이 나올 수 있고 그다음에 return “self.” <private-data-attribute>라고 해서 별도의 데이터 attribute 말고 private-data-attribute를 따로 지정을 해놓고 있습니다.

이렇게 하면 위에 있는 definition 헤더에 있는 data attribute라고 하는 것이 바로 프로퍼티의 속성을 가진 property attribute는 변경이 되는 것입니다.
이름은 지금 처음 지정된 것은 data attribute라는 것으로 지정이 되었지만 이제 그 밑에서 정의가 되는 setter라든지 deleter의 메소드 속성까지 함께 가지고 있는 프로퍼티 속성으로서 실제 속성이 변경이 되어서 사용이 되게 되는 것입니다.

그다음에 밑에 데코레이터에서는 이제 data attribute는 이미 프로퍼티라는 속성으로 되어있기 때문에 그 속성을 또 그대로 데코레이터로 사용을 할 수가 있습니다.
그래서 @를 붙이기만 하면 바로 그러고 나서 .setter를 하면 setter에 대한 속성이 밑에 정의 되는 함수의 suite가 그대로 지정되는 것입니다.
그 suite는 어떤 suite인가 보면 "self." <private-data-attribute>의 right hand side name을 assign하는 것이지요.
바로 세팅을 해 주는 것입니다.

그 값을 받아들이는 구문을 실행을 하는 메소드로서 이 <data-attribute>".setter"가 동작하는 것입니다.
그리고 <data-attribute>".deleter는 말 그대로 이 항목을 프로퍼티, data-attribute라는 것을 이 클래스에서 삭제를 시켜주는 역할을 하게 되는 것이지요.

이렇게 함으로써 이 데코레이터를 사용해서 주어진 어떤 attribute를 property attribute로 만들어서 우리가 사용할 수 있고 이 property attribute에 데이터를 세팅을 할 때에는 우리가 원하는 대로 제한을 두어서 값도 한번 범위에 맞는지 체크도 해 보고 그다음에 이것이 이상한 값인지 제대로 정당한 값인지도 체크를 하면서 좋은 값 또는 정당한 값일 때에만 세팅이 되도록 하는 일종의 필터를 만들어서 setter에다가 둘 수도 있는 것입니다.

또는 getter에다가 둘 수도 있는데 그 getter에서는 무조건 리턴을 하는 것이 아니고 사용자 또는 호출자의 프리빌리지 특권을 검사해서 그 프리빌리지가 이 데이터를 읽을 수 있는 권한인 수준에 맞는 것인지 검토를 해서 그 권한 수준에 맞을 때에는 리턴을 해 주고 그렇지 않을 때는 방지를 하는 이런 여러 가지 보안상의 필터링을 할 수도 있고 또는 이 값의 정확성이라든지 또 의미에 대한 부합성이라든지 모든 것들을 다 체크를 한 다음에 데이터를 입출력을 할 수 있도록 하는 그런 용도로서 이 데코레이터를 사용할 수 있는 것입니다.

지금까지 우리는 이름부터 시작해서 이 파이썬의 객체 지향성을 구성하는 모든 개념들에 대해서 살펴보았습니다.
아직도 수많은 개념들이 또 있기는 하지만 그래도 이 파이썬에서 필요로 하는 아주 중요한 개념들을 살펴보았다고 할 수 있고 이런 개념을 다음 실습 시간에 좀 더 확실하게 구체적으로 습득할 수 있도록 해 보겠습니다.
</data-attribute></data-attribute></private-data-attribute></private-data-attribute></base-class-name></class-name></class-name>
