-------------------------------------------------------------
11_03. 클래스 다루기
-------------------------------------------------------------

[3페이지]

방금 강의를 통해서 다루어 보았던 이름 그리고 클래스에 대해서 코딩을 통해 실습을 하겠습니다.
jupyter를 띄우겠습니다.
이제 파이썬 프로그램 디렉터리로 가서 새로운 디렉터리를 하나 만들어야지요.
폴더를 열고 이름을 바꾸겠습니다.

이번 차시의 이름에 해당하는 이름을 두겠습니다.
들어가서 노트북을 생성해야지요.
그 노트북의 이름도 역시 이번 차시와 관련된 이름으로 바꾸겠습니다.
일련번호 1을 줬습니다.
이름에 대한 테스트를 하는 코드를 만들어보도록 하겠습니다.

함께 코드를 보겠습니다.
프로그램을 보시면 scope_test를 전역 name scope 상에서 정의를 하고 있습니다.

즉 함수 이름은 scope_test는 현재 열려있는 모듈의 전역 이름이 되는 것이지요.
그러니까 global name이 되는 것입니다.
그 안에 3개의 로컬 함수를 정의하고 쭉 순차적으로 내려가면서 자신의 로컬 객체인 메시지, 로컬 이름인 메시지라는 이름을 가진 객체를 생성을 시키고 있습니다.

test message라는 값을 배정을 함으로써 새로운 객체를 생성시키고 do_local을 수행하고 그 결과를 print로서 출력합니다.
즉 메시지에 어떤 내용이 들어있는지가 궁금한 것이지요.
do_nonlocal이라는 함수를 수행한 다음에 또 메시지가 어떻게 변했는지 그다음에 do_global이라는 함수를 수행한 다음에 또 메시지를 수행하고 있습니다.

지금 이 3개의 print문이 레퍼런스를 참조하는 메시지라는 것은 바로 자신의 로컬 객체인 메시지라는 객체에 대한 것입니다.
여기에 처음에는 test message라는 문자열을 줬는데 그럼 이 메시지를 print 했을 때 test message가 계속 3번 나올까요?
그렇지 않으면 뭔가 변해서 나올까요?
그걸 확인해 보고자 하는 것입니다.

그 메시지에 들어있는 메시지라는 객체 들어있는 값은 누가 변화시킬까요?
앞에서 정의된 3개의 로컬 함수에서 그 작업이 일어날 수가 있는 건데 우선 첫 번째 do_local이라는 하는 함수 안을 들어가 보겠습니다.

역시 메시지는 로컬 메시지라고 local message라고 하는 그 값을 하나의 객체 이름을 가진 객체에 메시지라는 이름을 가진 객체에 배정을 하고 있습니다.
이때 do_local 함수 내부에서는 지역 변수가 우선 최우선적으로 검색이 되기 때문에 만일 그때 지역 변수가 없으면 그리고 아무런 메시지를 가진 변수가 나타나지 않았으면 지역 변수 하나를 새롭게 만드는 것입니다.
이 do_local 안에서 만들어지는 메시지라는 객체는 바로 지역 이름을 가진 객체가 되는 것입니다.

이제 do_nonlocal이라는 함수 내부로 들어가 보겠습니다.
nonlocal message라고 하는 nonlocal 구문이 나타나고 있습니다.
이 뜻은 메시지라는 것은 자신의 local name이 아니다, 로컬 객체가 아니라는 것을 선언을 하고 있는 것입니다.

그러면 이 메시지는 무엇이 되는 걸까요?
바로 이 scope_test에 scope, 그 함수의 scope, 즉 이런 scope는 이런 scope지요.
여기에서 이런 데가 이 함수 scope가 됩니다.
그 scope에서 정의가 된 메시지라는 객체를 지금 내가 쓰고 있는 것이라고 선언을 한 겁니다.

이때는 nonlocal message라는 string을 message라는 이름을 가진 객체에 assign을 하면 새로운 로컬 객체가 생길 필요가 없지요.
이미 message라고 하는 enclosing 객체가 존재하는 것을 참조를 한 것이기 때문에 바로 scope test, 그 안에서 정의된 이 메시지 안으로 nonlocal message가 들어오는 것입니다.
처음에는 test message가 있었지만 그다음에는 이 함수가 수행된 다음에는 nonlocal message가 들어와 있게 되는 것이지요.

do_global 함수 속으로 들어가 보겠습니다.
여기에 global 구문이 있습니다.
message라는 이름을 가진 객체가 그 이름이 message라는 이름이 global name이라고 하는 것을 선언하는 것입니다.
그러니까 이 message는 local도 아니고 enclosing도 아니고 바로 global이다.
그 global 이름을 가진 객체에 global message라고 하는 string을 지금 assign한 것입니다.

그런데 이 scope 전체를 놓고 봤을 때 이 message를 global에서 선언하는 정의를 하는 부분이 없습니다.
그러니까 이 과정에서 바로 message라고 하는 global 이름을 가진 객체가 하나 생성되는 것입니다.
새롭게 생성되는 것입니다.
이런 기능을 하는구나, 라고 여러분이 한번 보신 것입니다.

수행하는 과정 전체를 실행시켜보겠습니다.
실행을 시켰습니다.
After local assignment test message라는 것은 어디에서 나온 것일까요?
바로 첫 번째 print문에서 나온 것이지요, After local assignment.
이 메시지 안에는 뭐가 들어가 있을까요?
바로 이 test message가 들어있습니다.

do_local을 수행해 보아도 그 do_local에서는 자신의 local object의 local message라는 string을 넣었으니까 그 scope test 함수에서 정의한 이 메시지라는 이름을 가진 객체와는 관계가 없습니다.
그 값이 변화가 없이 그대로 테스트 메시지가 다시 나타난 것이지요.

그다음에 After nonlocal assignment를 수행한 다음에는 바로 이 scope 테스트 함수에서 정의한 메시지가 메시지 객체가 이름이, 내용이 바뀐 것입니다.
뭐로?
nonlocal message로 바뀐 것입니다.
또 After global assignment를 한 다음에는 nonlocal message가 그대로 남아있지요.

왜 그러냐 하면 do global에서는 이 메시지를 건드리지 않았기 때문에 그렇지요.
어딘가에 있는 전역 global name을 가진 객체를 assign을 한 것이기 때문에 enclosing name scope에 들어있는 메시지라는 이름을 가진 객체는 건드리지 않은 것입니다.

그 값이 그대로 남아있겠지요.
즉 앞에서 변경을 시켜놓은 nonlocal message라는 내용이 그대로 또 한 번 나타나게 됩니다.
이제 최종적으로 전역 scope로 나아가서 전역 scope에서 객체를 이름을 찾아서 레퍼런스를 해서 그 내용을 찍어보았습니다.
그랬더니 global message라고 하는 string이 나타났습니다.

그것은 어디에서 들어오게 되었냐 하면 do_global을 수행시킬 당시에 들어온 것입니다.
어디에?
메시지라고 하는 global name을 가진 이 객체 안으로 들어오고 또 global scope에서 print를 하면 당연히 global name을 가진 객체를 액세스 하게 되므로 그 내용이 그대로 global message라는 내용이 나타나게 된 것입니다.

이렇게 그렇게 길지 않은 코드이기는 하지만 이 한 덩어리의 프로그램 조각을 가지고 앞 시간에 우리가 좀 긴 시간을 할애해서 이야기를 드렸는데 그 내용을 이 프로그램 코드로서 설명을 드렸습니다.
그다음에는 클래스를 정의하고 실체화하는 예를 살펴보도록 하겠습니다.
코딩이 되었습니다.
코드를 함께 보시기 바랍니다.
class MyClass를 통해서 새로운 MyClass라는 이름을 가진 클래스를 정의하고 있습니다.
이때 이 클래스 이름 바로 다음에 콜론이 오고 있기 때문에 베이스 클래스가 보이지 않고 있지요.
그렇지만 디폴트로 이 앞에 바로 오브젝트라고 하는 베이스 클래스가 있다고 생각을 하셔도 좋습니다.

이 오브젝트라는 이름을 가진 클래스는 파이썬이 제공하는 built in 클래스입니다.
사용자 프로그래머.
즉 프로그래머가 보는 관점에서는 이 MyClass라는 것이 하나의 자기 기준에서는 베이스 클래스가 되겠지만 그러나 실제로 이 파이썬 관점에서 봤을 때는 오브젝트의 파생 클래스라는 것이고 이 오브젝트 클래스가 하는 일은 클래스로서 갖춰야 하는 아주 기본적인 데이터라든지 메소드 속성들을 제공하는 역할을 해 주는 것입니다.

이렇게 이 MyClass라는 이름의 클래스가 생성되었는데 역시 모듈에서 최상위에서 정의되고 있기 때문에 MyClass는 전역 이름 공간에 속해있는 이름을 가진 클래스입니다.
그리고 그 밑에는 docstring이 나오고 있고 i는 100을 통해서 i라는 이름을 가진 data attribute 객체에 100이라는 값을 지정해서 생성해놓고 있습니다.

그다음에 def f를 통해서 f라는 이름을 가진 메소드 속성을 정의하고 있고 그 하는 일을 봤더니 단순하게 hello world라고 하는 string을 리턴하는 기능을 하고 있음을 볼 수 있습니다.
여기까지가 MyClass를 정의하는 구문의 전체입니다.

이제는 다시 global 영역으로 나아가서 print 또 X는 0, MyClass f(x) 그다음에 print MyClass.i라는 구문을 실행을 시켜보도록 하겠습니다.
어떤 결과가 나올지 일단은 설명을 먼저 드리겠는데요.
이 dir MyClass라고 하는 것은 MyClass 안에 있는 속성들을 이름을 모두 list up 하는 것입니다.

그리고 MyClass.f(x)라고 하면 x를 하나 생성시켜서 집어넣었지요?
왜 이런 일을 했을까?
왜냐하면 f는 최소한 하나의 argumnet를 필요로 하기 때문에 이런 불필요한 일을 한 것입니다.
그리고 MyClass.i라는 것을 통해서 MyClass가 가지고 있는 data attribute에 액세스를 했습니다.
그 값을 print를 하는 거지요.

결과가 어떤지 run을 통해서 보겠습니다.
이제 dir(MyClass)의 내용을 보니까 처음 __Class라는 attribute부터, 거기부터 시작해서 새롭게 생성을 한 i라는 attribute와 f라는 이름을 가진 attribute가 그 이름이 여기에 나타나고 있습니다.

이 do 이름을 가진 do attribute를 가진 클래스라는 것을 우리가 확인할 수 있겠고요.
또 Class i라고 하는 것은 어떤 역할을 하는가 봤더니 100이라는 값을 집어넣어줬습니다.
그러면 여기에 hello world가 나와야 하는데 그게 안 나왔네요.
제가 print를 넣지 않고 뺐기 때문에 그런데 그래서 뒤에 나오는 100이라는 값에 출력이 가려져서 안 나오게 된 거지요.

run을 다시 시켰습니다.
그리고 hello world가 튀어나오게 된 깁니다.
그다음에 만일 이 x를 주지 않고 비어있는 상태로 MyClass.f를 호출을 하면 어떻게 될까요?
이럴 때에는 TypeError가 발생하게 됩니다.
원래 f라는 이 메소드는 최소한 하나의 그 argument를 필요로 하는데 그 argument가 지금 주어지지 않았다는 것입니다.

그래서 여기에 self라고 지금 파라미터가 지정되어 있는데 그걸 거기 해당하는 argument로 주지 않았다는 거지요.
그리고 x를 임의로 만들어서 줬는데 x를 주지 않더라도 여기에 x는 필요 없고 0라는 tricking 한, 즉 뭔가 속이는 듯한 그런 값을 줘서 얼렁뚱땅 넘어가보도록 하겠습니다.

이렇게 해도 이 파이썬 인터프리터는 구별하지 않습니다.
재료가 들어왔든 뭐가 들어왔든 어떻든 요구하는 숫자만큼의 argument가 들어왔으므로 일단 실행을 시켜 줍니다.
다행히 이 안에서는 self라고 하는 argument를 활용하는 구문이 없으므로 0를 주거나 뭘 주거나 별 문제가 일어나지 않는데 만일 이 argument를 사용한다면 이렇게 해서는 안 되겠지요.
하여튼 오류 없이 일단 코드는 돌기는 돌았습니다.
그래서 hello world가 나왔고 100이라는 숫자가 나왔습니다.

이렇게 여러분이 이 코드를 통해서 또 실행 과정을 통해서 보신 것은 하나의 클래스가 정의가 되었고 그 클래스에 data attribute 또 method attribute들이 액세스를 해서 동작을 하는 과정이라든지 값을 내놓는 과정을 지켜보신 것입니다.
다음에는 이런 클래스 객체로부터 인스턴스 객체를 만들어내는 과정을 코드를 통해서 또 보도록 하겠습니다.

코드를 보시면 굉장히 간단하지요.
조금 전에 정의했던 MyClass라는 이름을 가진 클래스를 괄호를 붙여서 함수처럼 호출을 시켜주면 바로 그 클래스 객체에 대한 인스턴스 객체가 생성이 되고 그 레퍼런스를 mc라는 이름으로 받은 것입니다.

이제 mc라는 레퍼런스는 MyClass로부터 생성된 인스턴스 오브젝트에 대한 레퍼런스가 되는 것인데 f라는 함수를 실행을 시켜보겠습니다.
그리고 i라는 함수, mc라는 함수를 mc.i 또 mc라는 오브젝트 안에 있는 여러 속성들을 들여다보도록 하겠습니다.
dir을 통해서 들여다보는 것이지요.

실행을 시켜보겠습니다.
그런데 잠깐, 여기에서 f라는 메소드를 호출을 하는데 argument를 준 게 없네요.
앞에서 조금 위로 올라가 보실까요?
우리가 왜 굳이 여기서 0이라는 값 또는 x라는 값을 줬을까요?
이 f라는 메소드가 정의될 때 보니까 self라는 하나의 파라미터가 있다.
그래서 하나 이상의, 하나의, 하나 이상이어도 안 되지요.

하나의 argument를 받아야 하는데 안 줬더니 오류가 나타났던 것이지 않습니까?
그런데 여기는 주지 않았어요.
과연 이게 돌까요?
한번 실행을 시켜서 확인해 보겠습니다.
문제없이 돌았습니다.
이것은 왜 그럴까요?
여기에 self라고 하는 것은 바로 인스턴스 객체 그 자신을 이야기하는 것입니다.

그래서 이 MyClass라는 단계에서는 인스턴스 객체가 없는 상태이기 때문에 self를 줄 수가 없어요.
그래서 외부에서 강제적으로 self 대신에 어떤 한 argument를 줘야지 통과되는 것입니다.
그런 점이 다른 점이 되는 것이지요.
그리고 이 mc를 통해서 f를 호출했을 때는 이 mc 자체가 인스턴스 객체이기 때문에 mc 스스로 f1으로 들어가게 되는 것입니다.

self라는 것은 그런 뜻을 가지고 있거든요.
인스턴스 오브젝트 그 자신이라는 것을 뜻하고 있습니다.
MyClass, 클래스 시절에는 인스턴스 객체가 형성되지 않은 때이기 때문에 여기에 argument로 줄 만한 게 없어서 오류가 나타난 거지만 일단 인스턴스 객체가 생성된 다음에는 self 대신에 그 객체에 대한 아이디를 주면 되니까 문제없이 통과된 겁니다.

결과를 보니까 역시 hello world라는 일을 했고 100이라는 데이터 값을 내놨고 그다음에 클래스라는 항목부터 f와 i까지 보니까 이 mc가 가진 attribute의 항목들이나 또는 MyClass가 가진 이 attribute의 항목들이 완전히 동일하다는 것을 알 수 있습니다.
아직은 변경을 시키지 않았으니까 동일하겠지요.

그런 상태를 지금 확인했습니다.
그리고 다시 한번 말씀드리지만 In7, In8 이 두 셀은 앞에도 마찬가지지만 이런 모든 셀들은 모두 한 모듈로 통합되어 있는 셀들이라는 것이고 이 안에서 정의된 global name들은 그 scope는 전부 모든 셀들에 걸쳐서 형성되어 있다는 것을 다시 한번 말씀드린 것입니다.
지금까지는 jupyter를 그렇게 숱하게 사용을 했지만 이런 말씀을 드리지 않았는데 이번 차시에는 우리가 name을 다뤘기 때문에 이런 이야기를 또 드리는 것입니다.

이제 클래스 데이터 속성 생성 과정에 대해서 몇 가지 살펴보도록 하겠습니다.
첫 번째는 이 클래스를 처음 정의하는 과정에서 __init 메소드를 통해서 데이터 속성을 생성하는 방법에 대해서 살펴보겠습니다.

먼저 코딩을 입력하겠습니다.
코드를 한번 보시면 앞에서 다뤘던 MyClass와 조금 다른 새로운 클래스를 생성시키고 있습니다.
바로 처음에는 init 메소드, __init__ 메소드를 정의하고 있습니다.
그런데 이 init라는 메소드는 이미 우리 눈에는 보이지 않지만 오브젝트라고 하는 것이 하나의 베이스 클래스로 작용하고 있는데 이 오브젝트 클래스 속에 이미 들어있는 것입니다.

그런데 그것을 상속을 받아서 우리 나름대로 새롭게 지금 고치고 있는 것이지요.
그 코드를 새로 만드는 것입니다.
이걸 뭐라고 한다고 했지요?
이것이 일종의 오버라이드가 되는 것입니다.
상속 받은 메소드의 내용을 자기 나름대로 새롭게 고친다.
어떻게 고쳤나 보겠습니다.

self.r=realpart, self.i=imagpart, imaginary part인데 여기서 realpart, imagpart라고 하는 것은 어디서 오는 걸까요?
이 메소드의 argument 또 self 외에 또 다른 두 개의 argument로서 넘어오는 것입니다.
여기에서는 파라미터지요, realpart라든지 imaginary part라고 하는 것은 파라미터들의 이름이 됩니다.

그 속에 있는 argument를 assign함으로써 이 self 안에 r이라고 하는 이름을 가진 데이터 속성과 i라는 이름을 가진 데이터 속성을 생성을 시켜주는 것입니다.
그래서 이 클래스 콤플렉스를 통해서 인스턴스 오브젝트 실체화 된 객체를 생성할 때에는 처음 이 init 메소드, __init 메소드가 자동적으로 실행되어서 do attribute를 생성하게 되는 것입니다.

이때 콤플렉스 실체 객체를 만들 때에는 그 콤플렉스를 함수 형태로 부른다고 했는데 그 함수 형태로 부를 때 이 안에 들어있는 argument를 뭘 줘야 하지요?
self는 줄 필요가 없습니다.
이것은 자동적으로 객체, 실체 객체를 만들면서 그 실체 객체 레퍼런스를 자동적으로 self로서 부여를 하는 것이기 때문에 프로그래머가 줄 필요는 없는 것이고 여기서 필요한 것은 realpart에 해당하는 argument와 또 imaginary part에 해당하는 argument를 줘야 하는 것이지요.

2개의 argument를 줘야 하는 것입니다.
그리고 그러면 이런 객체 속에 클래스 객체 속에 있는 attribute들을 확인해 보기 위해서 먼저 콤플렉스 클래스 안에 있는 attribute를 살펴보고 그다음에는 c라고 하는 객체를 만들었습니다.

이 객체가 인스턴스 오브젝트라고 그랬지요.
그때 만들 때 두 개의 argument가 필요하니까 임의로 3.0이라는 소수와 -4.5라고 하는 부동소수점 소수를 제공했습니다.
그러고 나서 다시 c가 가진 attribute들을 dir을 통해서 표시를 해 본 것입니다.
그리고 이 r attribute와 i attribute를 어떤 값인지 표시를 해 본 것입니다.

실행을 해 보겠습니다.
이 쏟아놓은 attribute 수가 좀 많지요.
그래서 여러분의 강의 노트에는 처음과 끝 정도만을 표시했을 뿐이니까 이 중간 부분은 생략한 상태로 제공된 것입니다.
여기에 보시면 다 볼 필요는 없습니다.
중요한 것은 지금 쭉 보시면 여기까지 클래스 객체에 있는 attribute 이름들입니다.

그다음에 두 번째 나온 것이 바로 이 print dir c, 실체 객체인 c에 해당하는 attribute들의 리스트입니다.
한번 잘 비교를 해 보시면 끝에 있는 i하고 r이 i라는 이름과 r이라는 이름의 attribute 두 개가 더 추가되었음을 알 수 있습니다.
언제 추가된 거지요?

바로 이 실체 객체를 생성하는 과정에서 init 메소드가 실행됨으로써 r과 i의 realpart와 imaginary part가 assign 되면서 이 클래스에 해당하는 로컬 attribute들이 생성된 것입니다.
그리고 그 각각의 값은 여기에 배정되어 있는 대로 3.0과 -4.5가 배정되어있음을 확인할 수 있지요.

조금 전에 말씀드린 것은 지금 말씀드린 것은 이 클래스로부터 객체를 생성하는 과정에서 그 클래스에 이미 정의가 되어있는 attribute들을 생성하는 것으로서 데이터 attribute를 만드는 과정에 대해서 말씀을 드렸고요.

다음에 설명을 드리고자 하는 것은 이미 실체 객체가 만들어졌거나 또는 기존에 클래스 객체 속에 있는 attribute를 변경을 시키는 것입니다.
새로운 attribute를 생성한다든지 이미 있던 attribute를 삭제하는 과정은 가능할까?
그 가능성을 코딩을 통해서 확인해 보도록 하겠습니다.

코딩된 프로그램을 한번 같이 보기 바랍니다.
조금 이전에 우리가 생성해놨던 MyClass를 다시 지금 들고 나온 상태입니다.
아직 이 jupyter 노트북에서 MyClass가 전역 이름 공간에 남아있기 때문에 그대로 우리가 사용할 수 있지요.
이제 기억을 되살리기 위해서 앞으로 한번 쭉 가볼까요?
이 MyClass 안에는 어떤 attribute들이 있을까요?
i하고 f라는 이름의 사용자가 만들어놓은 attribute가 있음을 알 수 있습니다.
바로 여기 있지요.

이런 attribute 두 개만 있는데 여기에 또 하나 새로운 dynamic_data_attr라는 이름을 가진 데이터 attribute를 생성하겠다는 것입니다.
그 방법은 지금은 없지만 일단 attribute의 레퍼런스 name을 쓰고 이퀄 기호를 통해서 어떤 값을 배정하면 그 attribute 이름을 가진 데이터 attribute가 그 객체가 생성되는 것입니다.

이미 이 부분이 실행되었다면 dir을 통해서 과연 dynamic_data_attr가 생겼는지 확인할 것이고요.
그다음에 그 attribute가 가진 값을 확인하고 그다음에는 다시 삭제를 하는 과정을 거쳐서 삭제가 되었는지 또 dir을 통해서 확인하는 것입니다.
실행을 시켜보겠습니다.

attribute를 생성한 다음에 dir을 했더니 이렇게 dynamic data attribute가 들어있음을 알 수 있습니다.
그리고 값은 1000이 배정이 됐고 delete를 한 다음에 다시 dir을 통해서 확인해 보니 weakref와 f 사이에는 이 데이터 attribute, dynamic_data_attr가 있었는데 이제 사라졌음을 알 수 있지요.

이렇게 우리가 임의로 프로그램 코드를 실행하는 그동안에도 얼마든지 클래스 객체의 attribute를 변경할 수 있다는 것을 코딩을 통해서 확인을 했습니다.
이렇게 이런 속성은 C++라든지 자바에서는 볼 수 없던 그런 속성이 됩니다.

이런 속성은 어느 면에서는 프로그램 언어를 강력하게 만들어주기도 하지만 또 어떤 경우에는 잘못 사용을 하면 어떻게 될까요?
혼란스럽겠지요?
이런 혼란스러운 것을 막아준다면 얼마든지 강력한 프로그래밍을 할 수 있는 특징이 이 파이썬에는 있는 것입니다.

이제 배정을 통해서 이제는 실체 객체, 조금 전에는 클래스 객체의 데이터 속성을 생성해 봤는데 이제는 실체 객체를 또 똑같은 방법으로 새로운 attribute를 생성하기도 하고 또 삭제하는 과정을 살펴보도록 하겠습니다.

코드를 보시면 MyClass로부터 실체 객체를 생성하여서 mm이라는 이름으로 배정을 받았습니다.
레퍼런스를 삼았습니다.
그런 실체 객체에 똑같은 방법으로 2000이라는 값을 배정함으로써 dynamic_data_attr를 생성시키고 dir을 통해서 생성되었는지 확인하고 그 값을 찍어서 확인하고 delete를 통해서 다시 삭제를 하고 삭제가 되었는지 확인하는 과정입니다.

run을 통해서 결과를 보겠습니다.
지금 나온 이 결과는 조금 전에 MyClass를 사용해서 코딩을 한 과정에서 보여줬던 결과나 지금 실체 객체를 통해서 보여주는 결과가 아주 똑같음을 전혀 똑같음을 알 수 있습니다.
이렇게 우리는 클래스든 그 클래스로부터 생성된 실체 객체이든 마음대로 attribute를 넣거나 뺄 수 있다는 것을 확인을 했습니다.

지금까지 배정을 이용해서 실체 객체의 데이터 속성 생성하는 과정을 봤고요.
그러면 데이터 속성만 변경시킬 수 있는가, 또는 생성시킬 수 있는가?
그렇지는 않습니다.
메소드 속성에 대해서도 역시 마찬가지, 변경이나 생성 작업을 할 수 있는데 한 예로 조금 전에 우리가 다뤘던 MyClass에서 메소드 속성을 변경시키는 과정을 코딩으로 확인해 보겠습니다.

코드를 한번 보시기 바랍니다.
우선 MyClass에 어떤 attribute가 있는지 dir을 통해서 확인했고요.
메소드 attribute인 f를 ff라고 이름이 붙여진 객체에 저장을 했습니다.
백업을 해 놓은 거지요.

그러고 나서 built in 함수인 len, 즉 주어진 객체의 길이를 측정하는 함수를 레퍼런스를 f에다 배정했습니다.
이렇게 하면 원래 메소드가 아닌 len이라는 함수의 레퍼런스로 둔갑하는 것이지요.

과연 그런지 ABC라고 하는 세 개의 문자로 된 string을 줘서 기능을 확인해 봤습니다.
그리고 help를 해 봤고요.
그다음에 거기에 맞춰서 변경된 상태의 클래스에 따라서 실체 객체를 생성해서 mc로 받았습니다.

그리고 mc에 있는 f 속성으로 다시 ABC라는 문자열을 argument로 줘서 호출해 봤고 그다음에는 MyClass.f에 원래 백업되어 있던 ff 값을 배정해서 복원을 시켰습니다.
복원을 시키고 이 f를 호출해 봤습니다.
앞에서 말씀드렸듯이 0라는 argument는 또 tricky하게 준 값입니다.
또 MyClass라고 하는 클래스 실체 객체를 mc로 받아서 f를 확인해 봤습니다.
이런 과정을 run을 통해서 확인해 보겠습니다.
확인을 해 봤습니다.

처음 디렉터리 dir 속에는 큰 변화는 없네요.
f하고 i가 그대로 있습니다.
그다음에 이 3이라는 것은 어떤 것의 결과일까요?
len으로 바꾼 다음에 ABC를 문자열로 줘서 f를 호출을 했을 때 결과값이 3입니다.
이 값은 바로 len으로써 ABC 문자열을 측정을 한 결과값과 같은 것이지요.

그다음에 help를 했더니 f에 대해서 help를 했더니 엉뚱하게 len에 대한 help, docstring이 나타난 것이지요.
여기까지가 help입니다.
len에 대한 help가 그대로 나타난 것이지요.
또 실체 객체를 만들어서 f 함수를 호출을 했지요.
여기에 바로 이 부분입니다.

print mcf, 그것이 3이었고 그다음에 ff로 백업된 값으로 복구를 한 다음에 MyClass.f를 호출했고 mc.f를 다시 mc에다가 MyClass 실체를 생성 받아서 그 mc.f를 호출해서 두 번의 원래와 똑같은, hello world와 hello world가 나타남을 볼 수 있었습니다.

이렇게 이 객체, 클래스 객체라든지 또 실체 객체가 가진 메소드 속성 객체도 얼마든지 값을 변경할 수 있다는 것을 확인했고 지금 코딩을 통해서 확인하지 않았지만 새로운 attribute, 메소드 객체 attribute에 대한 객체도 생성하거나 삭제할 수 있다는 것은 앞에서 우리가 다뤘던 데이터 attribute 객체와 마찬가지인 것입니다.

이 코딩을 보시면 class MyList(list):에 pass라고 이름을 붙였습니다.
이건 무슨 뜻일까요?
list라는 것은 파이썬이 제공하는 built in 클래스지요.
또는 데이터 타입입니다, list data type입니다.

이 list라는 클래스를 베이스 클래스로 해서 MyList라는 또 다른 좀 더 전문화 된 객체를 클래스를 만들겠다는 것이지요.
그런데 실제로는 아무것도 한 일은 없습니다.
pass로서 그냥 no operation 하고 마감을 했습니다.

여기서 우리가 보고자 하는 것은 바로 이 구문 자체입니다.
이렇게 베이스 클래스를 argument로 줘서 MyClass라는 이름을 붙여서 클래스라는 구문을 만들면 파생 클래스가 하나 만들어진다.
그리고 이 파생 클래스는 아무것도 한 일은 없으니까 베이스 클래스와 동일한 클래스로서 실체가 객체가 만들어지는 것이라는 것입니다.

그리고 이런 리스트에 대해서 우리가 몇 차시 전에 다뤄봤던 comprehension expression을 넣어봤습니다.
comprehension list generation을 해 보면 레인지 1에서 4까지 즉 1, 2, 3, 4에 해당하는 모든 아이템들에 대해서 그 아이템을 받아들이는 리스트를 객체로 만들고 그 객체를 ml이라는 이름으로 그 레퍼런스를 배정을 하라는 하나의 구문이 생성된 거지요.
이거나 또 ml2라고 한다면 리스트에 item4, item in range 1~4 이거나 똑같은 거지요.
그리고 print ml2까지도 print를 해 보겠습니다.

run, 동일한 결과가 나왔지요.
ml1이나 ml2나.
이런 것이 하나의 클래스 전문화이다.
다만 전문화 하는 구체적인 내용은 보여드리지는 않았고 베이스 클래스를 이용해서 정의하는 방법만 여러분에게 코딩을 통해서 보여드린 것이니까 이 코드를 적절하게 활용해서 여러분의 커스터마이즈한 클래스를 만드실 수 있게 될 것이고 또 이런 것들은 구체적으로 나중에 우리가 프로젝트를 수행하면서 다루기 때문에 여기서는 짧게 설명 드리도록 하겠습니다.

다음에는 프로퍼티를 정의하고 활용하는 과정에 대해서 알아보겠습니다.
두 가지 방법이 있었지요.
하나는 내장 클래스 프로퍼티 또는 제너레이터 내장 함수 프로퍼티 함수를 이용하는 경우하고 또 하나의 프로퍼티 데코레이터를 이용하는 두 가지 방법으로 이 프로퍼티를 사용하는 방법을 보도록 하겠습니다.

함께 코드를 보시겠습니다.
이름이 Celsius라는 클래스를 정의를 하는 구문입니다.
여기에서 프로퍼티가 사용되는 예로써 클래스를 정의를 했습니다.
프로퍼티와 관련이 되는 부분은 바로 get_temperature, set_temperature에 해당하는 부분이 됩니다.

그리고 이 두 부분이 되고 그다음에 나머지 두 메소드들은 init는 처음에 어떤 실체 객체가 생성될 때 temperature라고 하는 attribute에 argument로 주어진 temperature라는 값을 배정해주는 것이지요.
그렇게 함으로써 이 temperature라고 하는 attribute를 생성이 되도록 하는 것입니다.

그런데 이때 이 클래스에는 이미 temperature라고 하는 attribute가 생성되어 있어요.
앞에서 말씀드렸지만 만일 클래스의 로컬 영역에 attribute를 생성하는 구문이 없다면 이 init에서 배정이 일어날 때 새롭게 생성될 텐데 그렇지 않은 경우이기 때문에 이 temperature가 그대로 여기에 self.temperature로 사용되는 것입니다.

그런데 이 temperature를 보니까 좀 이상하네요.
이상하기보다는 주의해서 봐야 할 점이 이 프로퍼티입니다.
프로퍼티는 앞에서 말씀드렸듯이 getter, setter, deleter 그리고 docstring 네 개의 조건부 argument를 포지션할 argument를 받는 형태로서 실체화 되는 클래스이지요.
이 프로퍼티 자제가 built in 클래스입니다.

지금은 getter와 setter만 주어졌지요.
나머지 deleter와 docstirng은 주지 않은 상태로 temperature가 실체화가 되고 있습니다.
프로퍼티라는 실체 객체로서 생성되고 있습니다.
그래서 만일 init에서 self.temperature, temperature 값이 배정될 때에는 어디를 통하게 되냐 하면 set_temperature라는 메소드를 통하게 됩니다.

이 값이 -273보다 작으면 물리학적으로 봤을 때 이 세상에 -273도보다 더 낮은 온도는 없기 때문이 이건 받아 쓸 수 없다고 거절을 하게 되는 것이지요.
raise라는 것은 의도적으로 오류 신호를 발생시켜서 인터프리터를 중간에 멈추도록 또는 프로그램이 죽도록 만드는 신호를 발생시키는 키워드입니다.

그런 작업을 하는 것이지요.
확인 작업을 하는 것이지요.
그래서 init에서 바로 self.temperature의 temperature를 assign할 때 set_temperature를 한번 불리게 되고 그다음에는 만일 to_fahrenteit라고 섭씨를 화씨로 고치는 이 메소드를 호출을 했다면 이제 self.temperature라고 하는 attribute에 있는 값을 읽어내야 하지요.

읽어내는 과정에서는 get_temperature라는 getter가 동작하는 것입니다.
여기에서는 별 동작은 안 하고 print 한 번, getting value라는 print 한 번 하고 값을 있는 그대로 내주게 되는 것입니다.
내주는데 여기에서, 여기서 set temperature를 보면 여기에 self._temperature가 있어요.

바로 이 순간에 이 _temperature라는 새로운 데이터 attribute가 만들어지는 것입니다.
이 _temperature는 프로퍼티가 아닙니다.
순수한 데이터 attribute가 되는 것입니다.
그리고 이 temperature로부터 뭔가 읽어내려고 할 때 to_fahrenteit에서 읽어내려고 할 때는 getter가 동작을 하면서, 즉 get_temperature가 동작을 하면서 이 순수한 data attribute인 _temperature로부터 값을 읽어서 리턴을 하게 되는 것이지요.

각각은 자기가 일을 했다는 것을 표시하기 위해서 setting value라든지 또는 getting value라는 메시지를 print 하도록 하고 있습니다.
이렇게 해서 동작을 확인해 보는 거지요.
이제 Celsius(-200)이라는 이 값을 줘서 한번 이 값이 얼마로 환산되는지 화씨 얼마로 환산되는지 실행을 시켜보겠는데요.

이미 조금 전에 제가 테스트를 위해서 한번 눌러봤기 때문에 여러분에게 새로 누르는 것을 과정을 보여드릴 필요는 없겠지요.
일단 결과만 보면 이 setting value라는 것을 언제 동작을 해서 생긴 것이냐 하면 처음에 c는 Celsius(-200)이라고 하는 구문이 동작을 하면 init가 동작하게 됩니다.
그리고 init가 동작할 때 temperature라는 프로퍼티 attribute의 temperature 값이 -200이라는 값이 assign이 되지요.

assign이 될 때 set_temperature라는 setter가 호출이 됩니다.
호출이 되어서 검사를 했더니 -200은 -273보다는 큰 값이므로 value error를 raise 하지는 않았습니다.
그리고 setting value를 print 했고 그다음에 이 _temperature에 -200이라는 값을 assign을 해 준 것이지요.
그 과정에서 우리한테는 setting value라는 문장 하나가 보인 것입니다.

그다음에 c.to fahrenheit를 불렀을 때는 바로 이 temperature 값을 읽어내는 과정에서 getter가 동작을 한 것입니다.
getter인 get_temperature가 동작을 해서 getting value가 메시지로 나왔고 self._temperature, _temperature 값이 리턴이 되어서 1.8로 곱해지고 그다음에 32로 더해진 것이지요.

그 결과값은 -328.0도라는 것으로 나타났고 그 와중에 getter에 의해서 getting value가 우리에게 나타난 것입니다.
그 과정을 아셨지요?
이렇게 프로퍼티라고 하는 것은 우리가 좀 더 데이터를 안전하게 다루기 위해서 더 신뢰성 있게 다루기 위해서 필요한 것이라는 것을 이 코딩을 통해서 확인할 수 있습니다.

다음에는 프로퍼티 클래스를 바로 생성자를 이용하는 것이 아니고 데코레이터를 이용하는 과정에 대해서 한번 살펴보도록 하겠습니다.
그전에 만일 우리가 좀 잘못된 값을 주었다면 어떻게 반응할지 그것도 확인해 보겠습니다.

다시 한번 c를 통해서, cc라고 해도 되지요.
cc는 Celsius(-300)도 정도 줄까요?
주고 이제는 분명히 에러가 날 것이라고 확신을 하기 때문에 뒤에 어떤 코드를 넣어보지는 않겠습니다.
run을 시켜보겠습니다.
바로 value error가 나타납니다.
어디에서?
이 set_temperature라는 데에서, 이 set_temperature는 어느 때 불렸는가?
여기에 temperature에다가 뭔가 값을 배정하기 위한 init 메소드에서 배정하는 과정에서 set_temperature가 불렸고 그 안에서 value가 -300이었기 때문에 -273보다는 작아서 이 value error가 raise 한 것입니다.
그 과정에서 이 프로그램이 죽어버린 것이지요.
이런 오류가 나타난 것을 볼 수 있습니다.

그다음에 데코레이터에 관한 코딩을 해 보겠습니다.
코딩을 보시겠습니다.
아까와 똑같은 이름의 Celsius라는 클래스를 정의하고 있습니다.
init도 init는 이제 데코레이터를 사용하기 위해서 _temperature라는 순수 데이터 attribute를 먼저 사용을 했습니다.

그다음에 fahrenheit는 같고요.
temperature라고 하는 것은 프로퍼티입니다.
언더바 없이 사용되는 것은.
그다음에 이제 프로퍼티 데코레이터를 통해서 이 temperature라고 하는 메소드를 정의를 했습니다.
이 메소드 자체는 getter에 해당합니다.
하는 일은 데이터 attribute인 _temperature로부터 값을 받아서 리턴을 하는 역할을 해 주는 것이지요.

그다음에 이 temperature는 이미 프로퍼티로 선언이 되었기 때문에 setter라고 하는 attribute를 갖게 됩니다.
그 attribute는 바로 이 temperature라는 함수로서 setter인데 그 temperature의 setter인데 이 setter가 하는 일은 -273도보다 작은지 검사를 하고 작다면 오류를 발생시키는 일을 하는 것은 앞에서 보신 setter와 동일합니다.

여기까지 하고 클래스는 데코레이터를 통해서 정의를 한 다음에 실행을 시켜보도록 하겠습니다.
이때 -300이라는 좀 무리스러운 오류가 발생할 만한 값을 넣어서 실행을 시켜보도록 하겠습니다.

그런데 이상하게 getting value가 동작을 했고 -508.0이라고 하는 값이 그대로 나왔습니다.
왜 이런 현상이 나타날까요?
이것은 이 c를 생성하는 과정에서 Celsius가 실제 객체를 생성하는 과정에서 _temperature에다 value를 집어넣었는데 이 과정 자체에서는 setter가 동작하지 않았어요.
왜 그럴까요?
이건 프로퍼티가 아니고 순수한 데이터, attribute이기 때문에 그렇지요.

그래서 여기에 만일 c.temperature에다가 -300이라는 값을 배정을 하겠다 하면 어떻게 될까?
이때는 오류가 나타납니다.
그런데 c.temperature에다 -272도를 배정을 해 보겠다 하면 어떤 결과가 나타날까요?
세팅이 되었습니다.

이 temperature 자체는 이미 클래스 정의를 할 때 이미 프로퍼티로 정의가 된 것이기 때문에 프로퍼티로서 동작을 합니다.
하면서 뭔가 세팅을 하려고 했기 때문에 이 setter에 해당하는 코드가 동작을 한 거지요.
이 부분을 동작을 한 것입니다.

그래서 이런 처음 실체, 객체를 생성할 때 문제를 문제가 이런 검사가 제대로 setter가 동작하지 않는 이런 문제를 해결하기 위해서는 여기에다가 if value -273도이면 raise 등등이라는 똑같은 구문을 넣어줄 필요가 있는 것이지요.
이 데코레이터를 이용할 때에는 이런 점들을 주의를 해야 할 필요가 있다.

그리고 일단 이 초기값을 이용하지 않는다면 그리고 여기 c.temperature라는 데에다 값을 넣는 과정으로써 이 프로퍼티 attribute의 값을 지정하겠다고 한다면 이 자체도 데코레이터를 통해서 정의를 한 프로퍼티도 우리의 목적에 맞게 훌륭하게 잘 활용할 수 있는 것입니다.

이렇게 이 프로퍼티 attribute를 사용하는데 프로퍼티 클래스에 대한 제너레이션으로 실체 객체를 통해서 프로퍼티를 생성하는 것과 또 데코레이터를 통해서 생성하는 과정 두 가지에 대해서 봤고 그들의 차이점을 코딩을 통해서 확인해 보았습니다.

지금까지 우리가 다뤄온 코딩 과정을 통해 클래스라고 하는 어떻게 보면 상당히 다루기 어려운 난해하기도 한 주제를 다뤄본 것입니다.
이런 객체 지향성이라고 하는 것은 C++이든 자바이든 자바 스크립트이든 파이썬이든 어떤 종류의 객체 지향성 언어이든 한 번은 다루고 넘어가야 할 하나의 높은 언덕이라고 볼 수 있는 거지요.
그 언덕을 여러분은 거의 80% 이상 넘어온 것이다 볼 수 있고 나머지 20%는 여러분이 또 과제를 통해서 또는 앞으로 남은 차시 동안에 수행하는 이 프로젝트를 통해서 더 훌륭하게 더 잘 넘어가실 것으로 생각을 합니다.
