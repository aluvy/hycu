12. 죽지 않는 프로그램

-------------------------------------------------------------
12_02. 죽지 않는 프로그램의 구조
-------------------------------------------------------------

[2페이지]

이번 차시는 죽지 않는 프로그램에 대해서 알아보겠습니다.
죽지 않는 프로그램의 구조.
프로그램은 죽지 않는다, 다만 말할 뿐이다.
이 두 가지가 이번 차시에 대한 작은 주제들이 되겠습니다.
이번 차시를 통해서 여러분은 불완전한 환경에서도 강인하게 동작하고 끝까지 서비스하는 프로그램의 개념과 구조를 설명하실 수 있게 될 것이고요.
파이썬 프로그램의 예외 처리 구조를 코딩을 하실 수 있게 될 것입니다.

첫 번째 시간입니다.
죽지 않는 프로그램의 구조입니다.
우선 파이썬 프로그램의 예외적인 상황, 즉 질병이라고 이야기할 수 있고요.
그 질병에 대한 조치 방법, 치료 방법에 대해서도 한번 알아보겠습니다.
먼저 오류가 있습니다.
에러라고 하는데 파이썬에서는 오류의 정의를 프로그램 코드가 문법을 지키지 않고 작성된 상태를 뜻합니다.
이래서는 도저히 프로그램이 수행될 수 없는 상태를 이야기하는 것입니다.

아주 치명적인 그리고 프로그램 동작을 하는 데 있어서는 완전 실패를 야기할 수 있는 상태라고 하는 거죠.
예를 들면 와일 구문에서 콜론을 빼고 와일 스위트를 작성해버린 것, 즉 콜론을 빼먹은 것, 신택스상에 오류가 난 것, 이런 것들이 파이썬에서는 오류라고 이야기하고 있습니다.
이번에는 예외라는 것이 있습니다.
오류와는 좀 다르게 프로그램이 충분히 대처를 할 수 있고 넘어갈 수 있는 문제들이라는 것이죠.
정의를 해보겠습니다.

프로그램이 사용자가 원하는 서비스를 제공하지 못하는 상태를 예외라고 이야기합니다.
기능은 할 수 있는데 서비스를 제공하지 못한다.
대부분의 경우는 인터프리터는 이 경우에도 프로그램을 기능을 완전히 멈추고 중지를 시키는 일을 하게 되는데 그렇게 하지 않을 수도 있다는 것입니다.
이럴 때는 프로그램이 죽지 않게 할 수 있다는 것입니다.
이런 예외의 원인은 대부분 프로그램 동작이 잘못됐거나 사용자가 실수를 하는 경우에 발생하게 됩니다.

예를 들면 제로디비전에러라든지 네임에러라든지 타입에러 같은 것들이 이 예외의 예라고 할 수 있습니다.
버그가 있습니다.
버그는 프로그램이 설계된 기능을 실행하지 못하는 원인이 되는 코드의 일부분입니다.
조금 전에는 예외는 서비스를 제공하지 못하게 한다.
또, 버그는 지금 말씀드리기는 기능을 실행하지 못하게 한다.
기능과 서비스, 조금 구별을 해서 우리가 생각을 해볼 필요가 있는데요.
자세한 것은 나중에 기회가 되면 말씀을 드리겠습니다.

이 버그는 예외보다는 좀 규모가 작은 잘못된 상태라고 이야기를 할 수 있습니다.
이 버그의 원인은 대부분 개발자의 코딩 실수라든지 프로그램 언어에 대한 미숙함으로 버그가 발생하게 됩니다.
예를 들면 함수 속성의 객체 참조의 속성을 데이터 속성으로 바꿨는데 그걸 잘 기억 못 하고 프로그래밍을 하는 사람이 다시 원래의 함수처럼 사용하려고 호출을 해버렸다, 이럴 때는 타입에러가 발생하게 되겠죠.
이런 부분도 버그에 속하게 되는 것입니다.

또는 예외 상태에도 속하게 되는 것이죠.
그래서 버그라고 하는 것은 예외를 발생시키는 원인이 된다고도 볼 수 있습니다.
이제는 이런 프로그램의 잘못된 상태, 오류라든지 예외라든지 버그와 같은 질병의 상태를 어떻게 조치를 하는가, 치료를 하는가.
그 첫 번째가 예외 처리입니다.
예외 처리는 말 그대로 예외가 발생했을 때 그 예외를 적절하게 대처하고 그 예외에 대한 정보를 사용자에게 제공하는 과정을 예외처리라고 이야기할 수 있습니다.

또, 이 예외처리라는 것은 다른 말로 오류처리라고도 흔하게 이름을 붙이고 있는데 우리는 지금 파이썬의 범위에서는 오류와 예외를 좀 다르게 표현하고 있죠.
오류는 치명적인 것, 예외는 치명적이긴 하지만 우리가 충분히 프로그래밍을 통해서 극복하고 넘어갈 수 있는 것이라고 이야기를 했는데 지금 많은 경우에는 이 오류처리라든지 예외처리를 구별하지 않고 사용을 하는 경우가 있습니다.

우리는 조금 더 정확하게 표현한다면 항상 예외처리라는 용어로 통일을 시켜서 이야기하도록 하겠습니다.
예외처리의 예를 보면 지난 차시에서 우리가 다룬 적이 있습니다.
저온의 하한선이 물리학적으로 -273℃인데 0℃ KE죠.
그보다 낮은 온도값을 사용자가 입력하면 프로그램은 입력값이 잘못됐다고 알려줄 필요가 있습니다.
그리고 또 더 친절하다면 그 값이 어느 이상이 돼야 한다고 –273이라는 숫자도 같이 알려줘야 하는 능력이 있어야 하겠죠.

이런 것들이 필요한데 바로 이런 일들이 예외처리의 과정에서 일어나는 일들이라고 할 수가 있습니다.
고장 수리가 있습니다.
트러블슈팅이라고 이야기합니다.
고장이 있을 때 겨냥을 해서 쏘아서 그 고장 상태를 없앤다, 죽인다 하는 이야기를 트러블슈팅이 가지고 있죠.
그럼 이런 트러블슈팅이라는 것이 왜 용어가 발생했을까요?

그 고장의 원인이 너무나 광범위하게 퍼져 있기 때문에 어떤 것을 조준해야 할지 모르는 경우에도 분명한 원인을 찾아서 조준을 해야 한다 하는 것을 내포하고 있습니다.
그만큼 고장 수리라는 것은 좀 더 광범위한, 예외보다도 버그보다도 그 원인이 광범위하게 분포돼 있는 시스템 전체에 분포돼 있는 상황을 이야기할 때 그때 그런 상황을 극복하는 것을 고장 수리라고 이야기합니다.

정리를 해서 정의를 한다면 예외 상황이 발생했을 때 프로그램 사용자가 입력된 데이터 시스템 구성 및 환경 등에서 원인을 찾고 제거하고 수정하여서 프로그램이 정상적으로 서비스를 제공할 수 있게 하는 것을 고장 수리라고 이야기합니다.
예를 들면 데이터 파일의 저장 경로가 없어서 프로그램이 데이터 파일을 찾지 못하게 됐다.

이럴 때는 이 프로그램이 패스라고 하는 환경 변수를 참조하고 있을 때는 그 패스에 OS 차원에서 또는 응용 프로그램 차원에서 이 데이터 파일의 경로를 넣어주는 것입니다.
그렇게 함으로써 데이터 파일을 정상적으로 찾을 수 있고 사용할 수 있도록 한다면 바로 고장 수리가 되는 것이죠.
그렇다면 패스라고 하는 것은 프로그램 자체의 문제가 아니고 프로그램이 돌아가는 환경에서의 문제가 되는 것입니다.

그 환경 자체를 고쳐주고 시스템의 다른 부분을 고쳐주는 것을 고장 수리라고 이야기할 수 있습니다.
또, 앞에서도 언급했지만 프로그램에 입력할 온도 데이터 파일에서 –273보다 적은 값을 찾아내서 검토하고 사용자가 삭제해 주는 것입니다.
그렇게 한다면 데이터 파일 자체를 일차적으로 필터링 한다면 이 프로그램이 잘못 동작하거나 서비스를 못하게 되는 경우는 없게 되겠죠.

이런 데이터 파일 자체를 정제하는 것 자체도 고장수리라고 이야기할 수 있습니다.
디버깅은 버그를 찾아내고 코드를 수정해서 없애는 것입니다.
코딩을 다시 하는 것이죠.
예를 들면 객체 참조의 유형이 의도와 다르게 변경되는 부분을 찾아내고 그 유형이 유지되도록 다시 코딩을 하는 것을 디버깅이라고 할 수 있습니다.

또는 객체 참조를 참조할 때마다 이 객체 참조의 유형이 무엇인지 검사를 하는 기능, 이프 구문을 하나 더 두고 여기에서 원하는 유형일 때만 호출을 하든지 또는 플러스 오퍼레이션을 하는 이런 경우는 굉장히 고강도의 시큐어 코딩에 해당하는 부분이 되기는 하는데, 이런 것도 역시 디버깅이라고 이야기를 할 수가 있습니다.

두 번째로 조금 전까지 우리는 프로그램에서 발생할 수 있는 여러 가지 질병의 상태 그리고 이 질병을 치료할 수 있는 과정에 대해서 개념을 알아보았고요.
이제는 이 프로그램이 죽더라도 우아하게 죽을 수 있는 구조에 대해서 알아보도록 하겠습니다.
먼저, 예외라고 하는 클래스를 알아볼 필요가 있습니다.
우리가 파이썬에서 예외라고 한다면, 익셉션이라고 한다면 그것은 하나의 예외에 대한 정보를 갖추고 있는 클래스입니다.

이 예외 클래스의 계위 구조를 보면 가장 상위 클래스, 슈퍼 클래스로서는 또는 베이스 클래스로서는 베이스 익셉션이 있습니다.
베이스 익셉션 자체도 어떤 클래스로부터 파생이 된 겁니다.
클래스의 가장 원조는 무엇이라고 할 수 있을까요?
지난 차시에 우리가 클래스를 다루었을 때 오브젝트라는 클래스가 있었습니다.

이것이 파이썬에서는 가장 제1순위가 되는, 제일 상층이 되는 슈퍼 클래스 또는 베이스 클래스가 되는 것이고, 여기에서 수많은 클래스들이 파생되게 되는데 그중의 하나가 예외처리를 하기 위한, 오류처리를 하기 위한 클래스로서 베이스 익셉션을 만들어놓게 됩니다.
그리고 베이스 익셉션으로부터 파생되는 클래스들이 제너레이터 엑시트, 시스템 엑시트, 익셉션, 키보드 인터럽트라는 4개의 주요 베이스 클래스를 또 파생하게 됩니다.

이제 파이썬 프로그램에서 주로 상대를 해야 하는 부분은 바로 익셉션입니다.
익셉션으로부터 또 파생돼 내려오는 여러 가지 특정한 예외에 대한 클래스들이 있습니다.
어트리뷰트 에러라든지 아리스메틱 에러라든지 이런 정도는 하나의 도메인을 이루는 것이고 그 도메인 내에서도 또 여러 파생된 자세한 예외에 대한 클래스들이 있는데 지금 보시는 그림은 전체 최상층부만을 우리가 보는 것이고,
그 상층부에서 파생돼 있는 수많은 예외 클래스는 우리가 볼 수 있는 그림에서는 표현하지 않고 다 생략을 한 것입니다.
그중에 일부만 여러분에게 보여드린 것이죠.
그리고 익셉션이라는 것은 그 옆에 있는 제너레이터엑시트나 시스템엑시트 또는 키보드인터럽트와 조금 다릅니다, 성질이.
그 주변에 있는 것들은 전부 시스템에서 발생하는 것입니다.

오퍼레이팅시스템이라든지 하드웨어에서 발생하는 것이고, 이런 오류가 발생한다면 시스템 자체 또는 파이썬이 돌아가는 플랫폼이 되는 OS 자체, 맥이라든지 윈도우즈가 다 크래시가 되는 상태가 될 수 있는 예외들이 됩니다.
이런 것들은 파이썬으로서도 파이썬 인터프리터가 적절하게 대처를 해서 넘어갈 수 있는 문제는 아니고 반드시 시스템 차원에서 문제를 해결해야 하기 때문에 그 영역을 벗어나게 되는 것이죠.

파이썬에서 해결할 수 있고 죽더라도 우아하게 죽을 수 있는 상대가 되는 것은 바로 이 익셉션에 해당하는 부분이라는 것 꼭 기억해 주시기 바랍니다.
그래서 익셉션이라는 것은 넌 엑시트, 즉 중도에 빠져나가지 않더라도 가능한 예외라고 이름을 붙여주고 있고 그 옆에 있는 예외들은 엑시트, 반드시 엑시트 해서 일단은 프로그램을 멈추고 시스템 차원에서 들여다봐야 하는 예외라는 것.
이렇게 구별을 해서 여러분에게 말씀을 드릴 수 있습니다.

이런 익셉션 계열에 해당하는 예외를 우리는 어떤 구조로써 대처를 할 수 있는가.
바로 트라이 익셉트 엘스 파이널리 구문으로서 대처를 할 수 있습니다.
지금 보여드린 트라이 익셉트 엘스 파이널리는 이 예외를 처리하는 모두를 보여드린 것입니다.
그리고 나중에 조금 있다가 이 부분, 부분, 부분 트라이해서 익셉트만 있는 부분, 트라이에서 파이널리만 있는 부분, 또 트라이, 익셉트, 엘스만 있는 부분.

이렇게 전체 완벽한 구조에서 경우에 따라 이걸 다 쓸 필요는 없습니다.
비경제적이 될 수가 있는 것이죠.
또 비효율적이 될 수도 있는 것입니다.
경우에 따라서 우리가 원하는 목적에 따라서 취사 선택을 해서 구조를 간편하게 만들 수 있는데 그런 과정까지 말씀을 드리겠는데, 그전에 우리는 전체 구조를 미리 보는 것입니다.

우아하게 죽는다.
이건 무슨 뜻일까요?
다잉 그레이스풀리.
프로그램 실행 중 예외가 발생했을 때 프로그램이 바로 중지되지 않고 예외에 대한 조치를 취하고 사용자에게 예외에 대한 정보를 제공한 후에 중지되는 현상을 뜻합니다.
이런 경우는 프로그램 개발과 운영 효율성이 좋으므로 대부분 우아하게 죽는 것을 선택하는 거죠.
끝까지 살아남을 수도 있습니다.

조금 전에 앞에서도 말씀드렸고, 또 이번 차시의 제목 자체가 여러분의 이목을 끌기 위해서 절대 죽지 않는 듯한 그런 뉘앙스로서 죽지 않는 프로그램이라고 했는데 이것은 결론부터 말씀드리면 비경제적이라고 할까 또는 특수한 경우에만 필요한 경우라고 할 수가 있습니다.

끝까지 살아남는다, 리빙 포레버라고 하는 것은 프로그램 실행 중 예외가 발생했을 때 프로그램이 예외에 대한 조치를 취하고 사용자에게 예외에 대한 정보를 제공한 후 사용자의 고장 수리가 될 때까지 기다려 주는 것입니다.
고장 수리가 다 된다, 즉 트러블슈팅이 다 돼서 다시 정상적으로 돌아갈 수 있는 환경이 준비가 되면 그때 다시 자기의 기능을 재시작, 재시동하는 것입니다.
이것을 리줌이라고 이야기합니다.
스톱했다가 리줌한다.
스톱, 웨이트, 리줌.

오퍼레이팅 시스템에서도 비슷한 용어를 쓰기는 하는데 응용 프로그램에서도 비슷한 용어를 지금 사용할 수가 있습니다.
상황이 안 됐을 때는 잠시 동작을 멈추고 잠복을 하고 있는 것입니다.
그리고 상황이 좋아졌을 때 정상화됐을 때는 다시 활개를 펼치고 기능을 하면서 서비스를 제공하는 그런 형태가 끝까지 살아남는 프로그램의 형태가 되는데 이런 자동적 서비스 재개, 리주밍을 할 수 있을 때는 실현 비용이 상당히 큽니다.

코딩을 하거나 설계를 하는 것도 쉽지는 않죠.
시큐어 코딩이라든지 또는 릴라이어블 코딩에서 할 수 있는 일인데, 이것까지도 가능은 합니다.
그렇지만 이번 차시에서 우리가 다루는 것은 우아하게 죽는 쪽에 좀 더 중점을 두어서 말씀을 드리도록 하겠습니다.
이런 트라이 익셉트 엘스 파이널리 구문의 문법을 말씀드리겠습니다.
트라이, 트라이 블록이 있고 익셉트 구문이 또 뒤따라 나오게 됩니다.

그다음에는 엘스 구문이 나타나게 되고 파이널리 구문이 마지막으로 나타나게 됩니다.
여기에서 익셉트 구문은 중괄호를 치고 스타를 오른쪽에 붙임으로써 옵션이라는 것을 하나도 없을 수도 있고 또 여러 개가 나타날 수도 있다는 것을 보여드리는 것이고, 익셉트의 익셉션이라고 하는 대문자 E로 시작하는 익셉션 구문이 있죠.
이 구문은 하나만 있으면 됩니다.
그리고 이 구문은 반드시 모든 익셉트 구문의 가장 마지막에 위치해 줘야 합니다.

그다음에 엘스 구문이 있을 수 있고, 또 파이널리 구문이 있을 수 있다.
대괄호로 친 것은 옵션이라고 말씀을 드렸죠.
구문 전체를 보면서 간단간단하게 말씀을 드렸는데 이제 텍스트로 정의된 내용을 다시 한번 보면서 정리해서 말씀을 드리겠습니다.
애즈 구절은 프레이즈죠.
구문은 스테이트먼트고 구절은 프레이즈라고 해서 우리말로 번역을 한 것입니다.
애즈 구절은 아이덴티파이어의 예외에 대한 시스템 메시지를 배정하는 구문입니다.

그리고 익셉트 구문은 구문에 주어진 스페시픽 익셉션 클래스 또는 익셉션 그리고 이들의 파생 클래스가 매치가 된다면 그 해당되는 익셉트 블록을 수행하고 트라이 구문을 빠져나가게 됩니다.
빠져나가다가 만일 파이널리 구문이 있으면 거기에 또 빠져서 그 파이널리 블록을 수행시키고 나가야겠죠.
그다음에 슈퍼 클래스 예외는 매치가 되지 않습니다.
예를 들어서 익셉션 구문이 있다 하더라도 익셉션의 슈퍼 클래스가 뭐죠?
베이스 익셉션이죠.

베이스 익셉션에 해당하는 예외가 발생했다면 여기에는 매치가 되지 않는다는 것이죠.
그다음에 트라이 블록은 서비스를 제공하기 위한 준비 작업을 수행하는 부분으로 사용된다든지 서비스 제공을 위한 주요 기능을 실행하는 부분으로도 우리가 사용을 할 수 있습니다.
익셉트 블록은 예외 대책을 실행하는 부분이 되겠고 예외에 대한 정보 서비스를 제공하는 부분이 되겠습니다.

엘스 블록은 예외가 전혀 발생하지 않았을 경우에 서비스를 제공하기 위한 기능을 실행하는 부분이고, 파이널리 블록은 예외 발생 여부에 관계없이 서비스 제공을 위한 기능을 실행합니다.
파이널리 구문이 굳이 필요한가.
이렇게 생각을 할 수도 있는 부분이 있는데
그러나 다중 트라이 구문을 사용한다든지 또는 병렬 트라이 구문을 사용할 때는 파이널리 블록을 우리가 사용해야 하는 경우가 많이 생기게 됩니다.
그때를 위해서 준비를 해놓는 것이죠.
이제 트라이 익셉트 구문과 포괄적 예외 이름 사용하는 경우에 대해서 보겠습니다.
구문 사용 문법은 앞에서 보신 전체적인 구문 문법의 하나의 섭셋입니다.
트라이가 있고 익셉트, 익셉션이 바로 나오게 됩니다.

대문자 익셉션 클래스 이름이 바로 주어지게 되고 필요하다면 애즈 아이덴티파이어가 주어지게 되고 그다음에 제너릭 익셉트 블록이 나오게 됩니다.
키워드 익셉트 뒤에 익셉션이라는 예외의 포괄적 클래스를 둠으로써 예외가 발생한다면 그 예외의 종류에 관계없이 모두 여기에 다 매치가 되도록 하는 것입니다.
그러면 이것도 매치, 저것도 매치 하면 구별을 하기 어렵게 되겠죠.

그래서 이럴 때는 애즈 아이덴티파이어 구조를 뒤에 덧붙임으로써 시스템이 도대체 어떤 예외 때문에 이 익셉트 익셉션 블록으로 들어오도록 만들었는지 좀 더 자세한 정보를 보기 위해서 애즈 프레이즈를 두게 되는 것입니다.
그런데 이 익셉션과 동급에 있는 예를 들어서 시스템 엑시트라든지 제너레이트 엑시트라든지 키보드인터럽트라는 클래스에 해당하는 예외가 발생한다면 여기에 들어올까요?
들어오지 않죠.

또, 그 위에 있는 슈퍼 클래스인 베이스 익셉션에 해당하는 예외가 발생해도 여기에는 매치가 되지 않는다고 조금 전에 말씀을 드린 적이 있습니다.
그다음에 이 클래스 익셉션이라는 것을 보겠습니다.
클래스 익셉션은 특정 파이썬 예외 클래스의 베이스 클래스 역할을 하게 되는 것입니다.
중요한 것입니다.
앞으로 우리가 사용자 커스터마이즈드 익셉션 클래스를 만들 때는 반드시 이 익셉션이라는 클래스가 베이스 클래스가 되는 것입니다.

그리고 익셉션의 베이스 클래스는 베이스 익셉션이라는 것이 되는 것이고요.
이 관계를 기억해 둘 필요는 있습니다.
그다음에 익셉트 익셉션 구문은 클래스 익셉션의 파생 클래스인 스페시픽 익셉션 클래스도 모두 다 잡아서 매치를 시킬 수 있으므로 익셉션 구문 중 마지막에 배치를 합니다.
그렇지 않고 이것이 중간이나 앞에 있으면 거기에서 이미 걸려버려서 스페시픽한 익셉션으로 들어올 리가 없게 되겠죠.

그래서 클래스 익셉션 구문은 가장 스페시픽한 것들의 가장 다음에 가장 마지막에 이 구문이 와야 한다는 것이죠.
이건 포괄적인 경우였고, 그다음에 하나하나 예외 종류를 특정해서 처리하고 싶다고 할 때는 중간에 있는 스페시픽 익셉션 클래스를 사용하면 됩니다.
이제는 베이스 클래스인 익셉션을 사용하는 것이 아니고 그 파생 클래스들을 하나하나 불러서 구문을 만들어주는 것이죠.
그것이 스페시픽 익셉션 클래스들입니다.

여기에도 마찬가지로 애즈 아이덴티파이어 프레이즈 구조를 우리가 사용할 수 있습니다.
키워드 익셉트 뒤에 예외의 종류를 구별할 수 있도록 각 예외에 부여된 이름인 스페시픽 익셉션 클래스를 명시함으로써 발생한 예외와 매치된 스페시픽 익셉트 블록이 실행되도록 하는 것입니다.

또, 이런 스페시픽 익셉션 클래스들은 모두 대문자 익셉션의 파생 클래스라는 것 앞에서도 말씀드렸고요.
그다음에 익셉트 스페시픽 익셉션 클래스 구문 자체는 클래스 스페시픽 익셉션 클래스와 그의 파생 클래스와 매치되어서 자신의 스페시픽 익셉션 블록을 실행시켜주는 것입니다.
이다음에는 응용 프로그램을 끝까지 살리기에 대해서 살펴보도록 하겠습니다.

개요를 보면 예외의 종류를 구별하고 각각 대응함은 우리가 곤란하기 때문에 모든 종류를 다 구별해서 대응을 하겠다고 하면 수백 개의 예외에 대한 코드가 작성돼야 할 것입니다.
이렇게 할 필요도 없고 또 그렇게 하기도 어렵죠.
힘들죠.

이럴 때는 우리가 필요한 것만 익셉트 구문을 마련하고 그다음부터는 그냥 대문자 익셉트로 퉁치는 겁니다.
그렇게 해서 포괄적으로 우리가 관심이 있는 것만 몇 개 앞에서 매치를 시켜서 처리를 하도록 하고 그 외의 것은 우리가 별 관심이 없어.
일어난다 하더라도 뭐가 일어났는지만 알면 돼.
그럴 때는 익셉션 구문으로 마지막에 있다고 했죠?

그 마지막에서 모두 잡아서 거기에 대한 시스템 메시지 정도만 보고 끝내든지 그렇지 않으면 무시를 하고 넘어가도록 하는 것입니다.
이런 것들이 응용 프로그램을 끝까지 살리기에 대한 구조를 만드는 개념이라고 할 수가 있습니다.
구문 문법을 보면 트라이, 트라이 블록, 익셉트, 스페시픽 익셉션 클래스, 마지막으로 익셉트 익셉션이 나오게 되는 것입니다.

그래서 이 스페시픽 익셉션 클래스로서 관심을 가지고 있는 예외에 대한 처리를 한 다음에 넘어가도록 하는 것이고, 만일 그런 관심 있는 관심 대상이 아니면 익셉트 익셉션, 즉 제너릭 익셉션 블록에서 처리가 되도록 하면서 넘어가고자 하는 것이죠.
이제 조금 전에는 우아하게 죽을 줄 아는 프로그램이었는데 이제는 우아할 뿐만 아니고 효율적인 프로그램이 되도록 하는 이야기를 하겠습니다.

그런 프로그램에 대해서 이야기를 하겠습니다.
효율적이라는 것은 죽는 것하고 관계는 없습니다.
다만 될 수 있으면 죽지 않도록 하겠다는 것이죠, 효율적이라고 하는 것은.
그리고 죽더라도 손해를 좀 덜 끼치면서 죽겠다는 것을 뜻합니다.
트라이 익셉트 엘스.
바로 이 엘스가 첨가된 구문이 이런 효율적에 관한 부분을 강화시키는 부분이라고 할 수가 있습니다.
목적은 응용 프로그램의 작업 성공률을 높이고 비용 손실을 줄이고자 하는 것입니다.

응용 프로그램의 주요 작업 조건을 먼저 점검한 다음에 예외 발생 가능성이 없을 때만 작업을 수행하는데 어디에서 수행하는가, 이게 중요합니다.
점검을 하는 것은 바로 트라이 블록에서 수행을 합니다.
트라이 블록에서 수행하고 거기에서 혹시나 예외가 발생하게 되면 익셉트 구문에서 처리를 하게 합니다.
만일 그런 예외가 없을 때는 밑에 있는 엘스 구문에서 주요한 서비스를 처리하도록 하는 것이죠.

구문의 문법을 보면 트라이, 트라이 블록, 익셉트, 익셉트 익셉션, 엘스가 있고 바로 이 엘스가 효율성을 강화시키는 요소가 된다고 말씀을 드렸죠.
트라이 블록에서는 주요 작업 조건을 점검하고 만일 예외 상황이 발생할 것 같으면 익셉트 블록에서 처리를 하게 하고, 또 해소를 한 다음에 그다음에는 엘스 블록이 와야 하는데 만일 익셉트 블록이 수행이 됐다면 엘스 블록으로 오지는 못하죠.

그래서 엘스 블록이 수행하지 못하는 조건을 미리 발견해서 예외를 미리 발견해서 대처를 하든지 중지를 시킴으로써 쓸데없이 엘스 블록이 수행되다가 자원만 소비하고 서비스는 못하게 되는 것을 막겠다고 하는 개념이 되는 것입니다.
그리고 엘스 블록에서는 주요 작업을 실행하여서 서비스를 제공하게 되는 것입니다.
그다음에는 전체적인 구조를 다 사용하는 트라이 익셉트 엘스 파이널리.

우리가 처음에 보았던 전체 구조를 다 사용하는 구문의 개요에 대해서 말씀을 드리겠습니다.
목적은 파이널리 구문이 있기 때문에 예외 발생 여부와 관계없이 파이널리 구문에서 어떤 작업을 실행할 수가 있는 것입니다.
구문 문법은 앞에서 보셨던 문법과 똑같으니까 내용은 자세하게 또 말씀드리지는 않겠습니다.

맨 밑에 보시면 지금 트라이부터 엘스까지는 지금까지 우리가 보아왔던 부분입니다.
이제 파이널리, 파이널리 블록이 있습니다.
맨 밑에 보시면 블록이 있고, 중간쯤에 보시면 모두 어떻게 표현이 돼 있나요?
익셉트 블록은 있거나 또는 옵션으로서 하나도 없을 수도 있습니다.
그리고 익셉트 익셉션 구문도 옵션으로서 없을 수도 있습니다.

결과적으로 가장 작은 경우에는 트라이, 트라이 블록과 파이널리, 파이널리 블록 두 개만으로도 이 구문이 구성될 수 있다는 것입니다.
그리고 파이널리 블록이 일단 붙어 있으면 파이널리 블록은 앞에서 어떤 예외가 발생했든지 상관없이 실행이 되도록 하는 성격을 가지고 있습니다.
단, 발생한 모든 예외는 익셉트 구문에 의해서 미리 처리가 됐다는 전제 조건을 또 필요로 하는 것이죠.

지금까지 말씀드린 것은 기본적으로 파이썬이 내장형으로서 다룰 수 있는 예외들을 대상으로 말씀을 드린 거고, 이제는 그 파이썬이 제공하는 기본적인 빌트인 예외로서 우리가 표현하기 어려운 그런 예외들이 또 있습니다.
이것은 특정한 서비스에 아주 밀접하게 관련이 돼 있는 예외들이라고 할 수 있습니다.

그래서 파이썬은 기본적인 응용 프로그래밍을 할 수 있는 기본적인 플랫폼을 제공하는 것이고 그 플랫폼에 해당하는 것만 예외 처리를 할 수 있고 예외를 제공해 주는 것이죠.
그 클래스들을 제공해 주는 것이고, 응용에 관한 정보를 제공하려면 우리가 만들어야 합니다.
그것을 사용자 예외라고 이야기를 하고 영어로는 커스터마이즈드 익셉션이라고 이야기합니다.

정의를 해보면 응용 프로그램이 예외를 스스로 생성하여서 시스템을 보고하고 그에 대해서 내장 예외와 동일한 방법으로 처리할 수 있도록 하는 것입니다.
그 목적은 응용 프로그램에서 발생한 비정상 상태가 내장 예외로 표현할 수 없는 경우에 이를 표현하기 위해서 응용 프로그램이 특정 예외를 시키는 것입니다.

그리고 응용 프로그램의 환경이 프로그램의 기능과 서비스에 부적당한 경우 이를 사용자에게 알리고 시정하도록 하기 위해서 주로 사용자 예외를 만들게 됩니다.
사용자 예외를 만드는 방법은 바로 레이즈 구문입니다.
레이즈 구문의 문법은 레이즈 커스터마이즈드 익셉션이라는 구조로 형성됩니다.
여기서 레이즈는 키워드죠.
그리고 사용자 예외, 커스터마이즈드 익셉션인데 이것이 바로 클래스입니다.

커스터마이즈드 익셉션은 익셉션이라는 베이스 클래스의 바로 파생 클래스들이 되는 것입니다.
그래서 사용자 예외 클래스를 파생하는 구문의 문법을 보시면 클래스 키워드를 사용하시면 되죠.
지난 차시에 우리가 다루었습니다.
클래스 이름, 베이스 클래스 이름 괄호를 통해서 괄호 열고 닫고 그 속에 베이스 클래스 이름을 주면 되는 것이죠.

그 구조를 그대로 가져와서 클래스 커스터마이즈드 익셉션이라는 클래스 이름을 주고 괄호 열고 커스터마이즈드 익셉션 베이스를 클래스를 주고 그다음 괄호를 닫으면 됩니다.
대부분의 경우 여기에는 익셉션을 주면 되는 것이죠.
또는 익셉션으로부터 한 단계 더 파생시켜서 만든 것으로 우리가 베이스 클래스를 삼을 때 바로 이 커스터마이즈드 익셉션 베이스라고 이야기를 하게 됩니다.
그 밑에 표현된 대로입니다.

이렇게 이번 차시에는 죽지 않는 프로그램을 만들겠다.
물론 만들 수 있습니다.
그리고 죽지 않는 프로그램을 현재 다룬 구조로서 충분히 우리가 만들 수 있지만 다만 비용이 문제죠.
그리고 그럴 필요성이 있는가.
제목하고는 조금 다른 이야기를 하기 때문에 의아하게 생각을 하실 수도 있지만 경제성 문제에 의해서 영원히 죽지 않는 프로그램 만들 수 있지만 만들지는 않겠고 
죽더라도 우아하게 죽고 효율적으로 전체적인 프로그램 서비스를 제공할 수 있는 그런 구조의 프로그램을 우리가 만드는 것이 최선의 현재로써 베스트한 목적이 된다는 것으로서 첫 번째 시간 말씀을 전체적으로 주제를 삼아서 말씀드렸고요.

거기에서 중요한 구문 여러분이 잊지 마셔야 할 것은 트라이 익셉트 엘스 파이널리, 이 네 개의 부분부분 구문으로 구성된 전체적인 트라이 구문을 우리가 구성한다면 이런 우아하게 죽고 전체적으로 효율성 있게 서비스를 제공할 수 있는 프로그램을 코딩할 수 있다는 것을 첫 번째 시간에 말씀드린 것입니다.
