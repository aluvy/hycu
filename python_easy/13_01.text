13. 파일 다루기

-------------------------------------------------------------
13_02. 파일 다루기
-------------------------------------------------------------

[2페이지]

이번 차시에는 파일 다루기라는 제목으로 공부를 하겠습니다.
간단하지요.
열고 읽고 쓰고 그리고 닫는다는 것을 우리는 다루는데.
거기에 숨어 있는 여러 가지 자세한 것들을 이번 차시에 모아서 한번 정리하면서 공부를 하는 시간이 된다는 것입니다.
첫 번째 시간에는 파일 다루기를 알아보겠습니다.
파일의 종류는 텍스트 파일과 바이너리 파일이 있습니다.
텍스트 파일은 사람이 볼 수 있는 문자들로 구성이 된 파일이지요.

그중에는 사람이 볼 수 없는 제어문자도 섞여 있기는 합니다.
newline 등과 같은 것들이 대표적인 예이고요.
이런 텍스트 파일을 구성하는 문자를 코딩을 하는 체계가 있지요.
ASCII 코드나 UNICODE 등이 그 대표적인 예입니다.
텍스트 파일의 확장자는 단순 텍스트일 경우에는 .txt, .csv 등으로 표현을 할 수 있고 그 외에도 프로그램 소스 코드라든지 데이터 등이 텍스트 파일의 대표적인 예라고 할 수가 있습니다.

바이너리 파일인 경우는 실행 파일이라든지 이미지 파일 등과 같이 시스템과 응용 프로그램이 처리하고 실행할 수 있는 내용을 가진 파일입니다.
사람이 직접 읽거나 작성하는 것은 거의 불가능하지요, 어렵지요.
이런 파일들에는 실행 가능한 파일 실행 파일이라든지 이미지 파일, 비디오 파일, 오디오 파일, 압축 파일, 폰트나 문서 등이 바이너리 파일에 속합니다.

조금 이상한 느낌을 가지신 분이 있을 거예요.
데이터라고 하는 건 전에는 다 바이너리인 줄 알았는데 또 텍스트라 그러네, 앞에서.
이런 경우에는 제이슨이나 xml도 역시 데이터를 구조화시켜서 표현을 합니다.
그렇지만 사람이 눈으로 읽을 수 있는 프로그램과 같은 형태로 구성이 돼 있어서 이런 제이슨 파일이라든지 xml 파일은 텍스트 파일이라 그러고.

그다음에 문서 파일이다 그러면 흔히 우리가 생각할 때는 사람이 읽을 수 있는 글로 적혀져 있는 것이 문서 파일 아닌가.
그렇지만 여러분이 직접 pdf나 docx.
docx라 그러지요?
ms워드에서 만든 파일.
또는 엑셀로 만든 파일을 여러분 실제로 텍스트 에디터를 통해서 읽으려고 하시면 못 읽지요.
이거는 해당되는 응용 프로그램만 읽고 여러분에게 보여주고 편집을 할 수 있도록 해 주는 것이기 때문에 바이너리 파일이라고 할 수가 있는 것입니다.

파일 열기에 대해서 보겠습니다.
이런 파일을 연다는 것은 어떤 것인가?
그것은 운영체제 API를 통해서 오픈을 하고 운영체제 메모리 영역에 파일에 대한 정보 블록을 형성해 놓는 것입니다.
파이썬이 하는 일은 그 OS가 만들어 놓은 정보 블록과 자신이 만든 파일 객체를 서로 연관 짓는 것이 연다는 것이고.

그다음에 파일 닫는다는 것은 OS API가 물리적으로 이 파일을 닫고.
자기가 만들어놓았던 정보 블록을 등록을 삭제하는 것입니다.
이에 대해서 파이썬이 하는 일은 객체와 OS에 형성돼 있던 정보 블록의 연관을 끊는 것이 파일 닫기에 해당이 됩니다.
파일 열기 함수.
파이썬의 파일 열기 함수는 open입니다.
호출을 할 때에는 filename과 ext가 필수적인 인수이고 나머지는 선택적인 인수가 됩니다.
옵션 인수가 됩니다.

그 옵션 인수에 해당하는 것이 앞에서 보셨던 mode, buffering, encoding 등등인데.
여기에서는 또 bnf의 변수로 표현을 했지요.
이것은 여러분이 어떤 이름으로 주어도 상관은 없다는 것입니다.
또 어떤 값으로 주어도 상관은 없다 하는 것입니다.

filename.ext의 이름이 지정된 파일을 운영체제 API를 통해 열고 파일에 대한 정보를 담은 객체를 생성하여서 file-object에 배정을 하는 것이 open( )의 호출 구문의 역할이 되겠습니다.

여기서 좀 더 하나하나를 자세하게 보겠습니다.
mode의 데이터 입출력과 내용 속성 제어 값을 갖게 되는데.
인수를 제공하게 되는데.
r이라는 문자로 주면 read의 의미를 갖습니다.
그리고 이럴 때는 읽기만 하지 쓰지는 않기 때문에 파일의 내용이 변경되지는 않습니다.

append라고 하는 것은 지정된 파일이 있는 경우에 기존 내용을 그대로 유지한 채 열게 되고.
지정된 파일이 없는 경우에는 새로 만들어주게 됩니다.
또 새로운 내용을 쓸 때에도 아무 데나 쓰는 것이 아니고 항상 기존 내용의 뒤에만 그 내용을 추가를 하도록 하고 있습니다.

mode에서 w라는 것을 문자를 주었을 때에는 지정된 파일이 있는 경우에 내용 전체를 삭제를 하게 됩니다.
지정된 파일이 있는 경우에는 전제 조건이 있던 내용을 전부 싹 클리어 한다.
또 filename.exists으로 지정된 파일이 없는 경우에는 새로운 파일을 그 이름으로 생성을 해 주게 됩니다.

그리고 overwrite를 지원을 합니다.
append는 지원하지 않지요.
또 read도 지원하지 않습니다.
append도 마찬가지입니다.
append는 추가만 지원하지 읽어볼 수는 없도록 하는 것이지요.
그다음에 create는 지정된 파일이 없는 경우에만 새로운 파일을 생성을 해 줍니다.
지정된 파일이 이미 있는 경우에는 예외가 발생하게 됩니다.

이제 묘한 것이 update입니다.
플러스 기호로 문자 플러스 문자로 나타나게 되는데.
이거는 홀로 사용되지 않고 앞에서 보았던 r이라든지 a라든지 w 또는 x 중 하나와 같이 붙어서 사용을 하게 됩니다.
그리고 또 주의하실 점은 앞에서 보았던 r, a, w, x는 네 가지 중에서 두 개를 합쳐서 사용할 수는 없습니다.

r과 +, a와 + 이렇게 조합해서 사용할 수 있지만 이 네 개는 서로 결합해서 사용할 수는 없습니다.
그래서 r+가 됐을 경우에는 읽으면서 쓸 수도 있다.
또 a+가 됐을 경우에는 append를 할 수 있으면서도 읽을 수 있다.

또 w+가 됐을 때에는 overwrite 할 수 있으면서도 읽을 수 있다.
create+, x+가 됐을 때에는 create를 시켜놓고 거기에 overwrite를 할 수 있으며 읽을 수 있다는 mode로 열어주게 되는 것입니다.

그리고 mode에는 t나 b가 함께 붙을 수 있습니다.
그래서 mode의 값은 최대 세 문자로 구성이 될 수 있습니다.
처음에는 r, a, w, x 중에 하나 그다음에 +가 붙든지 안 붙든지 그다음에 t나 b가 붙든지 안 붙든지.
이런 식으로 해서 세 개, 최소는 하나, 최대는 세 개까지 mode 값이 지정이 될 수 있습니다.

어떤 경우에는 아무것도 지정이 안 되는데 그거는 기본적으로 mode 값은 r, t로 기본 값이 정해져 있기 때문에 항상 mode 값을 아무것도 안 줬을 때에는 파일은 read, 읽기 mode로서 텍스트 파일로서 열린다고 보시면 되겠습니다.

조금 전까지는 파일 열 때의 이야기를 말씀드린 거고 이제부터 파일 닫기에 대해서 이야기를 드리는데요.
파일 닫기는 왜 필요한가.
파일을 열기만 하면 OS의 파일 객체를 만들기 위한.
조금 전에 말씀드렸지요.

파일 정보를 기록하도록 하는 정보 블록을 만들어서 OS에 등록을 해 둔다고 했는데.
거기에는 메모리라는 자원이 계속 필요하게 되지요.
1KB, 또는 수십 킬로바이트의 메모리 자원이 필요하게 됩니다.
그럼 파일을 한두 개 또는 수백 개를 열면 별 문제는 없겠지만 수만 개, 수천만 개, 수백만 개를 파일을 연다.
그런데 닫지를 않고 이런 정보 블록이 계속 생성되기만 하도록 한다 하면 시스템에 영향을 주게 되는 것이지요.

메모리가 부족해져서 시스템 속도가 다운된다든지 심지어는 프로그램이 clash가 일어나게 되는 것이지요.
이런 일을 막기 위해서 항상 파일을 열고 쓰고 사용하고 그다음에는 용도가 없어졌으면 항상 파일은 닫아줘야 되는 것입니다.
이것이 밑에 보시면 바람직한 프로그래밍 스타일이라고 볼 수 있습니다.

이때 메소드 close를 사용을 하게 됩니다.
close를 호출하는 문법은 file-object“.close( )”입니다.
또는 클래스 이름을 바로 써도 되는데 우리는 클래스 이름을 거의 쓸 경우는 없고 항상 오픈을 해서 얻은 file-object“.close( )”으로서 해당 파일을 오픈 되었던 파일을 닫아주고 파이썬에서는 객체와 OS의 정보 블록에 association을 끊어주는 것이고.
그다음에 OS는 파일에 대한 정보 블록을 discard 시켜주는 것입니다.

이런 파일 열고 닫음에 대해서 항상 주의를 해서 열었으니까 닫아야지 열었으니까 닫아야지 이렇게 프로그래머가 기억을 하기가 어려운 경우가 많지요.
이럴 때 도와주는 것이 파일 여닫음 문맥 관리 구문입니다.

이것이 with 구문인데.
with 구문의 문법은 with, with-item 그리고 또 여러 개가 with-item이 나열이 될 수 있는데 그때는 콤마로서 각각의 with-item을 구별을 하면서 쭉 나열을 해 주게 됩니다.
몇 개인가 나열을 해 주고 그다음에 콜론 그리고 줄 바꾸든지 해서 with-suite를 실행을 하게 됩니다.

with-item이라는 것은 expression 옵션으로서는 as identifier가 있습니다.
그리고 with 구문 문법과 동일한 것으로서 아래와 같은 문법이 있는데.
두 가지는 다 동일하다고 볼 수 있습니다.
아이템이 쭉 나열된 것은 with 밑에 또 with, 속에 또 with, with, with가 서로 nest, nest, nest 돼 있다.
포함, 포함, 포함돼 있다고 하는 것을 의미를 하는 것입니다.

with 구문의 동작 절차를 보면 문맥관리자라는 것은 with-item을 실행하는 과정에서 expression을 실행하고 그 결과를 객체 identifier에 배정을 해 줍니다.
또 문맥관리자는 객체 identifier의 메소드인 _enter_( )를 실행하여서 객체 identifier의 셋업 작업을 수행을 합니다.

그다음에 with-suite를 실행을 하는 것이지요.
다 했으면 문맥관리자가 객체 identifier의 메소드 중의 하나인 _exit_( )를 무조건 실행하여서 객체 identifier에 대해서 클리어 작업을 수행을 하는 것입니다.

이 identifier는 여러 가지 종류의 것이 있을 수 있습니다.
이번 차시에서 이 identifier에 해당되는 것은 바로 file-object입니다.
그렇지만 string object가 될 수도 있고 문맥 관리가 필요한 여러 object들이 다 이 identifier에 들어와서 with 구문의 도움을 받을 수가 있는 것입니다.

그리고 주의할 거는 그런 with 구문의 도움을 받으려면 여기에 들어오는 identifier라고 하는 객체는 항상 enter와 exit 두 메소드는 그 이름을 가지고 항상 정의를 하고 있어야 된다는 것입니다.
바로 이 이야기지요.

객체 identifier에 대한 유의사항이 객체 identifier는 메소드 _enter_( )와 _exit_( )를 가지고 있어야 된다.
그 이름 그 자체로 갖고 있어야 됩니다.
만일 identifier의 베이스클래스에 이런 메소드들이 없으면 만들어줘야 됩니다.

또 문맥관리자의 예외 대책으로서는 with-suite 실행 중 예외가 발생해서 비정상적으로 중지되더라도 _exit_( )를 실행하고 예외를 처리하도록 하고 있습니다.
이거는 여러분이 걱정하지 않으셔도 됩니다.

문맥관리자가 알아서 해 주는 일이기 때문에.
그래서 도중에 어떤 예외가 발생해서 빠져나간다 하더라도 만일 파일이 열려 있었다면 파일을 닫을 거는 닫고 나간다는 것입니다.

파일 여닫음 문맥 구문의 문법은 앞에서 보셨던 일반적인 with 구문과 유사하고 다만 with-item이 open이라는 오퍼레이션으로 이루어져 있다.
그 expression 파트는 open이고 as 그다음에 identifier 파트는 file-object라는 것으로 대입만 하면 되는 것입니다.

이렇게 문맥관리자가 파일을 관리하는 절차는 문맥관리자는 객체 file-object의 메소드 _enter_( )에서 파일을 열고 파일 정보를 file-object에 셋업을 해 주게 됩니다.
또 with-suite를 실행을 합니다.
이때 file-object를 사용해서 파일 다루기가 일어나는 것이지요.

그다음에 파일을 사용하기를 다 했으면 문맥관리자는 객체 file-object의 메소드 _exit_( )를 실행함으로써 OS API를 통해 파일을 닫고 객체 file-object의 파일 상태 정보를 갱신한다.
즉 OS가 가지고 있는 정보 블록과 자신을 연관 관계를 끊는다는 것을 실행을 하는 것입니다.

그다음에는 파일 내용을 읽는 과정에 대해서 말씀을 드리겠습니다.
파일을 읽을 때 메소드 read를 사용을 합니다.
메소드 구문에 대해서 화면에 나와 있으니까 여러분이 참조를 해 주시면 되겠습니다.

메소드를 정의하는 구문.
그다음에 메소드를 호출하는 구문.
다 비슷비슷하기는 합니다.
그리고 정의하는 구문에서 read size에 bnf 변수 표시가 돼 있지요.
일반적인 스트링으로 표시가 돼 있지 않습니다.
이것은 메소드에 대한 파라미터가 확정돼 있지 않다 하는 것입니다.

왜 그럴까?
그 밑에 유의사항을 읽어보시면 file-object나 file-class의 메소드는 C-level API로서 지금 구성이 돼 있습니다.
우리가 사용하는 파이썬 인터프리터가 그렇게 만들어진 것이지요.
그렇기 때문에 파라미터 이름이 파이썬에 제공되지를 않았으므로 호출 시에 우리가 키워드 인수로 사용을 할 수가 없습니다.

즉, read 메소드가 가지고 있는 파라미터의 이름이 우리한테 밝혀지지가 않은 것입니다.
그래서 우리는 그 이름을 사용할 수가 없고 파라미터 이름을 그대로 키워드 인수로서 사용할 수는 없고.
Positional 인수로서 그 값만 넣어줄 수가 있다는 것.
이 점을 유의하시면 되겠습니다.

이 메소드의 기능과 서비스를 보면 size가 지정되면 file-object의 현재 위치로부터 size bite만큼을 읽어냅니다.
또 size가 없으면 처음부터 끝까지 읽어내게 되고 텍스트 내용은 문자열 유형으로 읽어냅니다.
바이너리 내용이라면 바이너리 파일이라면 bite열, bytes라는 유형으로 읽어내게 됩니다.

이제 readline 메소드에 대해서 또 보겠습니다.
메소드 구문은 역시 화면에 나와 있는 대로 여러분이 참조를 해 주시면 되겠습니다.
file-object“.readline 파라미터 이름이 size로 돼 있고 그다음에 메소드 호출 구문은 contents는 file-object”.readline(“[size]“)“로 돼 있습니다.

이런 메소드의 기능과 서비스를 보면 인수가 지정되면 한 줄을 초과하지 않으며 최대 size bite 또는 문자만큼의 내용을 읽어내는 것입니다.
인수 size가 지정되지 않으면 무조건 한 줄을 읽게 되고 텍스트 및 바이너리 파일에서 줄의 끝 end of line은 '＼n'이나 b' ＼n' 으로 표현이 됩니다.
텍스트 파일에서 읽어낸 내용을 str 유형으로 리턴을 하게 되고 바이너리 파일에서는 bytes 유형 객체로 리턴을 하게 됩니다.

그럼 맨 앞으로 가서 size가 지정됐을 때 한 줄을 초과하지 않으며 최대 size bite/문자 이하의 내용을 읽어낸다.
이 내용이 무언지 그림으로 표현을 하면 쉽게 표현이 될 텐데.
만일 지금 현재 파일 포지션에 있는 줄의 길이가 100이에요.
100bite이다, 또는 100문자로 이루어져 있다.

그런데 size가 200이라고 지정이 돼 있으면 어떻게 될까요?
그다음 줄에서도 어떻든 200문자 또는 bite를 읽어낼까요?
그게 아니고 100문자에 해당하는 한 줄만 읽어낸다는 것입니다.
실제 줄은 현재 포지션에 있는 줄은 100문자인데 여기서 size가 50만 지정이 돼 있다.
그러면 한 줄 다 읽는 것이 아니고 그 줄의 처음부터 중간까지 50자만 읽어낸다는 것.
그런 뜻을 가지고 있습니다.

readlines의 기능과 서비스를 보겠습니다.
인수 size-hint가 지정되면 읽어낸 줄의 크기가 size-hint bite 또는 문자에 도달하거나 초과하는 최소한의 개수의 줄로 구성된 리스트를 리턴한다.
복잡하지요?

밑에 있는 그림을 한번 참조를 해 주시기 바랍니다.
세 줄이 있습니다.
한 줄은 100문자, 두 번째 줄은 120문자, 세 번째 줄은 또 100문자로 구성이 돼 있는데.
읽어내라고 하는 것이 120문자 size-hint는 120문자로 지정이 돼 있다.
그러면 100문자는 첫 줄에 다 읽어낼 수 있는 숫자이기 때문에 100문자까지는 다 읽어냈어요.
한 줄을 읽어낸 거지요.

그다음에 20문자가 남았습니다.
20문자를 가지고 두 번째 있는 줄에 앞부분 20문자만 읽어낼까요?
그게 아니고 어떻든 읽어내야 되는 size-hint에 해당하는 문자들이 문자열이 다음 줄에도 걸려 있으면 중간까지 걸려 있던 처음의 한 문자만 걸려 있다 하더라도 그 걸려 있는 줄은 몽땅 읽어낸다는 것입니다.
그래서 몇 문자, 두 줄을 읽어내되 문자수로 본다면 220문자를 읽어내게 된다는 뜻이 첫 번째 텍스트 여러분이 읽으신 문장의 뜻이 되겠습니다.

두 번째 size-hint가 지정되지 않으면 처음부터 끝까지 모든 파일의 내용을 읽어낸다.
모든 줄을 읽어낸다.
그래서 세 줄을 다 읽어내면 각 줄을 아이템, 아이템, 아이템 세 개의 아이템을 가진 리스트로 구성을 해서 리턴을 하게 된다는 것입니다.
또 텍스트 파일의 내용을 읽어내면 스트링 유형의 리스트로 리턴을 하게 되는 것이고.
바이너리 파일의 내용을 읽어내면 bite 유형 항목의 리스트로 리턴을 하는 것입니다.

이번에는 파일 내용을 쓰는 과정에 대해서 살펴보겠습니다.
그 기능들과 서비스를 살펴보겠습니다.
대표적인 메소드가 write입니다.
메소드 정의 구문은 화면에 나와 있는 내용을 여러분이 보시면 되겠고요.

text-file-object인 경우는 write text-string 또 바이너리 file-object인 경우는 write 메소드에는 bytes-buffer에 해당하는 인수가 파라미터가 정의가 될 것이고 또 거기에 해당하는 인수를 주면 되는 것입니다.

텍스트 파일 객체 메소드 text-string은 스트링 유형이 되는 것이고.
또 바이너리 파일 객체 메소드의 파라미터 bytes-buffer는 bite 유형이다.
그 차이만 여러분이 알고 계시면 되겠습니다.

이런 write 메소드를 호출하는 것도 같은 모양입니다.
다만 이퀄 기호가 있고 그 왼쪽에는 카운트가 주어졌네요.
그 뜻은 write가 주어진 text-string이나 bytes-buffer에 해당하는 데이터 블록을 쓸 때 실제로 몇 문자 또는 몇 bite까지 써줬느냐.
그 수를 리턴을 해 주는 것입니다.

write 메소드의 기능과 서비스를 보면 주어진 인수 text-string이나 bytes-buffer의 내용을 유형에 맞춰 처리하여서 파일에 쓰는 것이고.
그게 서비스고 실제 파일에 쓴 문자의 수 또는 bite 수를 리턴을 해 줍니다.
그리고 bytes-buffer를 다 처리하지 못했는데 OS 입출력이 정지, 중지되면 예외가 BlockingIOError라는 예외가 발생하게 됩니다.

다음에는 메소드 writelines입니다.
메소드의 정의 구문을 보면 텍스트 파일과 바이너리 파일의 경우에 writelines를 쓸 수 있는데.
거기에 들어가 있는, 정의돼 있는 파라미터는 lines-iteration과 bytes-iteration이라고 표현이 돼 있습니다.

lines-iteration은 줄-문자열의 iterable 객체이고 bytes-iteration은 bite열의 iterable 객체입니다.
iterable 객체라는 것 알고 계시지요.
튜플, 스트링, 리스트, 셋, 맵.
이런 것들이 iterable 객체가 되는 것입니다.
이걸 통틀어서 이런 것들 중에 어느 하나면 된다는 것입니다.
iterable 객체 또 그다음에 writelines는 리턴 값은 주지 않습니다.

메소드를 호출하는 구문도 역시 비슷합니다.
거의 같다고 볼 수가 있지요.
리턴 하는 것이 없기 때문에 다른 것과는 다르게 이퀄 기호라든지 왼쪽에 있는 참조를 필요로 하지는 않습니다.
그래서 인수 lines-iteration은 각 항목이 스트링 유형인 iterable 객체가 될 것이고 bytes-iteration은 각 항목이 bytes 유형인 iterable 객체가 되는 것입니다.

그다음에 메소드의 기능과 서비스를 보면 그 줄의 iteration을 파일에 그대로 다 써주는 것이 메소드의 서비스가 되겠습니다.
앞에서 보셨던 write라고 하는 것은 지정된 어떤 주어진 버퍼, 줄의 개념이 아니고 버퍼.
어떤 한 덩어리를 써주는 것이고 bytes lines라고 하는 것은 여러 줄로 이루어진 리스트라든지 여러 줄의 셋, 한 덩어리를 또 써준다는 것이 차이가 있겠습니다.

지금까지 파일 쓰기에 대한 두 가지 대표적인 메소드를 보았고요.
이제는 이 파일을 열 때 그 모드 또 사용하는 메소드들과 통합해서 생각을 해 볼 때 크게 두 가지로 나누어볼 수 있습니다.
겹쳐 쓰는 것과 추가한다는 것으로 나눠볼 수가 있고.
그리고 이런 모드 또는 오퍼레이션에서 주의를 해야 될 사항들이 있어서 그걸 정리해서 말씀을 드리고자 하는 것입니다.

이렇게 파일을 열고 닫고 파일을 읽고 또 파일을 쓰는 과정까지 말씀을 드렸고 그런 파일을 읽고 쓰는 것을 좀 더 자유롭게 하는 방법에 대해서 이어서 말씀을 드리겠습니다.

조금 전에 말씀드렸던 것은 바로 파일 포인터에 관한 이야기입니다.
파일 포인터를 어떻게 이동을 시키는가.
또 파일 포인터가 현재 어디에 있는지 그 위치를 어떻게 확인을 하는가.

이런 능력이 있다면 우리가 자유롭게 파일의 어느 곳에서도 파일 포인터를 중심으로 해서 읽기도 하고 쓰기도 할 수 있는 능력을 갖게 되는 것입니다.
좀 더 플렉시블하게 읽고 쓸 수가 있다는 것이지요.
그 대표적인 메소드가 파일 포인터 이동에 관해서는 seek가 되는 것이고 위치 확인에 대해서는 tell이라는 메소드가 됩니다.

먼저 메소드 seek를 보겠습니다.
메소드 정의 구문은 file-object.seek에 파라미터가 두 개가 정의가 돼 있습니다.
offset과 origin이 정의가 돼 있고요.
origin은 디폴트 값 0를 가지고 있습니다.
그리고 역시 seek도 C-level API이므로 키워드 인수를 줄 수 없고 오직 위치 인수만 줄 수 있습니다.

호출은 조금 전에 말씀드렸던 대로 두 파라미터를 줄 수 있는데 offset은 필수적으로 줘야 됩니다.
그리고 origin은 안 줘도 되는데 안 주면 0라는 값을 디폴트로 사용하게 되는 것이지요.
이 offset의 뜻은 파일 포인터로부터 어느 정도 거리로 떨어져 있는가라는 것입니다.
범위의 길이를 거리를 주게 되는 것이지요.

거리의 단위는 몇 문자 떨어져 있는가, 몇 bite 떨어져 있는가.
그 bite 수 또는 문자수가 됩니다.
그리고 origin이라고 하는 것은 0값을 가지면 BOF입니다.
1이라는 값을 가지게 되면 현재 있는 파일 포지션의 현재 포지션을 뜻하는 것이고 2라고 하는 값을 가지면 EOF, 파일의 끝을 뜻하게 됩니다.

메소드의 동작을 보겠습니다.
offset이 양수이면 BOF를 지금 저의 왼손, EOF를 저의 오른손이라고 보겠습니다.
offset이 양수이면 레이저 포인터가 BOF 쪽으로부터 EOF로 진행을 하는데.
어느 정도 진행을 하는가라는 것을 뜻하는 것입니다.

음수이면 반대로 EOF로부터 BOF로 진행을 하는데 역행을 하는 것이지요.
얼마만큼 역행을 하는지를 표현을 해 주는 것입니다.
그래서 -3이라고 그러면 하나, 둘, 셋.
세 문자 또는 세 bite를 역행을 했다고 보면 되는 것입니다.

origin이 0인 경우 BOF로부터 offset이 bite 진행한 곳으로 포인터를 이동하는 것이고.
origin이 1인 경우에는 현재 포인터 위치로부터 offset bite의 진행 또는 역행으로 포인터를 이동을 하는 것입니다.
그리고 origin이 2인 경우에는 EOF로부터 offset이 bite 역행하는 곳으로 이렇게 포인터를 BOF 쪽으로 이동을 한다는 것을 뜻합니다.
이때는 offset이 대부분의 경우 음수가 돼야 되겠지요.

이제 위치 확인에 관한 메소드를 보겠습니다.
tell입니다.
tell은 file-object“.tell( )”입니다.
얘는 파라미터를 갖지 않습니다.
호출도 인수를 줄 필요가 없습니다.
이 메소드의 기능은 현재 이 포인터가 어디에 있는가.
BOF에 있는가 EOF에 있는가 그 중간 어디에 있는가라는 것을 BOF로부터의 offset 값으로서 리턴을 해 주는 것입니다.
호출 구문도 마찬가지지요.
인수를 줄 필요는 없습니다.
다만 리턴을 하는 값은 현재 포인터의 위치가 됩니다.

그래서 메소드 기능을 보면 현재 파일 포인터의 위치가 바로 BOF에 딱 붙어 있다.
그러면 제로가 나오겠지요.
또 EOF에 딱 붙어 있다.
그러면 이 파일 전체 사이즈가 나오게 될 것입니다.
중간에 포인터가 있다.
그러면 어떻게 될까요?
BOF로부터 몇 문자 또는 몇 bite만큼 떨어져 있는가.
그 숫자가 리턴된다는 것입니다.
그것이 포지션으로 나온다는 것이지요.

이렇게 이번 시간에는 파일을 열고 닫고 그다음에 열려진 파일을 가지고 읽고 쓰는 과정에 대해서 살펴보았고.
또 읽고 쓰는 것을 좀 더 세밀하게 자유롭게 할 수 있는 방법에 대해서도 살펴보았습니다.
