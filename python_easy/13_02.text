-------------------------------------------------------------
13_03. 파일 다루기 실습
-------------------------------------------------------------

[3페이지]

조금 전에 다루었던 파일 핸들링, 파일 다루기에 대해서 실습을 하겠습니다.
지금 이미 화면에는 ANACONDA 화면이 보이고 있고요.
여기에서 VS Code를 시작을 합니다.
VS Code가 열렸고 여기에서 차시를 구별하기 위해서 이번 차시에 대한 Workspace를 만들겠습니다.
지난번 작업했던 내용이 조금 보이고 있지요.
여러분의 홈 디렉토리에서 파이썬 프로그래밍이라는 디렉토리.
파일 핸들링이라는 디렉토리 들어가고.
여기에 Workspace에 대한 새로운 폴더를 만들어보겠습니다.

PP 13 WS라고 이름을 지어보겠습니다.
그다음에 이 디렉토리 안으로 들어가서 파일 이름을 PP 13 FileHandling이라는 이름으로 Workspace 파일을 만들겠습니다.
그다음에 이 Workspace에 우리의 작업 폴더.
조금 전에 만드셨지요.
PP 13 WS.
이 PP 13 WS라는 디렉터리를 Add를 하겠습니다.
지금은 아무것도 없습니다.
이제부터 코드를 만들어가면 되는 것이지요.

첫 번째로는 파일 열고 닫기 실습을 하려고 하는데.
앞으로 실습을 위해서 필요한 샘플 파일 하나를 만들도록 하겠습니다.
그 이름은 myTextFile_to_read.dat라는 이름으로 만들겠습니다.
New File myTextFile_to_read.dat.
read open을 하는데 열고자 하는 파일이 없으면 오류가 나지요.
예외가 발생하지요.
그래서 파일을 하나 만들어둬야 되는 것입니다.

파일 내용은 유명한 사람들이 이야기한 내용을 집어넣도록 하겠습니다.
그 이야기를 한 사람 이름과 함께 집어넣도록 하겠습니다.
그리고 save를 하겠습니다.
이제 우리 작업장에는 write를 하고자 하는 파일은 없지요.
이 TextFile은 이거 하나밖에는 없습니다.
지금 디렉터리 익스플로러에는 파일이 하나밖에 없다는 것을 보여주고 있지요.

이제는 또 새로운 프로그램 파일을 코딩을 하겠습니다.
파일을 열고 읽는 그런 프로그래밍을 해 보겠습니다.
그 이름은 open_myFile_to_read.py로 하겠습니다.
두 번째 파일이 열렸지요.
첫 번째 만들었던 데이터 파일은 일단 닫고.
코딩을 시작을 하겠습니다.

코딩을 끝냈는데요.
조금 전에 만들었던 myTextFile_to_read.dat 이 파일을 열어서 f1에 배정을 하고.
그 파일이 어떤 Attributes를 갖고 있는지 속성들, 파일 객체의 속성들을 인쇄를 하고.
그 속성 중에서 CHUNK_SIZE라든지 class, sizeof, closed 돼 있는지 상태.

encoding 방식, 그다음에 파일에 대한 line_buffering, mode, name 그리고 readable 한지, writable 한지 등을 검사를 한 다음에 일단 closed 시키도록 하겠습니다.
그러고 나서 closed 된 다음에 이 파일이 closed 됐는지를 또 확인을 Attributes를 통해서 하도록 하겠습니다.

이제 실행을 해 보겠습니다.
이 파일 이름을 찍고 여기에 Run Python File in Terminal.
실행이 됐습니다.
실행 결과를 보니까 이와 같이 처음에 f1이라고 하는 객체가 가지고 있는 Attributes가 리스트에 담겨서 나오고 있지요.
이 모양을 화면이 보이고 있는 것입니다.
전체 writelinesr까지 보였고.

그다음에 CHUNK_SIZE는 약 8KB 정도 되고 있습니다.
그다음에 size는 192bite인데.
그 192bite라는 것은 f1이 가지고 있는 모든 내용들을 담고자 한 객체를 담고자 한 메모리 사이즈입니다.
encoding은 cp949고.
그다음에 buffering은 쓰지 않고 있고.
mode는 r mode로 열렸고.
이 파일의 이름은 myTextFile_to_read.dat라는 것이 보이고.

readable 한가?
그렇다.
writable 한가?
False, 그렇지 않다.
또 나중에 closed 시킨 다음에 print를 한 거지요.
closed after f1.close 한 다음에 closed라는 플래그, Attributes의 값은 True이다.
프로그램이 완전히 끝났다고 여기에 Program done이 표시가 된 것입니다.

이렇게 함으로써 있는 파일을 하나 열고 그 파일 열기로부터 형성된 파일 객체 안에 주요 Attributes들이 어떤 값을 갖고 있는지 확인을 해 보았습니다.
다음번에는 텍스트 파일 쓰기 모드로 여닫는 과정을 코딩을 통해서 확인을 해 보겠습니다.
이제 새로운 파일을 또 하나 만들겠습니다.
이름은 open_myFile_to_write.py로 하겠습니다.

열기 모드로 열고 닫는 것을 코딩을 한 것입니다.
코딩을 해 보겠습니다.
코딩이 됐습니다.
내용을 잠깐 보겠습니다.
myTextFile_to_write.dat.
현재 이 익스플로러 상에는 이 이름을 가진 파일이 없습니다.
이 파일 이름을 주고 write 모드로 open을 시키고 거기에서 생성된 리턴된 file-object를 f2에 받도록 했습니다.

그리고 이 객체에 있는 주요 Attributes인 mode, name, readable, writable 값이 무엇인지 확인을 하고 close를 하고 프로그램을 마치는 과정이 되겠습니다.
실행을 시켜보겠습니다.
save를 하고.
지금 프로그램 파일의 이름이 open_myFile_to_write입니다.

Run Python File in Terminal.
실행이 됐습니다.
어떤 부분이냐면 이 부분입니다.
mode는 w이고 name은 myTextFile_to_write.dat.
그다음에 readable은 read 할 수 없다.
write 할 수 있다.
False, True로 나타내고 있습니다.

그다음에는 파일을 추가, 생성, 갱신하는 과정에 대해서 열고 닫는 과정을 한꺼번에 코딩을 통해서 확인을 해 보도록 하겠습니다.
파일의 이름은 추가를 하겠는데요.
파일의 이름은 open_myFile_to_append, 그다음에 update, create라는 aux.py로 이름을 지어보겠습니다.

새로운 코딩을 시작을 하겠습니다.
코딩이 일단 완성이 됐습니다.
같이 한번 보시겠습니다.
myTextFile_to_append.dat를 append mode로 열어서 파일 객체를 f3에 배정을 한다.
create mode를 열어서 또 read 하면서 write도 할 수 있도록 update mode로 여는 과정을 open을 시켰습니다.

파일 이름에는 aux라고 했는데.
여기에서 그 순서를 따르지는 않았습니다.
a, x, u 순서로 open을 시켰습니다.
그리고 각각의 파일 객체들이 어떤 속성을 가지고 있는지 비교하기 위해서 주로 readable 그다음에 writable 이 두 메소드에서 나타나는 상태 값만을 확인을 했습니다.

즉 이렇게 열려 있는 파일이 읽을 수 있는 것인지 쓸 수 있는 것인지 그런 종류만 비교 판단을 한 것입니다.
그리고 다 파일을 닫은 다음에 프로그램을 종결시켰다는 표시로서 Program done을 인쇄를 하도록 했습니다.
실행을 시켜보겠습니다.

이 파일의 이름이 open_myFile_to_aux.py지요.
이 파일을 Run Python File in Terminal로 실행을 하겠습니다.
여기에서 error가 발생을 했습니다.
예외가 발생했는데.
어떤 예외인지 잠깐 보겠습니다.
f5 TextFile_to_update.dat라고 하는 이 파일이 지금 없습니다, 여기에.
dat 파일을 보면 append, create, read, write까지는 있는데 update라고 하는 이 파일이 없네요.
이 파일을 하나 만들어줘야 됩니다.
어떻게 만들어줘야 될까요?

그런데 이런 예외가 왜 발생했지요?
이 r+ mode로 열 경우에는 먼저 r mode로 연 다음에 write 기능까지 허용을 한다고 아까 말씀을 드렸었지요.
이 r mode로 파일을 open을 하는 경우에 그 과정에서 이미 그 파일은 있어야 되는데 없기 때문에 FileNotFoundError가 예외로 발생을 한 것입니다.
뭔가 준비가 덜 됐다는 거지요, 실습을 하기 위한 거.

그럼 지금 다시 한번 실습을 위해서 그 파일을 만들겠습니다.
create하고 my, 이름이 뭐지요?
TextFile_to_update.dat라는 파일을 하나 만드는데 여기에 내용은 사실 없어도 됩니다.
어떤 내용이 들어 있든 안 들어 있든 별 상관은 없습니다.

test data file for updating이라고 하는 줄을 하나 넣고 save를 하고.
그다음에 이 파일을 닫도록 하겠습니다.
다시 한번 프로그램을 실행을 시켜보겠습니다.
이제 또 한 번 오류가 발생했습니다.
이제는 또 어떤 오류가 발생했을까요?
앞에서 1차적으로 우리가 프로그램을 실행을 시켰을 때 create에 의해서 myTextFile_to_create.dat가 생성이 이미 됐습니다.

됐는데 그 생성된 파일을 그대로 두고 다시 한번 create mode로 open을 시키려고 했기 때문에.
이미 있는 파일에 대해서 create 시키려고 했다는 뜻에서 예외가 발생을 한 것입니다.
이럴 때 해결 방법은 무엇인가요?
그 파일을 지워야 되지요.
어디에 있을까요?

myTextFile_to_create.dat 바로 이 파일을 하나 선택을 해서 Delete 시켜야 되겠습니다.
그러고 나서 다시 aux를 실행을 시키겠습니다.
이제는 됐지요.
그리고 f3는 a mode로 append mode로 open이 된 것입니다.
그래서 readable은 할 수 없습니다.
read 할 수는 없고 그다음에 또 f3에 writable은 True입니다.
True이고 그 외에 f4나 f5는 동일하지는 않습니다.

세 개의 메소드들이 내놓는 값이 모두 동일하다면 더블 이퀄 즉 같다는 것이 모두 참이 되기 때문에 True라는 값이 나오겠지만 이 셋 중에 어느 하나라도 다른 것과 다르기 때문에 False가 나왔습니다.
그런 반면에 writable을 비교를 세 개를 한꺼번에 했을 때에는 True가 나왔습니다.

이 이야기는 무엇이지요?
f3나 f4나 f5는 전부 write 할 수는 있다.
즉 append라든지 create라든지 read update, 즉 update라는 것은 다 write는 할 수는 있는데 그 세 개를 전부 read 할 수는, 읽기 동작을 시킬 수는 없다.
어느 경우에 읽기 동작이 안 될까요?
바로 append하고 create인 경우에는 읽기 동작이 안 되는 것이지요.
그리고 update는 읽기 동작은 가능한 것이고.

그러니까 f3 readable에서는 False가 나오고 f4 readable에서도 False가 나오는데 f5 readable에서는 True가 나오기 때문에 False, False, True 셋이 일괄적으로 다 같은 게 아니기 때문에 False가 최종적으로 나온 것입니다.
이런 관계식을 통해서 각각의 mode로 open을 시켰을 때 읽을 수 있는 것은 어느 경우이고 또 쓸 수 있는 경우는 어느 것인지 판단을 할 수가 있는 것이지요.

이제는 바이너리 파일 읽기 모드로 여는 코딩을 해서 실습을 해 보겠습니다.
이제 새로운 프로그램 코드를 작성을 해 보겠습니다.
이름은 open_myBinFile.
아까는 그냥 myFile이라고 했는데 디폴트로 텍스트 파일을 의미해서 굳이 myTextFile이라고 이름을 붙이지는 않았고 이제는 구별을 하기 위해서 myBinFile이라는 이름으로 넣도록 하겠습니다.
to_read, read를 하기 위한 목적으로 파일을 열고 닫는 코딩을 하는 것입니다.

코딩을 이제 시작을 하겠습니다.
코딩이 됐습니다.
myBinFile_to_read.dat라는 파일을 rb.
무슨 뜻이지요?
read 하겠다.
어떤 속성으로?
바이너리 속성으로 read 하겠다는 그 mode를 지정을 해 준 것입니다.
그 열린 결과로서 생긴 file-object를 f6에 배정을 해 주었습니다.

이때 f6의 class는 어떤 class 이름을 가지고 있을까?
또 size는 어떻게 변했을까?
앞에서 size를 보았을 때 192bite 정도 됐었지요.
text mode의 file-object를 size를 print를 해 봤을 때는 192bite 정도 됐었습니다.
이제는 몇 bite 정도 나올까?
그리고 닫고 Program done으로서 프로그램 종료.
정상적인 종료했음을 표시하도록 했습니다.

이제 실행을 시켜보겠습니다.
open_myBinFile_to_read.py를 Terminal에서 실행을 시켜보겠습니다.
이때 또 오류가 발생을 했지만 어떤 오류가 발생했을까요?
myBinFile이 없어요, myBinFile이.
그 BinFile을 하나 만들어줘야 되지요.
역시 똑같은 이유입니다.

그래서 비어 있는 파일 하나를 아무거나 만들어보도록 하겠습니다.
이제 그 BinFile을 준비하도록 하겠습니다.
특별하게 내용을 쓸 거는 없습니다.
그냥 비어 있는 상태로 Ctrl S로서 save만 시키고 닫도록 하겠습니다.

그리고 다시 한번 실행을 하겠습니다.
실행이 끝났는데요.
class 이름을 보니까 _io.BufferedReader라는 이름으로서 class 이름이 나와 있음을 알 수가 있습니다.
그리고 객체의 size는 8344bite입니다.

이제 바이너리 파일을 쓰기, 첨가, 추가, 그다음에 업데이트 그리고 생성하는 모드로 여닫겠습니다.
앞에서는 텍스트 모드 파일을 쓰기 모드도 별도로 한번 열고 닫고 해 봤는데.
지금은 그렇게 한 번은 했었으니까 따로 따로 할 필요는 없고 이 네 가지를 한꺼번에 처리를 하도록 하겠다는 것입니다.

코드 파일을 새로 생성을 하겠습니다.
뭐라고 정할까요?
waux_myBinFile.
이름을 바꾸겠습니다.
open_myTextFile_to_waux.py로 하겠습니다.
코딩을 하겠습니다.
코딩이 끝났습니다.
약간 길기는 하지만 크게 하는 일은 없습니다.

처음 f7에 대해서는 바이너리 파일을 write mode로 열고 f8라는 것은 이 파일을 append.dat 파일을 append mode로 열고.
또 update.dat 파일을 write mode로 여는데 거기에 update 할 수 있도록 하는 플러스 기호를 덧붙인 것입니다.
여기에서 앞에서는 read+를 붙였었지요.
그랬더니 파일이 없는 경우에는 open을 하지 못하고 예외가 발생했습니다.

지금은 조금 경험을 살려서 파일이 원래부터 없으면 생성을 하도록 하는 write를 했는데.
단점은 뭐지요?
이미 그 파일이 있는 경우에는 파일에 있는 내용을 완전히 없앨 수 있는 위험이 있다는 것이 하나의 단점이겠지요.
여기서는 그런 테스트 실습에서는 크게 문제가 되지 않기 때문에 write+로 열기로 하겠습니다.

그리고 create는 역시 create.dat 이 바이너리 파일인데 reate.dat로 열도록 하겠습니다.
지금 이 디렉토리의 파일 리스트를 보면 dat 파일 중에서는 바이너리 파일 중에 create 용어로 만들어진 파일이 없기 때문에 예외는 일어나지 않을 것으로 보입니다.
일단 다 연 다음에 class 이름과 size만을 검토를 하도록 하겠습니다.

실행을 시켜보겠습니다.
open_myBinFile_to_waux.py입니다.
이것을 실행을 시키겠습니다.
실행 결과를 같이 한번 보시지요.
write mode로 열어서 그 객체를 f7에 배정을 했습니다.
f7에 해당되는 class 이름을 보니까 io.BufferedWriter라는 이름으로 class의 이름이 배정이 됐습니다.

또 append mode로 열었을 때에도 똑같은 class가 베이스가 됐음을 알 수 있고.
update mode로 열었을 경우에는 이름이 조금 달라졌습니다.
BufferedRandom으로 이름이 다르지요.
그다음에 create 한 경우에는 역시 BufferedWriter로서 class가 베이스로 적용이 됐음을 알 수 있습니다.
그리고 객체들의 size는 전부 8344bite로 동일함을 알 수 있습니다.

이런 과정을 통해서 우리가 알 수 있는 것은 text mode file을 열고 닫을 경우에는 text io 래퍼라고 하는 class가 공통적으로 다 베이스가 돼서 객체가 생성됐음을 알 수 있는데.
write 경우에는 쓰기를 할 수 있는 경우, 그다음에 특히 바이너리 파일인 경우에는 Buffered라고 하는 것은 기본적으로 붙지만 여기에 Reader, Writer, Random이라고 하는 세 가지 종류의 class가 사용이 되고 있다는 것을 알 수가 있습니다.

초기 단계에서는 이것들을 구별을 하는 것이 큰 문제가 되지는 않지만.
나중에 우리가 정교한 프로그램을 만들 때는 이렇게 각각에 적용된 class가 무엇인지를 아는 것도 중요한 문제로 될 수가 있는 것이기 때문에 지금 단계에서 한 번 알아놓고 있는 것입니다.

이제는 문맥관리자를 이용한 파일 여닫기에 대해서 실습을 해 보겠습니다.
문맥관리자를 이용한다는 것은 텍스트 파일이든 바이너리 파일이든 차이가 없기 때문에 텍스트 파일만 가지고 실습을 해 보겠습니다.

우선 두 개의 파일.
조금 전에 실습 과정을 통해서 만들고 또 생성된 파일입니다.
myTextFile_to_read.dat 그리고 myTextFile_to_write.dat 이 두 파일을 열고 read 구문으로서 자동적으로 닫고 나가는 모습을 실습을 코딩을 통해서 해 보겠습니다.

파일 이름은 어떻게 정하면 될까요?
with_myFile_open_close.
with_open_close_myTextFile.
TextFile까지는 쓸 필요 없지요.
myFile.py로 해 보겠습니다.

코딩된 내용을 보시겠습니다.
우선 뭔가 Exception을 임의로 발생시키기 위해서 MySomeException이라고 하는 class를 하나 만들었습니다.
베이스 class는 Exception라는 class이고요.
내용은 사실 없습니다.

이 Exception을 발생시키는 것만이 중요하기 때문에 내용은 넣지 않고 pass로서 채워 넣었습니다.
그다음에 try를 하는 구문으로 들어가고 with 구문이 지금 실습을 통해서 확인해 보고자 하는 with 구문이 어디까지일까요?
여기까지 with 구문이 되겠습니다.

다시 한번 with 구문은 바로 이 부분까지입니다.
바깥에 있는 with로서 read.dat 파일을 열어서 f1에 배정을 했고.
안쪽에 있는 with 구문으로서는 write.dat 파일을 열어서 f2에 배정을 했습니다.
또 배정돼 있는 파일 객체 f1과 f2를 비교를 하는데.
readable을 비교하고 writable을 비교하는 문장을 넣었습니다.
바로 이 부분 print문이 with의 suite라고 할 수가 있지요.

그런데 with에서 빠져나가기 전에 suite 중에 일부러 예외를 발생시켜서 빠져나가도록 했습니다.
이렇게 한 이유는 suite를 수행하는 도중에 예외가 발생하면 제대로 파일을 다 닫고 나가는 것인지 확인을 하기 위해서 이런 코드를 만들어놓은 것입니다.

raise를 했기 때문에 당연히 이 print문 Outside with 이 부분은 실행이 되지 않고 바로 Except 부분으로 넘어가게 되겠지요.
그럼에도 불구하고 f1 closed와 f2 closed라고 하는 것은 두 파일이 닫혔을 때는 모두 True가 되겠지요.
True라는 값을 가지겠지요.

또 파일이 열려 있을 때는 False라는 값을 가지게 되는 속성들입니다.
이런 값들이 어떤 값을 갖고 있는가에 따라서 이 파일이 열려 있는지 닫혀 있는지 확인을 할 수가 있는 것이지요.

결과가 어떤지 실행을 통해서 보겠습니다.
지금 작성한 파일이 with_open_close입니다.
맨 마지막에 있네요.
실행을 시켜보겠습니다.
실행을 했더니 MySomeException이라고 하는 Exception은 발생했지만 별로 이유가 없지요.
없으니까 이유는 나타나지 않았습니다.

그러고 나서 with 구문이 완전히 예외에 의해서 강제적으로 끝난 후에 Outside try-with라는 이 구문, 이런 try하고 with 구문을 다 실행을 해서 벗어난 다음에 어떤 내용이 나오는가.
f1.closed, f2.closed라는 것은 모두 True이다.
이것은 두 파일이 모두 닫혀 있다는 것입니다.

지난 첫 시간에 말씀드렸듯이 with 구문에서 with-suite를 실행하다가 예외가 발생해서 강제적으로 프로그램이 다른 곳으로 벗어난다 하더라도 with 구문은 항상 닫아야 되는 파일은 닫고 나간다 하는 것을 어떤 경우에도 파일은 닫고 나간다는 것을 말씀을 드렸는데.
그 내용을 여기에서 입증 또는 확인을 할 수 있는 실습이 된 것입니다.


이제는 본격적으로 파일을 읽는 과정을 실습을 해 보겠습니다.
파일을 읽는 과정을 실습하기 위해서 myTextFile_to_read.dat를 준비를 해야 되는데.
그 파일이 제대로 지금 있는지 확인을 해 보겠습니다.

myTextFile_to_read.
처음에 넣었던 그 내용이 그대로 남아 있네요.
그럼 이 파일을 가지고 read 하는 과정을 실습을 해 보겠습니다.
먼저 read로 이런 TextFile을 여는 과정을 코딩을 해 보겠습니다.
코드의 이름은 새로운 코드를 넣고 코드의 이름은 read_myTextFile.py라고 해 보겠습니다.
코드를 집어넣어보겠습니다.

코딩이 됐습니다.
먼저 파일을 열어야 되지요.
이제는 with 구문을 알고 있기 때문에 with 구문을 사용을 했습니다.
with 구문을 통해서 myTextFile_to_read.dat 파일을 열고 그 파일 객체에 참조를 f에 배정을 했습니다.
이제 f.read 메소드로서 파일의 내용을 전부 읽어서 contents라고 하는 참조에 넣고.
그 contents를 print를 했습니다.

어떤 내용이 나올까 보겠습니다.
read_myTextFile를 run을 시켜보겠습니다.
나온 내용이 이렇게 하나, 둘, 셋, 넷.
네 개의 명언이지요, 일종의.
그 명언이 나옴을 볼 수 있습니다.
과연 그 명언이 같은 명언인지 데이터 파일을 찾아서 한번 보도록 하겠습니다.
어딘가 숨어서 지금 잘 보이지가 않네요.

데이터 파일이 여기 있네요.
하나, 둘, 셋, 네 개의 명언이 그대로 다 print가 돼서 결과로 출력이 됐음을 확인을 할 수가 있습니다.
이렇게 소스 코드를 다시 보면 read에서 인수를 주지 않았지요.
이런 경우에는 파일의 처음부터 끝까지 모두 읽어서 print를 한 경우가 되겠습니다.

그다음에는 readlines 여러 줄을 읽는 메소드를 이용해서 파일을 읽는 과정을 실습을 해 보겠습니다.
코딩을 하기 위해서 파일을 만들겠습니다.
소스 코드 파일을 만들겠습니다.
이름은 readlines_myTextFile.py라는 이름으로 파일을 만들고 이제 코드를 넣도록 하겠습니다.
코딩이 됐습니다.

맨 위에 보시면 with open('myTextFile_to_read.dat')를 열어서 파일 객체를 f에 배정을 했고요.
with-suite에서는 바로 f.readlines라고 하는 메소드를 사용을 했습니다.
어떤 이름을 가진 참조에다 주었냐면 배정을 했냐면 line_list이라는 이름을 가진 객체 참조에다가 배정을 했습니다.
그리고 print를 했습니다.

결과는 무엇일까요?
보시면 출력의 시작과 끝이 대괄호로 닫혀 있습니다.
리스트가 되겠지요.
그럼 아이템은 뭐가 될까요?
I've had a perfectly wonderful evening, but this wasn't까지 한 줄이 한 아이템이 되는 것이지요.

두 번째 아이템은 사람의 이름, Groucho Marx라고 하는 것이 두 번째 아이템이 됩니다.
이렇게 이 리스트의 각각의 아이템은 파일의 각각의 줄을 구성하는 문자열이 된다는 것이지요.
이런 모습의 출력을 readlines가 내놓는 것입니다.

만일 여기에 50이라고 한다면 어떤 현상이 나타날까요?
50이라고 하는 argument, 사이즈 힌트를 50이라는 값으로 주었을 때는 첫째 줄이 나오게 될 것입니다.
이 첫째 줄 하나의 길이가 50자를 넘기 때문에 이 정도까지 걸리게 되겠지요.
그러면 한 자라도 걸려 있는 줄의 전체를 출력을 한다고 했으니까 이 줄의 끝까지 출력이 되는 것입니다.

만일 100이라고 썼다면 이 size 힌트를 100이라는 값으로 주었다면 이 한 줄의 길이가 지금 100자같이 보이지는 않습니다.
그래서 이 정도까지 아마 걸려 있겠지요.

그럼 두 번째 줄, 세 번째 줄까지 걸려 있다면 100자 정도 되는 문자수가 그렇다면 이 세 개 줄이 지금 이 세 줄.
하나, 둘, 세 번째 줄까지 이 전체가 readlines를 통해서 리턴이 되고 print가 될 것입니다.
그 과정에 대해서는 여러분이 한번 직접 해 보시기 바라고요.
여기에서는 실습을 하지 않도록 하겠습니다.
그래서 다음 단계로 넘어가겠습니다.

이번 단계는 readline으로 text를 읽는 과정을 실습을 해 보도록 하겠습니다.
readline 역시 이름 붙이는 규칙은 똑같으니까 동사 먼저 쓰고 readline 또 형용사 my 그다음에 명사 첫째 글자는 대문자.
myTextFile.dat.
dat가 아니라 파이썬 프로그램 파일이지요.
넣고 코딩을 하겠습니다.

코딩 길지 않으니까 바로 끝났습니다.
with open('myTextFile_to_read.dat') as f:로 해서 f에 대한 메소드 readline으로서 한 줄을 읽어내는 작업을 하고 그 한 줄을 print를 하는 프로그램입니다.
실행을 시켜보겠습니다.
readline_myTextFile.
이렇게 한 줄이 딱 출력이 됐습니다.
확인이 됐지요.

그다음 다음번 기능을 확인을 해 보겠습니다.
readline을 이용해서 파일 전체를 읽고 싶다.
이런 경우는 어떻게 해야 될까요?
파일이 만일 10줄로 구성돼 있다.
조금 전처럼 여러 줄로 구성돼 있는 데이터 파일이라 할 경우에는 readline을 줄 수만큼 반복을 시켜주면 되는 거지요.
그런 반복 구문 형태로 사용되는 readline에 대해서 코딩을 해 보겠습니다.

새로운 파일을 또 코딩을 하겠습니다.
repeated_readline_myTextFile.py라는 이름으로 코딩을 하겠습니다.
코딩을 마쳤고요.
구조를 보시면 with 구문으로서 전체 문맥을 관리를 합니다.
먼저 open을 했고 open을 한 상태에서 readline으로서 한 줄을 읽습니다.
읽고 파일 루프로 들어갑니다.

이 파일 루프에서 파일 구문이 하는 일은 one_line이라고 하는 것이 과연 어떤 문자를 가진 빈 줄이 아닌 한 문자라도 가진 줄을 뜻하는 것인지 체크를 합니다.
만일 파일에서 컨디션의 상태를 보는 거는 값으로 보게 되지요.
False냐 True냐 하는 거짓이냐 참이냐 하는 것만으로 보게 되는데.
여기에 one_line이라는 줄에 아무런 문자도 들어 있지 않다면 이때에는 False가 나오게 됩니다.

그리고 한 문자라도 들어가 있다면 True가 나오게 되는 것이지요.
이런 암묵적인 bool-유형으로 변환, 스트링이 bool-유형으로 변환되는 모습을 여기서 우리는 또 예상을 할 수가 있습니다.
그리고 파일 루프를 통해서 한 줄 한 줄 print를 하는 것이지요.

여기에 end는 null로 넣었는데 print라는 함수는 기본적으로 newline을 줄 끝으로 삼아줍니다.
그리고 임의로 그 end 라인을 하나 끼워 넣게 되는 것이지요.
그렇게 하면 더블 스페이스가 돼버립니다.
한 줄 쓰고 한 줄 비우고 또 한 줄 쓰고 한 줄 비우는 형태로 드문드문하게 줄이 형성이 되기 때문에 좀 보기가 싫지요.

그리고 아래, 위로 너무 길어지게 되고 그러니까 print가 끼워 넣는 newline 대신에 null 문자를 넣도록 함으로써 아무 짓도 안 하도록 해 주는 것입니다.
그렇게 하면 촘촘하게 아래, 위가 붙어 있는 줄로서 나타나게 되는 것이지요.
그런 상태에서 파일 루프를 통해서 계속 readline을 하고 파일 루프에서 one_line에 실제 읽혀진 줄이 있는가.

또 있으면 print 하고 또 readline을 하고 그다음에 또 파일 구문에서 테스트를 하고.
그래서 null 라인이 나오면 비어 있는 빈 줄이 나오게 되면 이때 False가 되기 때문에 파일 루프에서 벗어나게 되는 것이지요.

그 상태는 무엇을 의미하냐면 파일의 끝까지 읽었다, 더 이상 읽을 것이 없다, 읽을 줄이 없다는 것을 뜻하는 것입니다.
실행을 해 보겠습니다.
repeated_readline 실행.
우리가 예상하듯이 데이터 파일이 가지고 있는 모든 내용을 print를 한 것을 확인을 할 수가 있습니다.

이제 read를 마치고 write, 즉 쓰기로 들어가겠습니다.
쓰기에 대한 실습을 해 보겠습니다.
쓰기에서 실습을 위해서 우선 Names.dat 파일을 아래와 같은 내용으로 준비를 하겠습니다.
조금 전에 있던 이 명언 파일은 상당히 길기 때문에 좀 더 간단한 구조를 갖춰보기 위해서 데이터 파일을 하나 더 만들어보겠습니다.

그것은 이름을 Names.dat로 정해 보겠습니다.
그리고 여기에는 우리에게 친숙한 이름을 넣어보겠습니다.
을지문덕, 김유신, 계백이 들어 있습니다.
이 파일을 다시 읽어서 write 하는 프로그램을 작성을 하고자 하는 것입니다.
그 파일의 이름을 뭐라고 할까요?
write_myTextFile.py로 하겠습니다.
코딩된 모습을 함께 보시겠습니다.
with가 현재 몇 개가 있지요?
3개가 있습니다.
처음 with는 이중 with입니다.

바깥에 있는 with는 파일을 열고 두 번째 안쪽에 있는 with는 새로운 파일을 write mode로서 열고 읽은 파일로부터 얻은 데이터를 write mode로 열린 파일로 쓰는 과정이 보여지고 있습니다.

이때 한글을 사용하고 있지요.
앞에서 보셨던 데이터 파일도 다 한글입니다.
그 한글 코딩 방식은 유니코드이기 때문에 utf-8라고 하는 유니코드를 encoding으로서 주어서 open을 시켰습니다.
open을 할 때 다 encoding, utf-8을 써서 줘야 되는 것이지요.
write 하기 위해서 open한 파일은 f2에 배정을 했습니다.
그럼 with-suite를 보면 contents에는 read 메소드를 통해서 파일 전체를 다 읽어서 contents에 넣었습니다.
그리고 tell 메소드로서 현재 파일 포인터가 어디에 있는지 보니까 EOF 포지션에 있음을 알 수 있겠지요.

그리고 읽어낸 실제 파일의 길이가 몇 자인지 몇 bite인지 bite 수를 print를 하기 위한 것입니다.
그러고 나서 contents를 print를 하고 그 contents를 다시 파일에다가 write를 시켜주는 모습입니다.
또 write된 파일에 EOF 포지션을 print 함으로써 이 파일의 size가 얼마인지 보는 것이지요.

그러고 나서 다시 강감찬이라고 하는 문자 한 줄을 문자열을 파일에다가 write를 시켰습니다.
그러고 나서 다시 EOF 포지션을 확인을 했습니다.
어떤 값이 나올지 보도록 하면 이 강감찬으로 해서 얼마만큼의 파일 size가 늘어났는지 확인을 할 수가 있는 것입니다.
그렇게 한 다음에 두 파일을 닫으면서 with 구문을 다 끝냈고요.

그다음에 새로운 with 구문이 열렸습니다.
목적은 쓰여져 있는 write.dat 파일을 다시 한번 읽어서 읽기 모드로 읽어서 속에 있는 내용이 어떻게 변했는지 전체를 출력을 시켜보는 과정이 되겠습니다.
그렇게 함으로써 이 프로그램을 끝낸 것입니다.

실행을 시켜보겠습니다.
이렇게 우선 실행이 됐는데요.
이 내용을 확인을 하려니까 윈도우를 조금 위로 끌어올려야겠네요.
처음에 EOF 포지션은 33이었습니다.
즉 우리가 읽어 들인 파일의 크기가 33bite라는 뜻이지요.
여기에 그 내용을 보니까 을지문덕, 김유신, 계백이 나왔고.
이걸 그대로 썼더니 역시 33bite가 나온 건 당연하겠지요.

그다음에 46이라고 나온 것은 강감찬이라는 이름이 들어가서 증가가 된 것입니다.
즉 얼마가 증가가 됐지요?
13bite가 증가가 된 것입니다.
13bite 증가가 강감찬으로 인해서 된 것이지요.
보면 유니코드는 한 문자를 적게는 2bite부터 많게는 4bite까지 가변적으로 코드의 길이가 다르게 표현이 될 수가 있습니다.

그래서 이 강감찬도 원래 한글로는 세 글자이지만 그다음에 뉴 라인들이 둘러싸고 있어서 어떻게 보면 다섯 자밖에 안 되는 것이 아닌가라고 보겠지만 이게 각각의 한 글자 한 글자가 많게는 4bite, 또는 3bite 정도로 표현이 되기 때문에 그 길이가 전체가 13bite 정도가 나오는 것입니다.

이렇게 해서 f2 사이즈도 역시 46bite고 이 결과도 확인을 했습니다.
write 한 결과도 확인을 한 것입니다.
이렇게 쓰기 실습에 대한 코딩을 하고 결과를 확인을 해 보았습니다.

다음에는 writelines 메소드를 사용하는 과정을 실습을 해 보겠습니다.
여기에서 실습을 하는 과정도 코딩을 하기 위해서 파일 이름을 생성을 하면서 지어보겠습니다.
writelines_myTextFile.py로 하겠습니다.
코딩을 해 보겠습니다.

코딩을 한번 보시기 바랍니다.
우선 원래 샘플 데이터 파일은 동일합니다.
myName_to_read.dat 즉 write 실습 과정을 위해서 작성을 했던 파일을 그대로 사용하고 있고요.

그다음에 보시면 또 myName_to_write.dat 이 파일은 이미 앞에서 실습 과정에서 만들어져 있기는 하지만 그 내용은 별 의미가 없습니다.
write mode로서 open을 함과 동시에 원래 있던 내용은 없어지게 되지요.

그런데 특이할 만한 점은 write의 경우는 read로서 파일을 읽었는데 지금은 readlines로서 읽게 됩니다.
readlines로 읽으면 각 줄을 항목으로 하는 리스트가 contents에 들어오게 되지요.
그 contents는 리스트 형태가 되는 것입니다.
파일 내용 그 자체가 되는 것이 아니고 리스트의 형태가 됩니다.

바로 이 리스트의 형태로 된 것을 writelines에 주면 다시 원래 상태로 풀어서 파일에다가 넣어주게 되는 것입니다.
그리고 그런 과정들을 통해서 파일 포인터의 포지션이 어떻게 변하는지 tell로서 그 위치들을 확인을 해 보았습니다.
또 최종적으로 이 파일이 어떤 내용이 들어가 있는지 파일에 어떤 내용이 들어가 있는지 확인을 해 본 것입니다.

실행을 시켜보겠습니다.
실행을 했는데요.
원래 샘플 파일은 33bite.
기억나시지요?
그다음에 파일에서 읽어낸 결과는 readlines로 읽었기 때문에 이렇게 각 줄을 항목으로 하는 세 개 줄이었는데.
그 세 개 줄을 세 개 항목으로 하는 리스트가 나온 것입니다.
그 리스트를 다시, 이게 contents의 내용이지요.

지금 어디에서 이 내용이 print가 된 거냐면 바로 이 부분입니다.
print contents.
그리고 그 contents를 바로 writelines를 통해서 파일에다가 넣었습니다.
썼습니다.
쓰고 f2의 EOF는 33이지요.
추가가 된 건 없기 때문에 33bite가 그대로 들어가 있게 된 것이고.

그다음에 강감찬이라고 하는 한 항목을 가진 리스트를 writelines에 다시 넣어서 파일에다가 write를 했습니다.
그러고 나서 EOF에 대한 파일 포인터 포지션을 측정을 했더니 이제는 46이 나왔습니다.

앞 경우와 write를 실습한 경우와 같은 포지션이 된 것이지요.
또 파일의 내용을 보니까 을지문덕, 김유신, 계백 한 줄 띄고 강감찬 또 한 줄 띄고까지가 파일 내용이 됐음을 알 수 있습니다.
앞에서 보셨던 write의 동작이 writelines에서도 똑같이 일어난 것을 확인을 할 수가 있는데.

다만 차이가 있다면 write라고 하는 것은 파일 내용을 평평하게 그대로 순수하게 받아서 순수하게 넣어줄 뿐인데.
이 writelines는 다른 점이 리스트로 받아서 순수한 모습으로 바꾸어서 파일에다가 넣어준다 하는 것이 다른 점이라고 할 수가 있습니다.

그다음에는 기존 내용에 새 내용을 겹쳐 쓰는 그런 과정을 실습을 해 보도록 하겠습니다.
우선 코딩을 통해서 실습을 해 보겠습니다.
파일 이름을 뭐라고 할까요?
overwrite라고 할까요?
우선 겹쳐 쓰기에 대한 실습이기 때문에 overwrite_myTextFile.py로 하겠습니다.
코딩을 해 보겠습니다.

코딩 내용을 한번 보시겠습니다.
먼저 myText_to_overwrite.dat라는 파일을 update w+ mode로 open을 했습니다.
만일 myText_to_overwrite.dat 파일이 없다면 새로 생성을 하겠지요.
만일 있었다면 그 내용을 전부 비워버리고 빈껍데기만 남기고 열어주겠지요.
그런 차이가 있습니다.

그런 파일의 객체 참조를 f에다 배정을 했습니다.
그러고 나서 a를 50개 쭉 write를 했습니다.
a라는 스트링 곱하기 50 하면 a를 50배를 하는 것이지요.
그다음에 파일 포인터가 어디에 있는지 tell을 통해서 print를 해 보았고.
다시 f.seek을 통해서 파일의 시작으로 포인터를 되돌렸습니다.

그러고 나서 읽도록 하고 또 seek(25)를 해서 옵셋을 25를 주어서 처음 파일의 시작부터 25번째 포인터가 들어가도록 했습니다.
이런 과정을 통해서 그 중간에 b라는 25번째부터 b를 10개를 overwrite 시키겠다는 거지요.
바로 이 부분이 핵심이 되는 것입니다.

overwrite는 바로 이 부분입니다.
그리고 파일 포인터를 다시 확인을 하고 그다음에 파일 내용을 읽어서 전체를 읽어보기 위해서 파일 포인터를 다시 0으로 되돌렸습니다.
즉 BOF bigin of file로 되돌린 것이지요.

이런 과정의 프로그램을 실행을 시켜보겠습니다.
실행이 됐습니다.
어떻게 됐는지 보겠습니다.
조금 위로 올려보겠습니다.
처음에 myText_to_overwrite.dat 파일은 a를 50개 가지고 있었습니다.
그 EOF에 해당하는 포지션의 위치는 50이었지요.
그리고 내용을 찍어보니까 a가 50개 들어 있음을 확인할 수가 있지요.
그리고 나서 파일 포인터를 중간 25 정도에 넣고 여기서부터 b를 overwrite 시킨 것이지요.

예상대로 b가 중간에 끼어 들어가 있고 원래 있었던 a는 전부 b로 overwrite가 돼 있음을 볼 수 있습니다.
전체적인 파일의 사이즈는 변하지 않았습니다.
그대로 50이 유지가 된 것이지요.
overwrite 됐기 때문에 그렇지요.
이것이 파일에 대한 쓰기를 통해서 overwrite 시킨 예를 실습을 한 결과입니다.

다음에는 새 내용을 추가를 하는 과정을 실습을 해 보겠습니다.
이를 위한 프로그램 소스 코드 파일 이름을 어떻게 정하면 될까요?
append라고 정해 보겠습니다.
append_myTextFile.py로 정해 보겠습니다.

그리고 코딩을 하겠습니다.
코딩이 완성이 됐습니다.
내용을 보시면 지금 myText_to_append.dat를 append 하면서 read도 할 수 있는 mode로 open을 한 것입니다.
그리고 역시 50개의 a를 write를 했고 그다음에 그 중간쯤 30번째 정도 되는 위치로 포인터를 옮겨서 그 결과도 확인을 했습니다.
과연 포인터가 30으로 이동을 했는지.
이동을 했고요.

그다음에 여기에다 write를 했습니다, z를.
write를 한 의도는 뭐지요?
30번째에다가 z라고 하는 글자를 10개를 overwrite 시키겠다는 의도로 넣은 것 같습니다.
그런데 과연 overwrite가 됐는지.
앞에서 말씀드렸을 때에는 overwrite 되는 게 아니고 어쨌든 뒤에 추가가 된다, append가 된다고 말씀을 드렸지요.

그게 과연 이루어지는지도 확인을 해 보겠습니다.
그러고 나서 f.read를 통해서 파일 전체를 확인을 한 것입니다.
z가 어떻게 이 파일 안으로 들어가 있는지, 어디에 들어가 있는지 확인을 하겠다고 하는 것입니다.

그래서 실행을 시켜보겠습니다.
append.
보겠습니다.
실행이 됐습니다.
보시면 f.tell은 분명히 포인터가 30번째에 있다고 했는데 이 정도에 z가 들어간 것이 아니고 그 끝에 z가 추가가 돼 있음을 볼 수가 있습니다.
이때 f.tell이 여기에 30을 보이고 있다,
포인터가 30에 있다 하는 그 의미는 read 할 때는 유효합니다.
이 상태에서 read 한다면 바로 여기부터 30번째부터 읽혀지는 것이지요.
그래서 a부터 끝까지 읽으면 z 이 정도 길이가 읽혀질 텐데.
write 할 때는 무조건 append가 돼버리는 것입니다.
그런 차이가 있습니다.

그리고 앞에서도 그렇고 지금도 그렇고 overwrite 때나 현재 append일 때나 전부 update 기능을 주어서 쓴 파일을 쓰기 용도로 열어놓은 파일을 닫고 다시 read 용도로 열지 않더라도.
이 파일을 그대로 읽을 수 있도록 하기 위해서 update mode를 추가를 한 것입니다.

만일 이 update mode가 없었다면 일단은 write 한 또는 append 한 파일을 닫고 다시 읽기 모드를 열어서 그 내용을 확인을 했어야 되겠지요.
그렇지만 update mode가 같이 붙어 있기 때문에 굳이 그렇게 닫고 열고 할 필요 없이 그냥 열려 있는 상태에서 그대로 읽기도 가능했던 것입니다.
지금까지 우리는 하나의 파일을 열고 그 파일을 내용을 읽어내고 또 쓰는 과정에 대해서 실습을 통해서 각 모든 기능들이 동작을 하는 모습을 확인을 해 보았습니다.
